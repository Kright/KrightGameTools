// Copyright (c) 2025 Igor Slobodskov
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm>
#include <array>
#include <cmath>
#include <concepts>
#include <ostream>
#include <span>
#include <type_traits>
#include <utility>
#include <vector>

// generated by com.github.kright.pga3d.codegen.cpp.CustomAmalgamate

// typesForward.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Multivector;
    struct Motor;
    struct Plane;
    struct Bivector;
    struct ProjectivePoint;
    struct Quaternion;
    struct ProjectiveTranslator;
    struct Translator;
    struct Vector;
    struct Point;
    struct PlaneIdeal;
    struct BivectorBulk;
    struct BivectorWeight;
    struct PseudoScalar;
    struct PointCenter;
    struct QuaternionWithTranslator;
    struct TranslatorWithQuaternion;
}

// Multivector.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Multivector {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double s = 0.0;
        double w = 0.0;
        double x = 0.0;
        double y = 0.0;
        double z = 0.0;
        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;
        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;
        double wxy = 0.0;
        double wxz = 0.0;
        double wyz = 0.0;
        double xyz = 0.0;
        double i = 0.0;

        static constexpr size_t componentsCount = 16;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { s, w, x, y, z, wx, wy, wz, xy, xz, yz, wxy, wxz, wyz, xyz, i }; }
        [[nodiscard]] static constexpr Multivector from(const std::array<double, componentsCount>& values) noexcept { return { .s = values[0], .w = values[1], .x = values[2], .y = values[3], .z = values[4], .wx = values[5], .wy = values[6], .wz = values[7], .xy = values[8], .xz = values[9], .yz = values[10], .wxy = values[11], .wxz = values[12], .wyz = values[13], .xyz = values[14], .i = values[15] }; }
        [[nodiscard]] static constexpr Multivector from(const std::span<double, componentsCount>& values) noexcept { return { .s = values[0], .w = values[1], .x = values[2], .y = values[3], .z = values[4], .wx = values[5], .wy = values[6], .wz = values[7], .xy = values[8], .xz = values[9], .yz = values[10], .wxy = values[11], .wxz = values[12], .wyz = values[13], .xyz = values[14], .i = values[15] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Multivector dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Multivector weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr Multivector bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Multivector reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Multivector antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Motor toMotorUnsafe() const noexcept;
        [[nodiscard]] constexpr Plane toPlaneUnsafe() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectivePoint toProjectivePointUnsafe() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr Vector toVectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Point toPointUnsafe() const noexcept;
        [[nodiscard]] constexpr PlaneIdeal toPlaneIdealUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorBulk toBivectorBulkUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline Multivector madd(const Multivector& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Multivector normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Multivector normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Multivector normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Multivector wedge(const Multivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Multivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector join(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Multivector sandwich(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Multivector& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Multivector>);
    static_assert(sizeof(Multivector) == 8 * Multivector::componentsCount, "Multivector must be exactly 128 bytes");
}

// Motor.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Motor {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double s = 0.0;
        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;
        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;
        double i = 0.0;

        static constexpr size_t componentsCount = 8;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { s, wx, wy, wz, xy, xz, yz, i }; }
        [[nodiscard]] static constexpr Motor from(const std::array<double, componentsCount>& values) noexcept { return { .s = values[0], .wx = values[1], .wy = values[2], .wz = values[3], .xy = values[4], .xz = values[5], .yz = values[6], .i = values[7] }; }
        [[nodiscard]] static constexpr Motor from(const std::span<double, componentsCount>& values) noexcept { return { .s = values[0], .wx = values[1], .wy = values[2], .wz = values[3], .xy = values[4], .xz = values[5], .yz = values[6], .i = values[7] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.MotorOpsGenerator

        [[nodiscard]] static constexpr Motor id() noexcept { return { .s = 1.0 }; };

        [[nodiscard]] static constexpr Motor addVector(const Vector& v) noexcept;

        [[nodiscard]] inline Bivector log() const noexcept;
        [[nodiscard]] inline Motor pow(double p) const noexcept;

        [[nodiscard]] constexpr QuaternionWithTranslator toQuaternionWithTranslator() const noexcept;
        [[nodiscard]] constexpr TranslatorWithQuaternion toTranslatorWithQuaternion() const noexcept;

        [[nodiscard]] inline Motor renormalized() const noexcept;

        [[nodiscard]] constexpr Vector axisX() const noexcept;
        [[nodiscard]] constexpr Vector axisY() const noexcept;
        [[nodiscard]] constexpr Vector axisZ() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Motor dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Motor weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr Quaternion bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Motor reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Motor antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorBulk toBivectorBulkUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline Motor madd(const Motor& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Motor normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Motor normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Motor normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Motor antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Quaternion join(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector join(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Quaternion join(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Motor join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr Multivector join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichAsMatrix

        [[nodiscard]] constexpr std::array<double, 16> sandwichAsMatrixForProjectivePoint() const noexcept;
        [[nodiscard]] constexpr std::array<double, 9> sandwichAsMatrixForVector() const noexcept;
        [[nodiscard]] constexpr std::array<double, 36> sandwichAsMatrixForBivector() const noexcept;
        [[nodiscard]] constexpr std::array<double, 16> sandwichAsMatrixForPlane() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Bivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Motor>);
    static_assert(sizeof(Motor) == 8 * Motor::componentsCount, "Motor must be exactly 64 bytes");
}

// Plane.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Plane {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;
        double w = 0.0;

        static constexpr size_t componentsCount = 4;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z, w }; }
        [[nodiscard]] static constexpr Plane from(const std::array<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2], .w = values[3] }; }
        [[nodiscard]] static constexpr Plane from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2], .w = values[3] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr ProjectivePoint dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Plane weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr PlaneIdeal bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Plane reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Plane antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr PlaneIdeal toPlaneIdealUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline Plane madd(const Plane& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Plane normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Plane normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Plane normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Multivector wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector meet(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Plane antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr double join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double join(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr double join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Plane>);
    static_assert(sizeof(Plane) == 8 * Plane::componentsCount, "Plane must be exactly 32 bytes");
}

// Bivector.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Bivector {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;
        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;

        static constexpr size_t componentsCount = 6;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { wx, wy, wz, xy, xz, yz }; }
        [[nodiscard]] static constexpr Bivector from(const std::array<double, componentsCount>& values) noexcept { return { .wx = values[0], .wy = values[1], .wz = values[2], .xy = values[3], .xz = values[4], .yz = values[5] }; }
        [[nodiscard]] static constexpr Bivector from(const std::span<double, componentsCount>& values) noexcept { return { .wx = values[0], .wy = values[1], .wz = values[2], .xy = values[3], .xz = values[4], .yz = values[5] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorOpsGenerator

        [[nodiscard]] inline std::pair<Bivector, BivectorWeight> split() const noexcept;

        [[nodiscard]] inline Motor exp() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Bivector dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr BivectorWeight weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr BivectorBulk bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Bivector reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Bivector antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorBulk toBivectorBulkUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline Bivector madd(const Bivector& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Bivector normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Bivector normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Bivector normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

        [[nodiscard]] constexpr Bivector projectOntoPlane(const Plane& plane) const noexcept;
        [[nodiscard]] constexpr Bivector projectOntoPlane(const PlaneIdeal& plane) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr double dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const BivectorWeight& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Motor antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr double join(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr double join(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr double join(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr double join(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr double join(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Bivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Bivector>);
    static_assert(sizeof(Bivector) == 8 * Bivector::componentsCount, "Bivector must be exactly 48 bytes");
}

// ProjectivePoint.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct ProjectivePoint {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;
        double w = 0.0;

        static constexpr size_t componentsCount = 4;

        [[nodiscard]] constexpr double wyz() const noexcept { return -x; }
        [[nodiscard]] constexpr double wxz() const noexcept { return y; }
        [[nodiscard]] constexpr double wxy() const noexcept { return -z; }
        [[nodiscard]] constexpr double xyz() const noexcept { return w; }

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z, w }; }
        [[nodiscard]] static constexpr ProjectivePoint from(const std::array<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2], .w = values[3] }; }
        [[nodiscard]] static constexpr ProjectivePoint from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2], .w = values[3] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructStaticConstructorGenerator

        [[nodiscard]] static constexpr ProjectivePoint blade3(double wxy = 0.0, double wxz = 0.0, double wyz = 0.0, double xyz = 0.0) noexcept { return {.x = -wyz, .y = wxz, .z = -wxy, .w = xyz}; }
        [[nodiscard]] static constexpr ProjectivePoint interpolate(const ProjectivePoint& a, const ProjectivePoint& b, double t) noexcept { return {.x = a.x * (1.0 - t) + b.x * t, .y = a.y * (1.0 - t) + b.y * t, .z = a.z * (1.0 - t) + b.z * t, .w = a.w * (1.0 - t) + b.w * t}; }
        [[nodiscard]] static constexpr ProjectivePoint mid(const ProjectivePoint& a, const ProjectivePoint& b) noexcept { return {.x = 0.5 * (a.x + b.x), .y = 0.5 * (a.y + b.y), .z = 0.5 * (a.z + b.z), .w = 0.5 * (a.w + b.w)}; }
        [[nodiscard]] static constexpr ProjectivePoint mid(const ProjectivePoint& a, const ProjectivePoint& b, const ProjectivePoint& c) noexcept { return {.x = (1.0 / 3.0) * (a.x + b.x + c.x), .y = (1.0 / 3.0) * (a.y + b.y + c.y), .z = (1.0 / 3.0) * (a.z + b.z + c.z), .w = (1.0 / 3.0) * (a.w + b.w + c.w)}; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Plane dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Vector weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr ProjectivePoint bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr ProjectivePoint reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr ProjectivePoint antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Vector toVectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Point toPointUnsafe() const noexcept;
        [[nodiscard]] constexpr Point toPoint() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline ProjectivePoint madd(const ProjectivePoint& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const Plane& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const PlaneIdeal& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoLine(const Bivector& line) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr ProjectivePoint wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const PlaneIdeal& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr double join(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr double join(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<ProjectivePoint>);
    static_assert(sizeof(ProjectivePoint) == 8 * ProjectivePoint::componentsCount, "ProjectivePoint must be exactly 32 bytes");
}

// Quaternion.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Quaternion {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double s = 0.0;
        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;

        static constexpr size_t componentsCount = 4;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { s, xy, xz, yz }; }
        [[nodiscard]] static constexpr Quaternion from(const std::array<double, componentsCount>& values) noexcept { return { .s = values[0], .xy = values[1], .xz = values[2], .yz = values[3] }; }
        [[nodiscard]] static constexpr Quaternion from(const std::span<double, componentsCount>& values) noexcept { return { .s = values[0], .xy = values[1], .xz = values[2], .yz = values[3] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructStaticConstructorGenerator

        [[nodiscard]] static constexpr Quaternion id() noexcept { return {.s = 1.0}; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.QuaternionOpsGenerator

        [[nodiscard]] static inline Quaternion rotation(const Vector& from, const Vector& to) noexcept;
        [[nodiscard]] static inline Quaternion rotation(const PlaneIdeal& from, const PlaneIdeal& to) noexcept;

        [[nodiscard]] inline BivectorBulk log() const noexcept;
        [[nodiscard]] inline Quaternion pow(double p) const noexcept;

        [[nodiscard]] inline Quaternion projectToRotationInPlane(const PlaneIdeal& plane) const noexcept;
        [[nodiscard]] inline double restoreRotationInPlane(const PlaneIdeal& plane) const noexcept;

        [[nodiscard]] constexpr Vector axisX() const noexcept;
        [[nodiscard]] constexpr Vector axisY() const noexcept;
        [[nodiscard]] constexpr Vector axisZ() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Motor dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr Quaternion bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Quaternion reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Quaternion antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorBulk toBivectorBulkUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline Quaternion madd(const Quaternion& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Quaternion normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Quaternion normalizedByBulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Quaternion antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Quaternion antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Quaternion meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk meet(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Quaternion antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Quaternion join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr double join(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr double join(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr double join(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Quaternion join(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichAsMatrix

        [[nodiscard]] constexpr std::array<double, 16> sandwichAsMatrixForProjectivePoint() const noexcept;
        [[nodiscard]] constexpr std::array<double, 9> sandwichAsMatrixForVector() const noexcept;
        [[nodiscard]] constexpr std::array<double, 36> sandwichAsMatrixForBivector() const noexcept;
        [[nodiscard]] constexpr std::array<double, 16> sandwichAsMatrixForPlane() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Bivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Quaternion>);
    static_assert(sizeof(Quaternion) == 8 * Quaternion::componentsCount, "Quaternion must be exactly 32 bytes");
}

// ProjectiveTranslator.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct ProjectiveTranslator {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double s = 0.0;
        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;

        static constexpr size_t componentsCount = 4;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { s, wx, wy, wz }; }
        [[nodiscard]] static constexpr ProjectiveTranslator from(const std::array<double, componentsCount>& values) noexcept { return { .s = values[0], .wx = values[1], .wy = values[2], .wz = values[3] }; }
        [[nodiscard]] static constexpr ProjectiveTranslator from(const std::span<double, componentsCount>& values) noexcept { return { .s = values[0], .wx = values[1], .wy = values[2], .wz = values[3] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Motor dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr BivectorWeight weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr double bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslator() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline ProjectiveTranslator madd(const ProjectiveTranslator& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight meet(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr double join(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr double join(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr BivectorWeight cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<ProjectiveTranslator>);
    static_assert(sizeof(ProjectiveTranslator) == 8 * ProjectiveTranslator::componentsCount, "ProjectiveTranslator must be exactly 32 bytes");
}

// Translator.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Translator {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;

        static constexpr size_t componentsCount = 3;

        [[nodiscard]] constexpr double s() const noexcept { return 1.0; }

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { wx, wy, wz }; }
        [[nodiscard]] static constexpr Translator from(const std::array<double, componentsCount>& values) noexcept { return { .wx = values[0], .wy = values[1], .wz = values[2] }; }
        [[nodiscard]] static constexpr Translator from(const std::span<double, componentsCount>& values) noexcept { return { .wx = values[0], .wy = values[1], .wz = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.TranslatorOpsGenerator

        [[nodiscard]] static constexpr Translator id() noexcept { return {}; }
        [[nodiscard]] static constexpr Translator addVector(const Vector& v) noexcept;

        [[nodiscard]] constexpr BivectorWeight log() const noexcept;
        [[nodiscard]] constexpr Translator pow(double p) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Motor dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr BivectorWeight weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr double bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Translator reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Translator antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslator() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Point geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PointCenter dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Translator meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Point meet(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight meet(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PointCenter wedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr PointCenter meet(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr double join(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr double join(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr BivectorWeight cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Translator>);
    static_assert(sizeof(Translator) == 8 * Translator::componentsCount, "Translator must be exactly 24 bytes");
}

// Vector.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Vector {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;

        static constexpr size_t componentsCount = 3;

        [[nodiscard]] constexpr double wyz() const noexcept { return -x; }
        [[nodiscard]] constexpr double wxz() const noexcept { return y; }
        [[nodiscard]] constexpr double wxy() const noexcept { return -z; }

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z }; }
        [[nodiscard]] static constexpr Vector from(const std::array<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2] }; }
        [[nodiscard]] static constexpr Vector from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructStaticConstructorGenerator

        [[nodiscard]] static constexpr Vector blade3(double wxy = 0.0, double wxz = 0.0, double wyz = 0.0) noexcept { return {.x = -wyz, .y = wxz, .z = -wxy}; }
        [[nodiscard]] static constexpr Vector interpolate(const Vector& a, const Vector& b, double t) noexcept { return {.x = a.x * (1.0 - t) + b.x * t, .y = a.y * (1.0 - t) + b.y * t, .z = a.z * (1.0 - t) + b.z * t}; }
        [[nodiscard]] static constexpr Vector mid(const Vector& a, const Vector& b) noexcept { return {.x = 0.5 * (a.x + b.x), .y = 0.5 * (a.y + b.y), .z = 0.5 * (a.z + b.z)}; }
        [[nodiscard]] static constexpr Vector mid(const Vector& a, const Vector& b, const Vector& c) noexcept { return {.x = (1.0 / 3.0) * (a.x + b.x + c.x), .y = (1.0 / 3.0) * (a.y + b.y + c.y), .z = (1.0 / 3.0) * (a.z + b.z + c.z)}; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.VectorOpsGenerator

        [[nodiscard]] constexpr Vector min(const Vector& other) const noexcept;
        [[nodiscard]] constexpr Vector max(const Vector& other) const noexcept;
        [[nodiscard]] constexpr Vector clamp(const Vector& minV, const Vector& maxV) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr PlaneIdeal dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Vector weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Vector reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Vector antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr ProjectivePoint toProjectivePoint() const noexcept;
        [[nodiscard]] constexpr Point toPointUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline Vector madd(const Vector& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Vector normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Vector normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorBulk& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Vector wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const PlaneIdeal& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr double join(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr double join(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Vector join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Vector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Vector>);
    static_assert(sizeof(Vector) == 8 * Vector::componentsCount, "Vector must be exactly 24 bytes");
}

// Point.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Point {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;

        static constexpr size_t componentsCount = 3;

        [[nodiscard]] constexpr double w() const noexcept { return 1.0; }

        [[nodiscard]] constexpr double wyz() const noexcept { return -x; }
        [[nodiscard]] constexpr double wxz() const noexcept { return y; }
        [[nodiscard]] constexpr double wxy() const noexcept { return -z; }
        [[nodiscard]] constexpr double xyz() const noexcept { return 1.0; }

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z }; }
        [[nodiscard]] static constexpr Point from(const std::array<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2] }; }
        [[nodiscard]] static constexpr Point from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructStaticConstructorGenerator

        [[nodiscard]] static constexpr Point blade3(double wxy = 0.0, double wxz = 0.0, double wyz = 0.0) noexcept { return {.x = -wyz, .y = wxz, .z = -wxy}; }
        [[nodiscard]] static constexpr Point interpolate(const Point& a, const Point& b, double t) noexcept { return {.x = a.x * (1.0 - t) + b.x * t, .y = a.y * (1.0 - t) + b.y * t, .z = a.z * (1.0 - t) + b.z * t}; }
        [[nodiscard]] static constexpr Point mid(const Point& a, const Point& b) noexcept { return {.x = 0.5 * (a.x + b.x), .y = 0.5 * (a.y + b.y), .z = 0.5 * (a.z + b.z)}; }
        [[nodiscard]] static constexpr Point mid(const Point& a, const Point& b, const Point& c) noexcept { return {.x = (1.0 / 3.0) * (a.x + b.x + c.x), .y = (1.0 / 3.0) * (a.y + b.y + c.y), .z = (1.0 / 3.0) * (a.z + b.z + c.z)}; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.PointOpsGenerator

        [[nodiscard]] inline double distanceTo(const Point& other) const noexcept;

        [[nodiscard]] constexpr Point min(const Point& other) const noexcept;
        [[nodiscard]] constexpr Point max(const Point& other) const noexcept;
        [[nodiscard]] constexpr Point clamp(const Point& minV, const Point& maxV) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Plane dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Vector weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr PointCenter bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr ProjectivePoint reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Point antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr ProjectivePoint toProjectivePoint() const noexcept;
        [[nodiscard]] constexpr Vector toVectorUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline Point madd(const Vector& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const Plane& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const PlaneIdeal& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoLine(const Bivector& line) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Point geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Point dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr ProjectivePoint wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Point wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Point meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const PlaneIdeal& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr double join(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr double join(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Point>);
    static_assert(sizeof(Point) == 8 * Point::componentsCount, "Point must be exactly 24 bytes");
}

// PlaneIdeal.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct PlaneIdeal {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;

        static constexpr size_t componentsCount = 3;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z }; }
        [[nodiscard]] static constexpr PlaneIdeal from(const std::array<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2] }; }
        [[nodiscard]] static constexpr PlaneIdeal from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Vector dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr PlaneIdeal bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr PlaneIdeal reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr PlaneIdeal antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Plane toPlane() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline PlaneIdeal madd(const PlaneIdeal& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline PlaneIdeal normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline PlaneIdeal normalizedByBulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Multivector wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk meet(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const BivectorWeight& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr double join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double join(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PseudoScalar& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<PlaneIdeal>);
    static_assert(sizeof(PlaneIdeal) == 8 * PlaneIdeal::componentsCount, "PlaneIdeal must be exactly 24 bytes");
}

// BivectorBulk.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct BivectorBulk {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;

        static constexpr size_t componentsCount = 3;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { xy, xz, yz }; }
        [[nodiscard]] static constexpr BivectorBulk from(const std::array<double, componentsCount>& values) noexcept { return { .xy = values[0], .xz = values[1], .yz = values[2] }; }
        [[nodiscard]] static constexpr BivectorBulk from(const std::span<double, componentsCount>& values) noexcept { return { .xy = values[0], .xz = values[1], .yz = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorBulkOpsGenerator

        [[nodiscard]] inline Quaternion exp() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr BivectorWeight dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr BivectorBulk bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr BivectorBulk reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr BivectorBulk antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivector() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternion() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline BivectorBulk madd(const BivectorBulk& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline BivectorBulk normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline BivectorBulk normalizedByBulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Quaternion antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr double dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr BivectorBulk antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const BivectorWeight& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Quaternion antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Quaternion join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr double join(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr double join(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr double join(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk join(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Bivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<BivectorBulk>);
    static_assert(sizeof(BivectorBulk) == 8 * BivectorBulk::componentsCount, "BivectorBulk must be exactly 24 bytes");
}

// BivectorWeight.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct BivectorWeight {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;

        static constexpr size_t componentsCount = 3;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { wx, wy, wz }; }
        [[nodiscard]] static constexpr BivectorWeight from(const std::array<double, componentsCount>& values) noexcept { return { .wx = values[0], .wy = values[1], .wz = values[2] }; }
        [[nodiscard]] static constexpr BivectorWeight from(const std::span<double, componentsCount>& values) noexcept { return { .wx = values[0], .wy = values[1], .wz = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorWeightOpsGenerator

        [[nodiscard]] constexpr Translator exp() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr BivectorBulk dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr BivectorWeight weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr BivectorWeight reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr BivectorWeight antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivector() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslator() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline BivectorWeight madd(const BivectorWeight& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline BivectorWeight normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline BivectorWeight normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr BivectorWeight dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PlaneIdeal& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight meet(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Vector meet(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const BivectorBulk& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr double join(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr double join(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr BivectorWeight cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<BivectorWeight>);
    static_assert(sizeof(BivectorWeight) == 8 * BivectorWeight::componentsCount, "BivectorWeight must be exactly 24 bytes");
}

// PseudoScalar.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct PseudoScalar {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double i = 0.0;

        static constexpr size_t componentsCount = 1;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { i }; }
        [[nodiscard]] static constexpr PseudoScalar from(const std::array<double, componentsCount>& values) noexcept { return { .i = values[0] }; }
        [[nodiscard]] static constexpr PseudoScalar from(const std::span<double, componentsCount>& values) noexcept { return { .i = values[0] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr double dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr PseudoScalar weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr PseudoScalar reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr PseudoScalar antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] inline PseudoScalar madd(const PseudoScalar& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline PseudoScalar normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline PseudoScalar normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr PseudoScalar wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Translator& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Motor antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane join(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Quaternion join(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator join(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint join(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk join(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight join(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar join(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const PointCenter& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint join(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Vector cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<PseudoScalar>);
    static_assert(sizeof(PseudoScalar) == 8 * PseudoScalar::componentsCount, "PseudoScalar must be exactly 8 bytes");
}

// PointCenter.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct PointCenter {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        static constexpr size_t componentsCount = 0;

        [[nodiscard]] constexpr double x() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double y() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double z() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double w() const noexcept { return 1.0; }

        [[nodiscard]] constexpr double wyz() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double wxz() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double wxy() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double xyz() const noexcept { return 1.0; }

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return {  }; }
        [[nodiscard]] static constexpr PointCenter from(const std::array<double, componentsCount>& values) noexcept { return {  }; }
        [[nodiscard]] static constexpr PointCenter from(const std::span<double, componentsCount>& values) noexcept { return {  }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Plane dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr PointCenter bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr ProjectivePoint reversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr PointCenter antiReversed() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr ProjectivePoint toProjectivePoint() const noexcept;
        [[nodiscard]] constexpr Vector toVectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Point toPoint() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const Plane& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const PlaneIdeal& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoLine(const Bivector& line) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Point geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PointCenter dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr ProjectivePoint antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr ProjectivePoint wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar meet(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint meet(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PointCenter wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PointCenter meet(const Translator& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector join(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr double join(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk join(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk join(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk join(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal join(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint join(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PointCenter sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PseudoScalar& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<PointCenter>);
}

// TranslatorWithQuaternion.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.TranslatorWithQuaternionGenerator

namespace pga3d {

    struct TranslatorWithQuaternion {
        Translator translator{};
        Quaternion quaternion{};

        static size_t constexpr componentsCount = Quaternion::componentsCount + Translator::componentsCount;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept {
            // a compiler will optimize this
            return { translator.toArray()[0], translator.toArray()[1], translator.toArray()[2], quaternion.toArray()[0], quaternion.toArray()[1], quaternion.toArray()[2], quaternion.toArray()[3] };
        }

        [[nodiscard]] static constexpr TranslatorWithQuaternion from(const std::span<double, componentsCount>& values) noexcept {
            return {
                .translator = Translator::from(values.first<Translator::componentsCount>()),
                .quaternion = Quaternion::from(values.last<Quaternion::componentsCount>())
            };
        }

        [[nodiscard]] constexpr Motor toMotor() const noexcept { return translator.geometric(quaternion); }

        [[nodiscard]] constexpr QuaternionWithTranslator reversed() const noexcept;

        [[nodiscard]] constexpr QuaternionWithTranslator toQuaternionWithTranslator() const noexcept;

        [[nodiscard]] static constexpr TranslatorWithQuaternion id() noexcept { return { .translator = Translator::id(), .quaternion = Quaternion::id() }; }
    };

    struct QuaternionWithTranslator {
        Quaternion quaternion{};
        Translator translator{};

        static size_t constexpr componentsCount = Quaternion::componentsCount + Translator::componentsCount;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept {
            // a compiler will optimize this
            return { quaternion.toArray()[0], quaternion.toArray()[1], quaternion.toArray()[2], quaternion.toArray()[3], translator.toArray()[0], translator.toArray()[1], translator.toArray()[2] };
        }

        [[nodiscard]] static constexpr QuaternionWithTranslator from(const std::span<double, componentsCount>& values) noexcept {
            return {
                .quaternion = Quaternion::from(values.first<Quaternion::componentsCount>()),
                .translator = Translator::from(values.last<Translator::componentsCount>())
            };
        }

        [[nodiscard]] constexpr Motor toMotor() const noexcept { return quaternion.geometric(translator); }

        [[nodiscard]] constexpr TranslatorWithQuaternion reversed() const noexcept;

        [[nodiscard]] constexpr TranslatorWithQuaternion toTranslatorWithQuaternion() const noexcept;

        [[nodiscard]] static constexpr QuaternionWithTranslator id() noexcept { return { .quaternion = Quaternion::id(), .translator = Translator::id() }; }
    };

    [[nodiscard]] constexpr QuaternionWithTranslator TranslatorWithQuaternion::reversed() const noexcept { return { .quaternion = quaternion.reversed(), .translator = translator.reversed() }; }
    [[nodiscard]] constexpr QuaternionWithTranslator TranslatorWithQuaternion::toQuaternionWithTranslator() const noexcept { return { .quaternion = quaternion, .translator = quaternion.reversed().sandwich(translator).toTranslator() }; };
    [[nodiscard]] constexpr TranslatorWithQuaternion QuaternionWithTranslator::reversed() const noexcept { return { .translator = translator.reversed(), .quaternion = quaternion.reversed() }; }
    [[nodiscard]] constexpr TranslatorWithQuaternion QuaternionWithTranslator::toTranslatorWithQuaternion() const noexcept { return { .translator = quaternion.sandwich(translator).toTranslator(), .quaternion = quaternion }; };
}

// types.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

// opsArithmetic.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

namespace pga3d {
    [[nodiscard]] constexpr Multivector operator+(const Multivector& a, const Multivector& b) noexcept { return {
        .s = (a.s + b.s),
        .w = (a.w + b.w),
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z),
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz),
        .xy = (a.xy + b.xy),
        .xz = (a.xz + b.xz),
        .yz = (a.yz + b.yz),
        .wxy = (a.wxy + b.wxy),
        .wxz = (a.wxz + b.wxz),
        .wyz = (a.wyz + b.wyz),
        .xyz = (a.xyz + b.xyz),
        .i = (a.i + b.i)
    }; }
    constexpr Multivector& operator+=(Multivector& a, const Multivector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Multivector operator-(const Multivector& a, const Multivector& b) noexcept { return {
        .s = (a.s - b.s),
        .w = (a.w - b.w),
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z),
        .wx = (a.wx - b.wx),
        .wy = (a.wy - b.wy),
        .wz = (a.wz - b.wz),
        .xy = (a.xy - b.xy),
        .xz = (a.xz - b.xz),
        .yz = (a.yz - b.yz),
        .wxy = (a.wxy - b.wxy),
        .wxz = (a.wxz - b.wxz),
        .wyz = (a.wyz - b.wyz),
        .xyz = (a.xyz - b.xyz),
        .i = (a.i - b.i)
    }; }
    constexpr Multivector& operator-=(Multivector& a, const Multivector& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Motor operator+(const Motor& a, const Motor& b) noexcept { return {
        .s = (a.s + b.s),
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz),
        .xy = (a.xy + b.xy),
        .xz = (a.xz + b.xz),
        .yz = (a.yz + b.yz),
        .i = (a.i + b.i)
    }; }
    constexpr Motor& operator+=(Motor& a, const Motor& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Motor operator-(const Motor& a, const Motor& b) noexcept { return {
        .s = (a.s - b.s),
        .wx = (a.wx - b.wx),
        .wy = (a.wy - b.wy),
        .wz = (a.wz - b.wz),
        .xy = (a.xy - b.xy),
        .xz = (a.xz - b.xz),
        .yz = (a.yz - b.yz),
        .i = (a.i - b.i)
    }; }
    constexpr Motor& operator-=(Motor& a, const Motor& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Plane operator+(const Plane& a, const Plane& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z),
        .w = (a.w + b.w)
    }; }
    constexpr Plane& operator+=(Plane& a, const Plane& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Plane operator-(const Plane& a, const Plane& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z),
        .w = (a.w - b.w)
    }; }
    constexpr Plane& operator-=(Plane& a, const Plane& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Bivector operator+(const Bivector& a, const Bivector& b) noexcept { return {
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz),
        .xy = (a.xy + b.xy),
        .xz = (a.xz + b.xz),
        .yz = (a.yz + b.yz)
    }; }
    constexpr Bivector& operator+=(Bivector& a, const Bivector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Bivector operator-(const Bivector& a, const Bivector& b) noexcept { return {
        .wx = (a.wx - b.wx),
        .wy = (a.wy - b.wy),
        .wz = (a.wz - b.wz),
        .xy = (a.xy - b.xy),
        .xz = (a.xz - b.xz),
        .yz = (a.yz - b.yz)
    }; }
    constexpr Bivector& operator-=(Bivector& a, const Bivector& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr Bivector operator+(const Bivector& a, const BivectorBulk& b) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz,
        .xy = (a.xy + b.xy),
        .xz = (a.xz + b.xz),
        .yz = (a.yz + b.yz)
    }; }
    constexpr Bivector& operator+=(Bivector& a, const BivectorBulk& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Bivector operator-(const Bivector& a, const BivectorBulk& b) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz,
        .xy = (a.xy - b.xy),
        .xz = (a.xz - b.xz),
        .yz = (a.yz - b.yz)
    }; }
    constexpr Bivector& operator-=(Bivector& a, const BivectorBulk& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr Bivector operator+(const Bivector& a, const BivectorWeight& b) noexcept { return {
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz),
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }
    constexpr Bivector& operator+=(Bivector& a, const BivectorWeight& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Bivector operator-(const Bivector& a, const BivectorWeight& b) noexcept { return {
        .wx = (a.wx - b.wx),
        .wy = (a.wy - b.wy),
        .wz = (a.wz - b.wz),
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }
    constexpr Bivector& operator-=(Bivector& a, const BivectorWeight& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator+(const ProjectivePoint& a, const ProjectivePoint& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z),
        .w = (a.w + b.w)
    }; }
    constexpr ProjectivePoint& operator+=(ProjectivePoint& a, const ProjectivePoint& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const ProjectivePoint& a, const ProjectivePoint& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z),
        .w = (a.w - b.w)
    }; }
    constexpr ProjectivePoint& operator-=(ProjectivePoint& a, const ProjectivePoint& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator+(const ProjectivePoint& a, const Point& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z),
        .w = (1.0 + a.w)
    }; }
    constexpr ProjectivePoint& operator+=(ProjectivePoint& a, const Point& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const ProjectivePoint& a, const Point& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z),
        .w = (-1.0 + a.w)
    }; }
    constexpr ProjectivePoint& operator-=(ProjectivePoint& a, const Point& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator+(const ProjectivePoint& a, const Vector& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z),
        .w = a.w
    }; }
    constexpr ProjectivePoint& operator+=(ProjectivePoint& a, const Vector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const ProjectivePoint& a, const Vector& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z),
        .w = a.w
    }; }
    constexpr ProjectivePoint& operator-=(ProjectivePoint& a, const Vector& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Quaternion operator+(const Quaternion& a, const Quaternion& b) noexcept { return {
        .s = (a.s + b.s),
        .xy = (a.xy + b.xy),
        .xz = (a.xz + b.xz),
        .yz = (a.yz + b.yz)
    }; }
    constexpr Quaternion& operator+=(Quaternion& a, const Quaternion& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Quaternion operator-(const Quaternion& a, const Quaternion& b) noexcept { return {
        .s = (a.s - b.s),
        .xy = (a.xy - b.xy),
        .xz = (a.xz - b.xz),
        .yz = (a.yz - b.yz)
    }; }
    constexpr Quaternion& operator-=(Quaternion& a, const Quaternion& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectiveTranslator operator+(const ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { return {
        .s = (a.s + b.s),
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz)
    }; }
    constexpr ProjectiveTranslator& operator+=(ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr ProjectiveTranslator operator-(const ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { return {
        .s = (a.s - b.s),
        .wx = (a.wx - b.wx),
        .wy = (a.wy - b.wy),
        .wz = (a.wz - b.wz)
    }; }
    constexpr ProjectiveTranslator& operator-=(ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectiveTranslator operator+(const Translator& a, const Translator& b) noexcept { return {
        .s = 2.0,
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz)
    }; }
    [[nodiscard]] constexpr BivectorWeight operator-(const Translator& a, const Translator& b) noexcept { return {
        .wx = (a.wx - b.wx),
        .wy = (a.wy - b.wy),
        .wz = (a.wz - b.wz)
    }; }

    [[nodiscard]] constexpr ProjectivePoint operator+(const Vector& a, const ProjectivePoint& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z),
        .w = b.w
    }; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const Vector& a, const ProjectivePoint& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z),
        .w = -b.w
    }; }
    [[nodiscard]] constexpr Point operator+(const Vector& a, const Point& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z)
    }; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const Vector& a, const Point& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z),
        .w = -1.0
    }; }
    [[nodiscard]] constexpr Vector operator+(const Vector& a, const Vector& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z)
    }; }
    constexpr Vector& operator+=(Vector& a, const Vector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Vector operator-(const Vector& a, const Vector& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z)
    }; }
    constexpr Vector& operator-=(Vector& a, const Vector& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator+(const Point& a, const ProjectivePoint& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z),
        .w = (1.0 + b.w)
    }; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const Point& a, const ProjectivePoint& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z),
        .w = (1.0 - b.w)
    }; }
    [[nodiscard]] constexpr ProjectivePoint operator+(const Point& a, const Point& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z),
        .w = 2.0
    }; }
    [[nodiscard]] constexpr Vector operator-(const Point& a, const Point& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z)
    }; }
    [[nodiscard]] constexpr Point operator+(const Point& a, const Vector& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z)
    }; }
    constexpr Point& operator+=(Point& a, const Vector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Point operator-(const Point& a, const Vector& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z)
    }; }
    constexpr Point& operator-=(Point& a, const Vector& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr PlaneIdeal operator+(const PlaneIdeal& a, const PlaneIdeal& b) noexcept { return {
        .x = (a.x + b.x),
        .y = (a.y + b.y),
        .z = (a.z + b.z)
    }; }
    constexpr PlaneIdeal& operator+=(PlaneIdeal& a, const PlaneIdeal& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr PlaneIdeal operator-(const PlaneIdeal& a, const PlaneIdeal& b) noexcept { return {
        .x = (a.x - b.x),
        .y = (a.y - b.y),
        .z = (a.z - b.z)
    }; }
    constexpr PlaneIdeal& operator-=(PlaneIdeal& a, const PlaneIdeal& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Bivector operator+(const BivectorBulk& a, const Bivector& b) noexcept { return {
        .wx = b.wx,
        .wy = b.wy,
        .wz = b.wz,
        .xy = (a.xy + b.xy),
        .xz = (a.xz + b.xz),
        .yz = (a.yz + b.yz)
    }; }
    [[nodiscard]] constexpr Bivector operator-(const BivectorBulk& a, const Bivector& b) noexcept { return {
        .wx = -b.wx,
        .wy = -b.wy,
        .wz = -b.wz,
        .xy = (a.xy - b.xy),
        .xz = (a.xz - b.xz),
        .yz = (a.yz - b.yz)
    }; }
    [[nodiscard]] constexpr BivectorBulk operator+(const BivectorBulk& a, const BivectorBulk& b) noexcept { return {
        .xy = (a.xy + b.xy),
        .xz = (a.xz + b.xz),
        .yz = (a.yz + b.yz)
    }; }
    constexpr BivectorBulk& operator+=(BivectorBulk& a, const BivectorBulk& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr BivectorBulk operator-(const BivectorBulk& a, const BivectorBulk& b) noexcept { return {
        .xy = (a.xy - b.xy),
        .xz = (a.xz - b.xz),
        .yz = (a.yz - b.yz)
    }; }
    constexpr BivectorBulk& operator-=(BivectorBulk& a, const BivectorBulk& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr Bivector operator+(const BivectorBulk& a, const BivectorWeight& b) noexcept { return {
        .wx = b.wx,
        .wy = b.wy,
        .wz = b.wz,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }
    [[nodiscard]] constexpr Bivector operator-(const BivectorBulk& a, const BivectorWeight& b) noexcept { return {
        .wx = -b.wx,
        .wy = -b.wy,
        .wz = -b.wz,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }

    [[nodiscard]] constexpr Bivector operator+(const BivectorWeight& a, const Bivector& b) noexcept { return {
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz),
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz
    }; }
    [[nodiscard]] constexpr Bivector operator-(const BivectorWeight& a, const Bivector& b) noexcept { return {
        .wx = (a.wx - b.wx),
        .wy = (a.wy - b.wy),
        .wz = (a.wz - b.wz),
        .xy = -b.xy,
        .xz = -b.xz,
        .yz = -b.yz
    }; }
    [[nodiscard]] constexpr Bivector operator+(const BivectorWeight& a, const BivectorBulk& b) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz,
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz
    }; }
    [[nodiscard]] constexpr Bivector operator-(const BivectorWeight& a, const BivectorBulk& b) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz,
        .xy = -b.xy,
        .xz = -b.xz,
        .yz = -b.yz
    }; }
    [[nodiscard]] constexpr BivectorWeight operator+(const BivectorWeight& a, const BivectorWeight& b) noexcept { return {
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz)
    }; }
    constexpr BivectorWeight& operator+=(BivectorWeight& a, const BivectorWeight& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr BivectorWeight operator-(const BivectorWeight& a, const BivectorWeight& b) noexcept { return {
        .wx = (a.wx - b.wx),
        .wy = (a.wy - b.wy),
        .wz = (a.wz - b.wz)
    }; }
    constexpr BivectorWeight& operator-=(BivectorWeight& a, const BivectorWeight& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr PseudoScalar operator+(const PseudoScalar& a, const PseudoScalar& b) noexcept { return {
        .i = (a.i + b.i)
    }; }
    constexpr PseudoScalar& operator+=(PseudoScalar& a, const PseudoScalar& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr PseudoScalar operator-(const PseudoScalar& a, const PseudoScalar& b) noexcept { return {
        .i = (a.i - b.i)
    }; }
    constexpr PseudoScalar& operator-=(PseudoScalar& a, const PseudoScalar& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator+(const PointCenter& a, const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = 2.0
    }; }

    [[nodiscard]] constexpr Multivector operator-(const Multivector& a) noexcept { return {.s = -a.s, .w = -a.w, .x = -a.x, .y = -a.y, .z = -a.z, .wx = -a.wx, .wy = -a.wy, .wz = -a.wz, .xy = -a.xy, .xz = -a.xz, .yz = -a.yz, .wxy = -a.wxy, .wxz = -a.wxz, .wyz = -a.wyz, .xyz = -a.xyz, .i = -a.i}; }
    [[nodiscard]] constexpr Motor operator-(const Motor& a) noexcept { return {.s = -a.s, .wx = -a.wx, .wy = -a.wy, .wz = -a.wz, .xy = -a.xy, .xz = -a.xz, .yz = -a.yz, .i = -a.i}; }
    [[nodiscard]] constexpr Plane operator-(const Plane& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z, .w = -a.w}; }
    [[nodiscard]] constexpr Bivector operator-(const Bivector& a) noexcept { return {.wx = -a.wx, .wy = -a.wy, .wz = -a.wz, .xy = -a.xy, .xz = -a.xz, .yz = -a.yz}; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const ProjectivePoint& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z, .w = -a.w}; }
    [[nodiscard]] constexpr Quaternion operator-(const Quaternion& a) noexcept { return {.s = -a.s, .xy = -a.xy, .xz = -a.xz, .yz = -a.yz}; }
    [[nodiscard]] constexpr ProjectiveTranslator operator-(const ProjectiveTranslator& a) noexcept { return {.s = -a.s, .wx = -a.wx, .wy = -a.wy, .wz = -a.wz}; }
    [[nodiscard]] constexpr ProjectiveTranslator operator-(const Translator& a) noexcept { return {.s = -1.0, .wx = -a.wx, .wy = -a.wy, .wz = -a.wz}; }
    [[nodiscard]] constexpr Vector operator-(const Vector& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z}; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const Point& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z, .w = -1.0}; }
    [[nodiscard]] constexpr PlaneIdeal operator-(const PlaneIdeal& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z}; }
    [[nodiscard]] constexpr BivectorBulk operator-(const BivectorBulk& a) noexcept { return {.xy = -a.xy, .xz = -a.xz, .yz = -a.yz}; }
    [[nodiscard]] constexpr BivectorWeight operator-(const BivectorWeight& a) noexcept { return {.wx = -a.wx, .wy = -a.wy, .wz = -a.wz}; }
    [[nodiscard]] constexpr PseudoScalar operator-(const PseudoScalar& a) noexcept { return {.i = -a.i}; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const PointCenter& a) noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -1.0}; }

    [[nodiscard]] constexpr Multivector operator*(const Multivector& a, double d) noexcept { return {
        .s = a.s * d,
        .w = a.w * d,
        .x = a.x * d,
        .y = a.y * d,
        .z = a.z * d,
        .wx = a.wx * d,
        .wy = a.wy * d,
        .wz = a.wz * d,
        .xy = a.xy * d,
        .xz = a.xz * d,
        .yz = a.yz * d,
        .wxy = a.wxy * d,
        .wxz = a.wxz * d,
        .wyz = a.wyz * d,
        .xyz = a.xyz * d,
        .i = a.i * d
    }; }
    [[nodiscard]] constexpr Multivector operator*(double d, const Multivector& a) noexcept { return a * d; }
    [[nodiscard]] constexpr Multivector operator/(const Multivector& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Multivector& operator*=(Multivector& a, double d) noexcept { a = a * d; return a; }
    constexpr Multivector& operator/=(Multivector& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr Motor operator*(const Motor& a, double d) noexcept { return {
        .s = a.s * d,
        .wx = a.wx * d,
        .wy = a.wy * d,
        .wz = a.wz * d,
        .xy = a.xy * d,
        .xz = a.xz * d,
        .yz = a.yz * d,
        .i = a.i * d
    }; }
    [[nodiscard]] constexpr Motor operator*(double d, const Motor& a) noexcept { return a * d; }
    [[nodiscard]] constexpr Motor operator/(const Motor& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Motor& operator*=(Motor& a, double d) noexcept { a = a * d; return a; }
    constexpr Motor& operator/=(Motor& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr Plane operator*(const Plane& a, double d) noexcept { return {
        .x = a.x * d,
        .y = a.y * d,
        .z = a.z * d,
        .w = a.w * d
    }; }
    [[nodiscard]] constexpr Plane operator*(double d, const Plane& a) noexcept { return a * d; }
    [[nodiscard]] constexpr Plane operator/(const Plane& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Plane& operator*=(Plane& a, double d) noexcept { a = a * d; return a; }
    constexpr Plane& operator/=(Plane& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr Bivector operator*(const Bivector& a, double d) noexcept { return {
        .wx = a.wx * d,
        .wy = a.wy * d,
        .wz = a.wz * d,
        .xy = a.xy * d,
        .xz = a.xz * d,
        .yz = a.yz * d
    }; }
    [[nodiscard]] constexpr Bivector operator*(double d, const Bivector& a) noexcept { return a * d; }
    [[nodiscard]] constexpr Bivector operator/(const Bivector& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Bivector& operator*=(Bivector& a, double d) noexcept { a = a * d; return a; }
    constexpr Bivector& operator/=(Bivector& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator*(const ProjectivePoint& a, double d) noexcept { return {
        .x = a.x * d,
        .y = a.y * d,
        .z = a.z * d,
        .w = a.w * d
    }; }
    [[nodiscard]] constexpr ProjectivePoint operator*(double d, const ProjectivePoint& a) noexcept { return a * d; }
    [[nodiscard]] constexpr ProjectivePoint operator/(const ProjectivePoint& a, double d) noexcept { return a * (1.0 / d); }
    constexpr ProjectivePoint& operator*=(ProjectivePoint& a, double d) noexcept { a = a * d; return a; }
    constexpr ProjectivePoint& operator/=(ProjectivePoint& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr Quaternion operator*(const Quaternion& a, double d) noexcept { return {
        .s = a.s * d,
        .xy = a.xy * d,
        .xz = a.xz * d,
        .yz = a.yz * d
    }; }
    [[nodiscard]] constexpr Quaternion operator*(double d, const Quaternion& a) noexcept { return a * d; }
    [[nodiscard]] constexpr Quaternion operator/(const Quaternion& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Quaternion& operator*=(Quaternion& a, double d) noexcept { a = a * d; return a; }
    constexpr Quaternion& operator/=(Quaternion& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectiveTranslator operator*(const ProjectiveTranslator& a, double d) noexcept { return {
        .s = a.s * d,
        .wx = a.wx * d,
        .wy = a.wy * d,
        .wz = a.wz * d
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator operator*(double d, const ProjectiveTranslator& a) noexcept { return a * d; }
    [[nodiscard]] constexpr ProjectiveTranslator operator/(const ProjectiveTranslator& a, double d) noexcept { return a * (1.0 / d); }
    constexpr ProjectiveTranslator& operator*=(ProjectiveTranslator& a, double d) noexcept { a = a * d; return a; }
    constexpr ProjectiveTranslator& operator/=(ProjectiveTranslator& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectiveTranslator operator*(const Translator& a, double d) noexcept { return {
        .s = d,
        .wx = a.wx * d,
        .wy = a.wy * d,
        .wz = a.wz * d
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator operator*(double d, const Translator& a) noexcept { return a * d; }
    [[nodiscard]] constexpr ProjectiveTranslator operator/(const Translator& a, double d) noexcept { return a * (1.0 / d); }

    [[nodiscard]] constexpr Vector operator*(const Vector& a, double d) noexcept { return {
        .x = a.x * d,
        .y = a.y * d,
        .z = a.z * d
    }; }
    [[nodiscard]] constexpr Vector operator*(double d, const Vector& a) noexcept { return a * d; }
    [[nodiscard]] constexpr Vector operator/(const Vector& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Vector& operator*=(Vector& a, double d) noexcept { a = a * d; return a; }
    constexpr Vector& operator/=(Vector& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator*(const Point& a, double d) noexcept { return {
        .x = a.x * d,
        .y = a.y * d,
        .z = a.z * d,
        .w = d
    }; }
    [[nodiscard]] constexpr ProjectivePoint operator*(double d, const Point& a) noexcept { return a * d; }
    [[nodiscard]] constexpr ProjectivePoint operator/(const Point& a, double d) noexcept { return a * (1.0 / d); }

    [[nodiscard]] constexpr PlaneIdeal operator*(const PlaneIdeal& a, double d) noexcept { return {
        .x = a.x * d,
        .y = a.y * d,
        .z = a.z * d
    }; }
    [[nodiscard]] constexpr PlaneIdeal operator*(double d, const PlaneIdeal& a) noexcept { return a * d; }
    [[nodiscard]] constexpr PlaneIdeal operator/(const PlaneIdeal& a, double d) noexcept { return a * (1.0 / d); }
    constexpr PlaneIdeal& operator*=(PlaneIdeal& a, double d) noexcept { a = a * d; return a; }
    constexpr PlaneIdeal& operator/=(PlaneIdeal& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr BivectorBulk operator*(const BivectorBulk& a, double d) noexcept { return {
        .xy = a.xy * d,
        .xz = a.xz * d,
        .yz = a.yz * d
    }; }
    [[nodiscard]] constexpr BivectorBulk operator*(double d, const BivectorBulk& a) noexcept { return a * d; }
    [[nodiscard]] constexpr BivectorBulk operator/(const BivectorBulk& a, double d) noexcept { return a * (1.0 / d); }
    constexpr BivectorBulk& operator*=(BivectorBulk& a, double d) noexcept { a = a * d; return a; }
    constexpr BivectorBulk& operator/=(BivectorBulk& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr BivectorWeight operator*(const BivectorWeight& a, double d) noexcept { return {
        .wx = a.wx * d,
        .wy = a.wy * d,
        .wz = a.wz * d
    }; }
    [[nodiscard]] constexpr BivectorWeight operator*(double d, const BivectorWeight& a) noexcept { return a * d; }
    [[nodiscard]] constexpr BivectorWeight operator/(const BivectorWeight& a, double d) noexcept { return a * (1.0 / d); }
    constexpr BivectorWeight& operator*=(BivectorWeight& a, double d) noexcept { a = a * d; return a; }
    constexpr BivectorWeight& operator/=(BivectorWeight& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr PseudoScalar operator*(const PseudoScalar& a, double d) noexcept { return {
        .i = a.i * d
    }; }
    [[nodiscard]] constexpr PseudoScalar operator*(double d, const PseudoScalar& a) noexcept { return a * d; }
    [[nodiscard]] constexpr PseudoScalar operator/(const PseudoScalar& a, double d) noexcept { return a * (1.0 / d); }
    constexpr PseudoScalar& operator*=(PseudoScalar& a, double d) noexcept { a = a * d; return a; }
    constexpr PseudoScalar& operator/=(PseudoScalar& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator*(const PointCenter& a, double d) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = d
    }; }
    [[nodiscard]] constexpr ProjectivePoint operator*(double d, const PointCenter& a) noexcept { return a * d; }
    [[nodiscard]] constexpr ProjectivePoint operator/(const PointCenter& a, double d) noexcept { return a * (1.0 / d); }

    inline Multivector Multivector::madd(const Multivector& other, double mult) const noexcept { return {
        .s = std::fma(other.s, mult, s),
        .w = std::fma(other.w, mult, w),
        .x = std::fma(other.x, mult, x),
        .y = std::fma(other.y, mult, y),
        .z = std::fma(other.z, mult, z),
        .wx = std::fma(other.wx, mult, wx),
        .wy = std::fma(other.wy, mult, wy),
        .wz = std::fma(other.wz, mult, wz),
        .xy = std::fma(other.xy, mult, xy),
        .xz = std::fma(other.xz, mult, xz),
        .yz = std::fma(other.yz, mult, yz),
        .wxy = std::fma(other.wxy, mult, wxy),
        .wxz = std::fma(other.wxz, mult, wxz),
        .wyz = std::fma(other.wyz, mult, wyz),
        .xyz = std::fma(other.xyz, mult, xyz),
        .i = std::fma(other.i, mult, i)
    }; }
    inline Motor Motor::madd(const Motor& other, double mult) const noexcept { return {
        .s = std::fma(other.s, mult, s),
        .wx = std::fma(other.wx, mult, wx),
        .wy = std::fma(other.wy, mult, wy),
        .wz = std::fma(other.wz, mult, wz),
        .xy = std::fma(other.xy, mult, xy),
        .xz = std::fma(other.xz, mult, xz),
        .yz = std::fma(other.yz, mult, yz),
        .i = std::fma(other.i, mult, i)
    }; }
    inline Plane Plane::madd(const Plane& other, double mult) const noexcept { return {
        .x = std::fma(other.x, mult, x),
        .y = std::fma(other.y, mult, y),
        .z = std::fma(other.z, mult, z),
        .w = std::fma(other.w, mult, w)
    }; }
    inline Bivector Bivector::madd(const Bivector& other, double mult) const noexcept { return {
        .wx = std::fma(other.wx, mult, wx),
        .wy = std::fma(other.wy, mult, wy),
        .wz = std::fma(other.wz, mult, wz),
        .xy = std::fma(other.xy, mult, xy),
        .xz = std::fma(other.xz, mult, xz),
        .yz = std::fma(other.yz, mult, yz)
    }; }
    inline ProjectivePoint ProjectivePoint::madd(const ProjectivePoint& other, double mult) const noexcept { return {
        .x = std::fma(other.x, mult, x),
        .y = std::fma(other.y, mult, y),
        .z = std::fma(other.z, mult, z),
        .w = std::fma(other.w, mult, w)
    }; }
    inline Quaternion Quaternion::madd(const Quaternion& other, double mult) const noexcept { return {
        .s = std::fma(other.s, mult, s),
        .xy = std::fma(other.xy, mult, xy),
        .xz = std::fma(other.xz, mult, xz),
        .yz = std::fma(other.yz, mult, yz)
    }; }
    inline ProjectiveTranslator ProjectiveTranslator::madd(const ProjectiveTranslator& other, double mult) const noexcept { return {
        .s = std::fma(other.s, mult, s),
        .wx = std::fma(other.wx, mult, wx),
        .wy = std::fma(other.wy, mult, wy),
        .wz = std::fma(other.wz, mult, wz)
    }; }
    inline Vector Vector::madd(const Vector& other, double mult) const noexcept { return {
        .x = std::fma(other.x, mult, x),
        .y = std::fma(other.y, mult, y),
        .z = std::fma(other.z, mult, z)
    }; }
    inline Point Point::madd(const Vector& other, double mult) const noexcept { return {
        .x = std::fma(other.x, mult, x),
        .y = std::fma(other.y, mult, y),
        .z = std::fma(other.z, mult, z)
    }; }
    inline PlaneIdeal PlaneIdeal::madd(const PlaneIdeal& other, double mult) const noexcept { return {
        .x = std::fma(other.x, mult, x),
        .y = std::fma(other.y, mult, y),
        .z = std::fma(other.z, mult, z)
    }; }
    inline BivectorBulk BivectorBulk::madd(const BivectorBulk& other, double mult) const noexcept { return {
        .xy = std::fma(other.xy, mult, xy),
        .xz = std::fma(other.xz, mult, xz),
        .yz = std::fma(other.yz, mult, yz)
    }; }
    inline BivectorWeight BivectorWeight::madd(const BivectorWeight& other, double mult) const noexcept { return {
        .wx = std::fma(other.wx, mult, wx),
        .wy = std::fma(other.wy, mult, wy),
        .wz = std::fma(other.wz, mult, wz)
    }; }
    inline PseudoScalar PseudoScalar::madd(const PseudoScalar& other, double mult) const noexcept { return {
        .i = std::fma(other.i, mult, i)
    }; }

    [[nodiscard]] constexpr bool operator==(const Multivector& a, const Multivector& b) noexcept { return a.s == b.s && a.w == b.w && a.x == b.x && a.y == b.y && a.z == b.z && a.wx == b.wx && a.wy == b.wy && a.wz == b.wz && a.xy == b.xy && a.xz == b.xz && a.yz == b.yz && a.wxy == b.wxy && a.wxz == b.wxz && a.wyz == b.wyz && a.xyz == b.xyz && a.i == b.i; }
    [[nodiscard]] constexpr bool operator==(const Motor& a, const Motor& b) noexcept { return a.s == b.s && a.wx == b.wx && a.wy == b.wy && a.wz == b.wz && a.xy == b.xy && a.xz == b.xz && a.yz == b.yz && a.i == b.i; }
    [[nodiscard]] constexpr bool operator==(const Plane& a, const Plane& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w; }
    [[nodiscard]] constexpr bool operator==(const Bivector& a, const Bivector& b) noexcept { return a.wx == b.wx && a.wy == b.wy && a.wz == b.wz && a.xy == b.xy && a.xz == b.xz && a.yz == b.yz; }
    [[nodiscard]] constexpr bool operator==(const ProjectivePoint& a, const ProjectivePoint& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w; }
    [[nodiscard]] constexpr bool operator==(const Quaternion& a, const Quaternion& b) noexcept { return a.s == b.s && a.xy == b.xy && a.xz == b.xz && a.yz == b.yz; }
    [[nodiscard]] constexpr bool operator==(const ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { return a.s == b.s && a.wx == b.wx && a.wy == b.wy && a.wz == b.wz; }
    [[nodiscard]] constexpr bool operator==(const Translator& a, const Translator& b) noexcept { return a.wx == b.wx && a.wy == b.wy && a.wz == b.wz; }
    [[nodiscard]] constexpr bool operator==(const Vector& a, const Vector& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z; }
    [[nodiscard]] constexpr bool operator==(const Point& a, const Point& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z; }
    [[nodiscard]] constexpr bool operator==(const PlaneIdeal& a, const PlaneIdeal& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z; }
    [[nodiscard]] constexpr bool operator==(const BivectorBulk& a, const BivectorBulk& b) noexcept { return a.xy == b.xy && a.xz == b.xz && a.yz == b.yz; }
    [[nodiscard]] constexpr bool operator==(const BivectorWeight& a, const BivectorWeight& b) noexcept { return a.wx == b.wx && a.wy == b.wy && a.wz == b.wz; }
    [[nodiscard]] constexpr bool operator==(const PseudoScalar& a, const PseudoScalar& b) noexcept { return a.i == b.i; }
}

// opsNorm.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

namespace pga3d {
    constexpr double Multivector::normSquare() const noexcept { return (i * i + s * s + w * w + wx * wx + wxy * wxy + wxz * wxz + wy * wy + wyz * wyz + wz * wz + x * x + xy * xy + xyz * xyz + xz * xz + y * y + yz * yz + z * z); }
    inline double Multivector::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Multivector Multivector::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Multivector::bulkNormSquare() const noexcept { return (s * s + x * x + xy * xy + xyz * xyz + xz * xz + y * y + yz * yz + z * z); }
    inline double Multivector::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Multivector Multivector::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Multivector::weightNormSquare() const noexcept { return (i * i + w * w + wx * wx + wxy * wxy + wxz * wxz + wy * wy + wyz * wyz + wz * wz); }
    inline double Multivector::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Multivector Multivector::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Motor::normSquare() const noexcept { return (i * i + s * s + wx * wx + wy * wy + wz * wz + xy * xy + xz * xz + yz * yz); }
    inline double Motor::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Motor Motor::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Motor::bulkNormSquare() const noexcept { return (s * s + xy * xy + xz * xz + yz * yz); }
    inline double Motor::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Motor Motor::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Motor::weightNormSquare() const noexcept { return (i * i + wx * wx + wy * wy + wz * wz); }
    inline double Motor::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Motor Motor::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Plane::normSquare() const noexcept { return (w * w + x * x + y * y + z * z); }
    inline double Plane::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Plane Plane::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Plane::bulkNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double Plane::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Plane Plane::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Plane::weightNormSquare() const noexcept { return w * w; }
    inline double Plane::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Plane Plane::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Bivector::normSquare() const noexcept { return (wx * wx + wy * wy + wz * wz + xy * xy + xz * xz + yz * yz); }
    inline double Bivector::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Bivector Bivector::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Bivector::bulkNormSquare() const noexcept { return (xy * xy + xz * xz + yz * yz); }
    inline double Bivector::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Bivector Bivector::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Bivector::weightNormSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double Bivector::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Bivector Bivector::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double ProjectivePoint::normSquare() const noexcept { return (w * w + x * x + y * y + z * z); }
    inline double ProjectivePoint::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectivePoint ProjectivePoint::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double ProjectivePoint::bulkNormSquare() const noexcept { return w * w; }
    inline double ProjectivePoint::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectivePoint ProjectivePoint::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double ProjectivePoint::weightNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double ProjectivePoint::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectivePoint ProjectivePoint::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Quaternion::normSquare() const noexcept { return (s * s + xy * xy + xz * xz + yz * yz); }
    inline double Quaternion::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Quaternion Quaternion::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Quaternion::bulkNormSquare() const noexcept { return (s * s + xy * xy + xz * xz + yz * yz); }
    inline double Quaternion::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Quaternion Quaternion::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double ProjectiveTranslator::normSquare() const noexcept { return (s * s + wx * wx + wy * wy + wz * wz); }
    inline double ProjectiveTranslator::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectiveTranslator ProjectiveTranslator::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double ProjectiveTranslator::bulkNormSquare() const noexcept { return s * s; }
    inline double ProjectiveTranslator::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectiveTranslator ProjectiveTranslator::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double ProjectiveTranslator::weightNormSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double ProjectiveTranslator::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectiveTranslator ProjectiveTranslator::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Translator::normSquare() const noexcept { return (1.0 + wx * wx + wy * wy + wz * wz); }
    inline double Translator::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectiveTranslator Translator::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Translator::bulkNormSquare() const noexcept { return 1.0; }
    inline double Translator::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectiveTranslator Translator::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Translator::weightNormSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double Translator::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectiveTranslator Translator::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Vector::normSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double Vector::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Vector Vector::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Vector::weightNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double Vector::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Vector Vector::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Point::normSquare() const noexcept { return (1.0 + x * x + y * y + z * z); }
    inline double Point::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectivePoint Point::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Point::bulkNormSquare() const noexcept { return 1.0; }
    inline double Point::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectivePoint Point::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Point::weightNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double Point::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectivePoint Point::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double PlaneIdeal::normSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double PlaneIdeal::norm() const noexcept { return std::sqrt(normSquare()); }
    inline PlaneIdeal PlaneIdeal::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double PlaneIdeal::bulkNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double PlaneIdeal::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline PlaneIdeal PlaneIdeal::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double BivectorBulk::normSquare() const noexcept { return (xy * xy + xz * xz + yz * yz); }
    inline double BivectorBulk::norm() const noexcept { return std::sqrt(normSquare()); }
    inline BivectorBulk BivectorBulk::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double BivectorBulk::bulkNormSquare() const noexcept { return (xy * xy + xz * xz + yz * yz); }
    inline double BivectorBulk::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline BivectorBulk BivectorBulk::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double BivectorWeight::normSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double BivectorWeight::norm() const noexcept { return std::sqrt(normSquare()); }
    inline BivectorWeight BivectorWeight::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double BivectorWeight::weightNormSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double BivectorWeight::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline BivectorWeight BivectorWeight::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double PseudoScalar::normSquare() const noexcept { return i * i; }
    inline double PseudoScalar::norm() const noexcept { return std::sqrt(normSquare()); }
    inline PseudoScalar PseudoScalar::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double PseudoScalar::weightNormSquare() const noexcept { return i * i; }
    inline double PseudoScalar::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline PseudoScalar PseudoScalar::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double PointCenter::normSquare() const noexcept { return 1.0; }
    inline double PointCenter::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectivePoint PointCenter::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double PointCenter::bulkNormSquare() const noexcept { return 1.0; }
    inline double PointCenter::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectivePoint PointCenter::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double PointCenter::weightNormSquare() const noexcept { return 0.0; }
    inline double PointCenter::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectivePoint PointCenter::normalizedByWeight() const noexcept { return *this / weightNorm(); }

}

// opsGeometric.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

namespace pga3d {
    [[nodiscard]] constexpr Multivector geometric(const Multivector& a,const Multivector& b) noexcept { return {
        .s = (a.s * b.s + a.x * b.x + a.y * b.y + a.z * b.z - a.xy * b.xy - a.xyz * b.xyz - a.xz * b.xz - a.yz * b.yz),
        .w = (a.s * b.w + a.w * b.s + a.wx * b.x + a.wy * b.y + a.wz * b.z + a.xyz * b.i - a.i * b.xyz - a.wxy * b.xy - a.wxz * b.xz - a.wyz * b.yz - a.x * b.wx - a.xy * b.wxy - a.xz * b.wxz - a.y * b.wy - a.yz * b.wyz - a.z * b.wz),
        .x = (a.s * b.x + a.x * b.s + a.xy * b.y + a.xz * b.z - a.xyz * b.yz - a.y * b.xy - a.yz * b.xyz - a.z * b.xz),
        .y = (a.s * b.y + a.x * b.xy + a.xyz * b.xz + a.xz * b.xyz + a.y * b.s + a.yz * b.z - a.xy * b.x - a.z * b.yz),
        .z = (a.s * b.z + a.x * b.xz + a.y * b.yz + a.z * b.s - a.xy * b.xyz - a.xyz * b.xy - a.xz * b.x - a.yz * b.y),
        .wx = (a.s * b.wx + a.w * b.x + a.wx * b.s + a.wxy * b.y + a.wxz * b.z + a.xy * b.wy + a.xyz * b.wyz + a.xz * b.wz + a.y * b.wxy + a.z * b.wxz - a.i * b.yz - a.wy * b.xy - a.wyz * b.xyz - a.wz * b.xz - a.x * b.w - a.yz * b.i),
        .wy = (a.i * b.xz + a.s * b.wy + a.w * b.y + a.wx * b.xy + a.wxz * b.xyz + a.wy * b.s + a.wyz * b.z + a.xz * b.i + a.yz * b.wz + a.z * b.wyz - a.wxy * b.x - a.wz * b.yz - a.x * b.wxy - a.xy * b.wx - a.xyz * b.wxz - a.y * b.w),
        .wz = (a.s * b.wz + a.w * b.z + a.wx * b.xz + a.wy * b.yz + a.wz * b.s + a.xyz * b.wxy - a.i * b.xy - a.wxy * b.xyz - a.wxz * b.x - a.wyz * b.y - a.x * b.wxz - a.xy * b.i - a.xz * b.wx - a.y * b.wyz - a.yz * b.wy - a.z * b.w),
        .xy = (a.s * b.xy + a.x * b.y + a.xy * b.s + a.xyz * b.z + a.yz * b.xz + a.z * b.xyz - a.xz * b.yz - a.y * b.x),
        .xz = (a.s * b.xz + a.x * b.z + a.xy * b.yz + a.xz * b.s - a.xyz * b.y - a.y * b.xyz - a.yz * b.xy - a.z * b.x),
        .yz = (a.s * b.yz + a.x * b.xyz + a.xyz * b.x + a.xz * b.xy + a.y * b.z + a.yz * b.s - a.xy * b.xz - a.z * b.y),
        .wxy = (a.i * b.z + a.s * b.wxy + a.w * b.xy + a.wx * b.y + a.wxy * b.s + a.wyz * b.xz + a.wz * b.xyz + a.xy * b.w + a.y * b.wx + a.yz * b.wxz - a.wxz * b.yz - a.wy * b.x - a.x * b.wy - a.xyz * b.wz - a.xz * b.wyz - a.z * b.i),
        .wxz = (a.s * b.wxz + a.w * b.xz + a.wx * b.z + a.wxy * b.yz + a.wxz * b.s + a.xy * b.wyz + a.xyz * b.wy + a.xz * b.w + a.y * b.i + a.z * b.wx - a.i * b.y - a.wy * b.xyz - a.wyz * b.xy - a.wz * b.x - a.x * b.wz - a.yz * b.wxy),
        .wyz = (a.i * b.x + a.s * b.wyz + a.w * b.yz + a.wx * b.xyz + a.wxz * b.xy + a.wy * b.z + a.wyz * b.s + a.xz * b.wxy + a.yz * b.w + a.z * b.wy - a.wxy * b.xz - a.wz * b.y - a.x * b.i - a.xy * b.wxz - a.xyz * b.wx - a.y * b.wz),
        .xyz = (a.s * b.xyz + a.x * b.yz + a.xy * b.z + a.xyz * b.s + a.yz * b.x + a.z * b.xy - a.xz * b.y - a.y * b.xz),
        .i = (a.i * b.s + a.s * b.i + a.w * b.xyz + a.wx * b.yz + a.wxy * b.z + a.wyz * b.x + a.wz * b.xy + a.xy * b.wz + a.y * b.wxz + a.yz * b.wx - a.wxz * b.y - a.wy * b.xz - a.x * b.wyz - a.xyz * b.w - a.xz * b.wy - a.z * b.wxy)
    }; }
    constexpr Multivector Multivector::geometric(const Multivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Motor& a,const Motor& b) noexcept { return {
        .s = (a.s * b.s - a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.s * b.wx + a.wx * b.s + a.xy * b.wy + a.xz * b.wz - a.i * b.yz - a.wy * b.xy - a.wz * b.xz - a.yz * b.i),
        .wy = (a.i * b.xz + a.s * b.wy + a.wx * b.xy + a.wy * b.s + a.xz * b.i + a.yz * b.wz - a.wz * b.yz - a.xy * b.wx),
        .wz = (a.s * b.wz + a.wx * b.xz + a.wy * b.yz + a.wz * b.s - a.i * b.xy - a.xy * b.i - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.s * b.xy + a.xy * b.s + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.s * b.xz + a.xy * b.yz + a.xz * b.s - a.yz * b.xy),
        .yz = (a.s * b.yz + a.xz * b.xy + a.yz * b.s - a.xy * b.xz),
        .i = (a.i * b.s + a.s * b.i + a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy)
    }; }
    constexpr Motor Motor::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Motor& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = (a.s * b.w + a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.s * b.x + a.xy * b.y + a.xz * b.z),
        .y = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .z = (a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.i * b.z + a.wx * b.y + a.xy * b.w - a.wy * b.x),
        .wxz = (a.wx * b.z + a.xz * b.w - a.i * b.y - a.wz * b.x),
        .wyz = (a.i * b.x + a.wy * b.z + a.yz * b.w - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Motor::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Motor& a,const Bivector& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.s * b.wx + a.xy * b.wy + a.xz * b.wz - a.i * b.yz - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.i * b.xz + a.s * b.wy + a.wx * b.xy + a.yz * b.wz - a.wz * b.yz - a.xy * b.wx),
        .wz = (a.s * b.wz + a.wx * b.xz + a.wy * b.yz - a.i * b.xy - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.s * b.xy + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.s * b.xz + a.xy * b.yz - a.yz * b.xy),
        .yz = (a.s * b.yz + a.xz * b.xy - a.xy * b.xz),
        .i = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy)
    }; }
    constexpr Motor Motor::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Motor& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.i * b.w - a.xz * b.y),
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wz * b.w + a.xz * b.x + a.yz * b.y - a.s * b.z),
        .wxz = (a.s * b.y + a.yz * b.z - a.wy * b.w - a.xy * b.x),
        .wyz = (a.wx * b.w - a.s * b.x - a.xy * b.y - a.xz * b.z),
        .xyz = a.s * b.w,
        .i = 0.0
    }; }
    constexpr Multivector Motor::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Motor& a,const Quaternion& b) noexcept { return {
        .s = (a.s * b.s - a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.wx * b.s - a.i * b.yz - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.i * b.xz + a.wx * b.xy + a.wy * b.s - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz + a.wz * b.s - a.i * b.xy),
        .xy = (a.s * b.xy + a.xy * b.s + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.s * b.xz + a.xy * b.yz + a.xz * b.s - a.yz * b.xy),
        .yz = (a.s * b.yz + a.xz * b.xy + a.yz * b.s - a.xy * b.xz),
        .i = (a.i * b.s + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor Motor::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Motor& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s + a.xy * b.wy + a.xz * b.wz),
        .wy = (a.s * b.wy + a.wy * b.s + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.s * b.wz + a.wz * b.s - a.xz * b.wx - a.yz * b.wy),
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.i * b.s + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Motor::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Motor& a,const Translator& b) noexcept { return {
        .s = a.s,
        .wx = (a.wx + a.s * b.wx + a.xy * b.wy + a.xz * b.wz),
        .wy = (a.wy + a.s * b.wy + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.wz + a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = (a.i + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Motor::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Motor& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.xz * b.x + a.yz * b.y - a.s * b.z),
        .wxz = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .wyz = (-a.s * b.x - a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Motor::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Motor& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (-a.i + a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wz + a.xz * b.x + a.yz * b.y - a.s * b.z),
        .wxz = (-a.wy + a.s * b.y + a.yz * b.z - a.xy * b.x),
        .wyz = (a.wx - a.s * b.x - a.xy * b.y - a.xz * b.z),
        .xyz = a.s,
        .i = 0.0
    }; }
    constexpr Multivector Motor::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Motor& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.s * b.x + a.xy * b.y + a.xz * b.z),
        .y = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .z = (a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.i * b.z + a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.i * b.y - a.wz * b.x),
        .wyz = (a.i * b.x + a.wy * b.z - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Motor::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Motor& a,const BivectorBulk& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (-a.i * b.yz - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.i * b.xz + a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz - a.i * b.xy),
        .xy = (a.s * b.xy + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.s * b.xz + a.xy * b.yz - a.yz * b.xy),
        .yz = (a.s * b.yz + a.xz * b.xy - a.xy * b.xz),
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor Motor::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Motor& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = (a.s * b.wx + a.xy * b.wy + a.xz * b.wz),
        .wy = (a.s * b.wy + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Motor::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Motor& a,const PseudoScalar& b) noexcept { return {
        .s = 0.0,
        .wx = -a.yz * b.i,
        .wy = a.xz * b.i,
        .wz = -a.xy * b.i,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.s * b.i
    }; }
    constexpr Motor Motor::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Motor& a,const PointCenter& b) noexcept { return {
        .s = 0.0,
        .w = -a.i,
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wz,
        .wxz = -a.wy,
        .wyz = a.wx,
        .xyz = a.s,
        .i = 0.0
    }; }
    constexpr Multivector Motor::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Plane& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.w * b.s - a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = (a.x * b.s - a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz + a.z * b.s),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.w * b.xy + a.y * b.wx - a.x * b.wy - a.z * b.i),
        .wxz = (a.w * b.xz + a.y * b.i + a.z * b.wx - a.x * b.wz),
        .wyz = (a.w * b.yz + a.z * b.wy - a.x * b.i - a.y * b.wz),
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Plane& a,const Plane& b) noexcept { return {
        .s = (a.x * b.x + a.y * b.y + a.z * b.z),
        .wx = (a.w * b.x - a.x * b.w),
        .wy = (a.w * b.y - a.y * b.w),
        .wz = (a.w * b.z - a.z * b.w),
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y),
        .i = 0.0
    }; }
    constexpr Motor Plane::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Plane& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.w * b.xy + a.y * b.wx - a.x * b.wy),
        .wxz = (a.w * b.xz + a.z * b.wx - a.x * b.wz),
        .wyz = (a.w * b.yz + a.z * b.wy - a.y * b.wz),
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Plane& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = a.z * b.w,
        .xz = -a.y * b.w,
        .yz = a.x * b.w,
        .i = (a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor Plane::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Plane& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = a.w * b.s,
        .x = (a.x * b.s - a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz + a.z * b.s),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.w * b.xy,
        .wxz = a.w * b.xz,
        .wyz = a.w * b.yz,
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Plane& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = (a.w * b.s - a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Plane::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Plane& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = (a.w - a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Plane::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Plane& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor Plane::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Plane& a,const Point& b) noexcept { return {
        .s = 0.0,
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = a.z,
        .xz = -a.y,
        .yz = a.x,
        .i = (a.w + a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor Plane::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Plane& a,const PlaneIdeal& b) noexcept { return {
        .s = (a.x * b.x + a.y * b.y + a.z * b.z),
        .wx = a.w * b.x,
        .wy = a.w * b.y,
        .wz = a.w * b.z,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y),
        .i = 0.0
    }; }
    constexpr Motor Plane::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Plane& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.w * b.xy,
        .wxz = a.w * b.xz,
        .wyz = a.w * b.yz,
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Plane& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Plane::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const Plane& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr Vector Plane::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Plane& a,const PointCenter& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = a.z,
        .xz = -a.y,
        .yz = a.x,
        .i = a.w
    }; }
    constexpr Motor Plane::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Bivector& a,const Motor& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.wx * b.s + a.xy * b.wy + a.xz * b.wz - a.wy * b.xy - a.wz * b.xz - a.yz * b.i),
        .wy = (a.wx * b.xy + a.wy * b.s + a.xz * b.i + a.yz * b.wz - a.wz * b.yz - a.xy * b.wx),
        .wz = (a.wx * b.xz + a.wy * b.yz + a.wz * b.s - a.xy * b.i - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.xy * b.s + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz + a.xz * b.s - a.yz * b.xy),
        .yz = (a.xz * b.xy + a.yz * b.s - a.xy * b.xz),
        .i = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy)
    }; }
    constexpr Motor Bivector::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Bivector& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y + a.xy * b.w - a.wy * b.x),
        .wxz = (a.wx * b.z + a.xz * b.w - a.wz * b.x),
        .wyz = (a.wy * b.z + a.yz * b.w - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Bivector::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Bivector& a,const Bivector& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.xy * b.wy + a.xz * b.wz - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.yz * b.wz - a.wz * b.yz - a.xy * b.wx),
        .wz = (a.wx * b.xz + a.wy * b.yz - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz),
        .i = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy)
    }; }
    constexpr Motor Bivector::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Bivector& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wz * b.w + a.xz * b.x + a.yz * b.y),
        .wxz = (a.yz * b.z - a.wy * b.w - a.xy * b.x),
        .wyz = (a.wx * b.w - a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Bivector::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Bivector& a,const Quaternion& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.wy * b.s - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz + a.wz * b.s),
        .xy = (a.xy * b.s + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz + a.xz * b.s - a.yz * b.xy),
        .yz = (a.xz * b.xy + a.yz * b.s - a.xy * b.xz),
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor Bivector::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Bivector& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wx * b.s + a.xy * b.wy + a.xz * b.wz),
        .wy = (a.wy * b.s + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.wz * b.s - a.xz * b.wx - a.yz * b.wy),
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Bivector::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Bivector& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wx + a.xy * b.wy + a.xz * b.wz),
        .wy = (a.wy + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.wz - a.xz * b.wx - a.yz * b.wy),
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Bivector::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Bivector& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.xz * b.x + a.yz * b.y),
        .wxz = (a.yz * b.z - a.xy * b.x),
        .wyz = (-a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Bivector::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Bivector& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wz + a.xz * b.x + a.yz * b.y),
        .wxz = (-a.wy + a.yz * b.z - a.xy * b.x),
        .wyz = (a.wx - a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Bivector::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Bivector& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Bivector::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Bivector& a,const BivectorBulk& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz),
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor Bivector::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Bivector& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Bivector::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const Bivector& a,const PseudoScalar& b) noexcept { return {
        .wx = -a.yz * b.i,
        .wy = a.xz * b.i,
        .wz = -a.xy * b.i
    }; }
    constexpr BivectorWeight Bivector::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Bivector& a,const PointCenter& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wz,
        .wxz = -a.wy,
        .wyz = a.wx,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Bivector::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.w * b.i + a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -a.w * b.yz,
        .y = a.w * b.xz,
        .z = -a.w * b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.w * b.wz - a.x * b.xz - a.y * b.yz - a.z * b.s),
        .wxz = (a.w * b.wy + a.x * b.xy + a.y * b.s - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz - a.w * b.wx - a.x * b.s),
        .xyz = a.w * b.s,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const ProjectivePoint& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = a.w * b.z,
        .xz = -a.w * b.y,
        .yz = a.w * b.x,
        .i = (-a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr Motor ProjectivePoint::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -a.w * b.yz,
        .y = a.w * b.xz,
        .z = -a.w * b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.w * b.wz - a.x * b.xz - a.y * b.yz),
        .wxz = (a.w * b.wy + a.x * b.xy - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz - a.w * b.wx),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectivePoint& a,const ProjectivePoint& b) noexcept { return {
        .s = -a.w * b.w,
        .wx = (a.x * b.w - a.w * b.x),
        .wy = (a.y * b.w - a.w * b.y),
        .wz = (a.z * b.w - a.w * b.z)
    }; }
    constexpr ProjectiveTranslator ProjectivePoint::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -a.w * b.yz,
        .y = a.w * b.xz,
        .z = -a.w * b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.x * b.xz - a.y * b.yz - a.z * b.s),
        .wxz = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz - a.x * b.s),
        .xyz = a.w * b.s,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectivePoint& a,const ProjectiveTranslator& b) noexcept { return {
        .x = (a.w * b.wx + a.x * b.s),
        .y = (a.w * b.wy + a.y * b.s),
        .z = (a.w * b.wz + a.z * b.s),
        .w = a.w * b.s
    }; }
    constexpr ProjectivePoint ProjectivePoint::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectivePoint& a,const Translator& b) noexcept { return {
        .x = (a.x + a.w * b.wx),
        .y = (a.y + a.w * b.wy),
        .z = (a.z + a.w * b.wz),
        .w = a.w
    }; }
    constexpr ProjectivePoint ProjectivePoint::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const ProjectivePoint& a,const Vector& b) noexcept { return {
        .wx = -a.w * b.x,
        .wy = -a.w * b.y,
        .wz = -a.w * b.z
    }; }
    constexpr BivectorWeight ProjectivePoint::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectivePoint& a,const Point& b) noexcept { return {
        .s = -a.w,
        .wx = (a.x - a.w * b.x),
        .wy = (a.y - a.w * b.y),
        .wz = (a.z - a.w * b.z)
    }; }
    constexpr ProjectiveTranslator ProjectivePoint::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const ProjectivePoint& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = a.w * b.z,
        .xz = -a.w * b.y,
        .yz = a.w * b.x,
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr Motor ProjectivePoint::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -a.w * b.yz,
        .y = a.w * b.xz,
        .z = -a.w * b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.x * b.xz - a.y * b.yz),
        .wxz = (a.x * b.xy - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const ProjectivePoint& a,const BivectorWeight& b) noexcept { return {
        .x = a.w * b.wx,
        .y = a.w * b.wy,
        .z = a.w * b.wz
    }; }
    constexpr Vector ProjectivePoint::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Plane geometric(const ProjectivePoint& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.w * b.i
    }; }
    constexpr Plane ProjectivePoint::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectivePoint& a,const PointCenter& b) noexcept { return {
        .s = -a.w,
        .wx = a.x,
        .wy = a.y,
        .wz = a.z
    }; }
    constexpr ProjectiveTranslator ProjectivePoint::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Quaternion& a,const Motor& b) noexcept { return {
        .s = (a.s * b.s - a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.s * b.wx + a.xy * b.wy + a.xz * b.wz - a.yz * b.i),
        .wy = (a.s * b.wy + a.xz * b.i + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.s * b.wz - a.xy * b.i - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.s * b.xy + a.xy * b.s + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.s * b.xz + a.xy * b.yz + a.xz * b.s - a.yz * b.xy),
        .yz = (a.s * b.yz + a.xz * b.xy + a.yz * b.s - a.xy * b.xz),
        .i = (a.s * b.i + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Quaternion::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Quaternion& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = a.s * b.w,
        .x = (a.s * b.x + a.xy * b.y + a.xz * b.z),
        .y = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .z = (a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.xy * b.w,
        .wxz = a.xz * b.w,
        .wyz = a.yz * b.w,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Quaternion& a,const Bivector& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.s * b.wx + a.xy * b.wy + a.xz * b.wz),
        .wy = (a.s * b.wy + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.s * b.xy + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.s * b.xz + a.xy * b.yz - a.yz * b.xy),
        .yz = (a.s * b.yz + a.xz * b.xy - a.xy * b.xz),
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Quaternion::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Quaternion& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.xz * b.x + a.yz * b.y - a.s * b.z),
        .wxz = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .wyz = (-a.s * b.x - a.xy * b.y - a.xz * b.z),
        .xyz = a.s * b.w,
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Quaternion geometric(const Quaternion& a,const Quaternion& b) noexcept { return {
        .s = (a.s * b.s - a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .xy = (a.s * b.xy + a.xy * b.s + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.s * b.xz + a.xy * b.yz + a.xz * b.s - a.yz * b.xy),
        .yz = (a.s * b.yz + a.xz * b.xy + a.yz * b.s - a.xy * b.xz)
    }; }
    constexpr Quaternion Quaternion::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Quaternion& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.xy * b.wy + a.xz * b.wz),
        .wy = (a.s * b.wy + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Quaternion::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Quaternion& a,const Translator& b) noexcept { return {
        .s = a.s,
        .wx = (a.s * b.wx + a.xy * b.wy + a.xz * b.wz),
        .wy = (a.s * b.wy + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Quaternion::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Quaternion& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.xz * b.x + a.yz * b.y - a.s * b.z),
        .wxz = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .wyz = (-a.s * b.x - a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Quaternion& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.xz * b.x + a.yz * b.y - a.s * b.z),
        .wxz = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .wyz = (-a.s * b.x - a.xy * b.y - a.xz * b.z),
        .xyz = a.s,
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Quaternion& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.s * b.x + a.xy * b.y + a.xz * b.z),
        .y = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .z = (a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Quaternion geometric(const Quaternion& a,const BivectorBulk& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .xy = (a.s * b.xy + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.s * b.xz + a.xy * b.yz - a.yz * b.xy),
        .yz = (a.s * b.yz + a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Quaternion Quaternion::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Quaternion& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = (a.s * b.wx + a.xy * b.wy + a.xz * b.wz),
        .wy = (a.s * b.wy + a.yz * b.wz - a.xy * b.wx),
        .wz = (a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor Quaternion::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Quaternion& a,const PseudoScalar& b) noexcept { return {
        .s = 0.0,
        .wx = -a.yz * b.i,
        .wy = a.xz * b.i,
        .wz = -a.xy * b.i,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.s * b.i
    }; }
    constexpr Motor Quaternion::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Quaternion& a,const PointCenter& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = a.s,
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& a,const Motor& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.s * b.wy + a.wx * b.xy + a.wy * b.s - a.wz * b.yz),
        .wz = (a.s * b.wz + a.wx * b.xz + a.wy * b.yz + a.wz * b.s),
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.s * b.i + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor ProjectiveTranslator::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const ProjectiveTranslator& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = (a.s * b.w + a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = (a.s * b.wx - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.s * b.wy + a.wx * b.xy - a.wz * b.yz),
        .wz = (a.s * b.wz + a.wx * b.xz + a.wy * b.yz),
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor ProjectiveTranslator::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectiveTranslator& a,const ProjectivePoint& b) noexcept { return {
        .x = (a.s * b.x - a.wx * b.w),
        .y = (a.s * b.y - a.wy * b.w),
        .z = (a.s * b.z - a.wz * b.w),
        .w = a.s * b.w
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& a,const Quaternion& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.wy * b.s - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz + a.wz * b.s),
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor ProjectiveTranslator::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectiveTranslator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s),
        .wy = (a.s * b.wy + a.wy * b.s),
        .wz = (a.s * b.wz + a.wz * b.s)
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectiveTranslator& a,const Translator& b) noexcept { return {
        .s = a.s,
        .wx = (a.wx + a.s * b.wx),
        .wy = (a.wy + a.s * b.wy),
        .wz = (a.wz + a.s * b.wz)
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const ProjectiveTranslator& a,const Vector& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z
    }; }
    constexpr Vector ProjectiveTranslator::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectiveTranslator& a,const Point& b) noexcept { return {
        .x = (-a.wx + a.s * b.x),
        .y = (-a.wy + a.s * b.y),
        .z = (-a.wz + a.s * b.z),
        .w = a.s
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const ProjectiveTranslator& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz),
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor ProjectiveTranslator::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const ProjectiveTranslator& a,const BivectorWeight& b) noexcept { return {
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz
    }; }
    constexpr BivectorWeight ProjectiveTranslator::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr PseudoScalar geometric(const ProjectiveTranslator& a,const PseudoScalar& b) noexcept { return {
        .i = a.s * b.i
    }; }
    constexpr PseudoScalar ProjectiveTranslator::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectiveTranslator& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz,
        .w = a.s
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Translator& a,const Motor& b) noexcept { return {
        .s = b.s,
        .wx = (b.wx + a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .wy = (b.wy + a.wx * b.xy + a.wy * b.s - a.wz * b.yz),
        .wz = (b.wz + a.wx * b.xz + a.wy * b.yz + a.wz * b.s),
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (b.i + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor Translator::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Translator& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = (b.w + a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Translator& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = (b.wx - a.wy * b.xy - a.wz * b.xz),
        .wy = (b.wy + a.wx * b.xy - a.wz * b.yz),
        .wz = (b.wz + a.wx * b.xz + a.wy * b.yz),
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor Translator::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint geometric(const Translator& a,const ProjectivePoint& b) noexcept { return {
        .x = (b.x - a.wx * b.w),
        .y = (b.y - a.wy * b.w),
        .z = (b.z - a.wz * b.w),
        .w = b.w
    }; }
    constexpr ProjectivePoint Translator::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Translator& a,const Quaternion& b) noexcept { return {
        .s = b.s,
        .wx = (a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.wy * b.s - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz + a.wz * b.s),
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor Translator::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const Translator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = b.s,
        .wx = (b.wx + a.wx * b.s),
        .wy = (b.wy + a.wy * b.s),
        .wz = (b.wz + a.wz * b.s)
    }; }
    constexpr ProjectiveTranslator Translator::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Translator geometric(const Translator& a,const Translator& b) noexcept { return {
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz)
    }; }
    constexpr Translator Translator::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const Translator& a,const Vector& b) noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z
    }; }
    constexpr Vector Translator::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Point geometric(const Translator& a,const Point& b) noexcept { return {
        .x = (b.x - a.wx),
        .y = (b.y - a.wy),
        .z = (b.z - a.wz)
    }; }
    constexpr Point Translator::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Translator& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Translator& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz),
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor Translator::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const Translator& a,const BivectorWeight& b) noexcept { return {
        .wx = b.wx,
        .wy = b.wy,
        .wz = b.wz
    }; }
    constexpr BivectorWeight Translator::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr PseudoScalar geometric(const Translator& a,const PseudoScalar& b) noexcept { return {
        .i = b.i
    }; }
    constexpr PseudoScalar Translator::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Point geometric(const Translator& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Point Translator::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Vector& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.x * b.xz - a.y * b.yz - a.z * b.s),
        .wxz = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz - a.x * b.s),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Vector& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr Motor Vector::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Vector& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.x * b.xz - a.y * b.yz),
        .wxz = (a.x * b.xy - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const Vector& a,const ProjectivePoint& b) noexcept { return {
        .wx = a.x * b.w,
        .wy = a.y * b.w,
        .wz = a.z * b.w
    }; }
    constexpr BivectorWeight Vector::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Vector& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.x * b.xz - a.y * b.yz - a.z * b.s),
        .wxz = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz - a.x * b.s),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const Vector& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s
    }; }
    constexpr Vector Vector::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const Vector& a,const Translator& b) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr Vector Vector::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const Vector& a,const Point& b) noexcept { return {
        .wx = a.x,
        .wy = a.y,
        .wz = a.z
    }; }
    constexpr BivectorWeight Vector::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Vector& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr Motor Vector::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Vector& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.x * b.xz - a.y * b.yz),
        .wxz = (a.x * b.xy - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const Vector& a,const PointCenter& b) noexcept { return {
        .wx = a.x,
        .wy = a.y,
        .wz = a.z
    }; }
    constexpr BivectorWeight Vector::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Point& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (b.i + a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-b.wz - a.x * b.xz - a.y * b.yz - a.z * b.s),
        .wxz = (b.wy + a.x * b.xy + a.y * b.s - a.z * b.yz),
        .wyz = (-b.wx + a.y * b.xy + a.z * b.xz - a.x * b.s),
        .xyz = b.s,
        .i = 0.0
    }; }
    constexpr Multivector Point::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Point& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x,
        .i = (-b.w - a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr Motor Point::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Point& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-b.wz - a.x * b.xz - a.y * b.yz),
        .wxz = (b.wy + a.x * b.xy - a.z * b.yz),
        .wyz = (-b.wx + a.y * b.xy + a.z * b.xz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Point::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const Point& a,const ProjectivePoint& b) noexcept { return {
        .s = -b.w,
        .wx = (-b.x + a.x * b.w),
        .wy = (-b.y + a.y * b.w),
        .wz = (-b.z + a.z * b.w)
    }; }
    constexpr ProjectiveTranslator Point::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Point& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.x * b.xz - a.y * b.yz - a.z * b.s),
        .wxz = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz - a.x * b.s),
        .xyz = b.s,
        .i = 0.0
    }; }
    constexpr Multivector Point::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint geometric(const Point& a,const ProjectiveTranslator& b) noexcept { return {
        .x = (b.wx + a.x * b.s),
        .y = (b.wy + a.y * b.s),
        .z = (b.wz + a.z * b.s),
        .w = b.s
    }; }
    constexpr ProjectivePoint Point::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Point geometric(const Point& a,const Translator& b) noexcept { return {
        .x = (a.x + b.wx),
        .y = (a.y + b.wy),
        .z = (a.z + b.wz)
    }; }
    constexpr Point Point::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const Point& a,const Vector& b) noexcept { return {
        .wx = -b.x,
        .wy = -b.y,
        .wz = -b.z
    }; }
    constexpr BivectorWeight Point::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const Point& a,const Point& b) noexcept { return {
        .s = -1.0,
        .wx = (a.x - b.x),
        .wy = (a.y - b.y),
        .wz = (a.z - b.z)
    }; }
    constexpr ProjectiveTranslator Point::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const Point& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x,
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr Motor Point::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const Point& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.x * b.xz - a.y * b.yz),
        .wxz = (a.x * b.xy - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Point::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const Point& a,const BivectorWeight& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Vector Point::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Plane geometric(const Point& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr Plane Point::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const Point& a,const PointCenter& b) noexcept { return {
        .s = -1.0,
        .wx = a.x,
        .wy = a.y,
        .wz = a.z
    }; }
    constexpr ProjectiveTranslator Point::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = (a.x * b.s - a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz + a.z * b.s),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy - a.z * b.i),
        .wxz = (a.y * b.i + a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.x * b.i - a.y * b.wz),
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& a,const Plane& b) noexcept { return {
        .s = (a.x * b.x + a.y * b.y + a.z * b.z),
        .wx = -a.x * b.w,
        .wy = -a.y * b.w,
        .wz = -a.z * b.w,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y),
        .i = 0.0
    }; }
    constexpr Motor PlaneIdeal::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = a.z * b.w,
        .xz = -a.y * b.w,
        .yz = a.x * b.w,
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor PlaneIdeal::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.x * b.s - a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz + a.z * b.s),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor PlaneIdeal::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& a,const Point& b) noexcept { return {
        .s = 0.0,
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = a.z,
        .xz = -a.y,
        .yz = a.x,
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor PlaneIdeal::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Quaternion geometric(const PlaneIdeal& a,const PlaneIdeal& b) noexcept { return {
        .s = (a.x * b.x + a.y * b.y + a.z * b.z),
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Quaternion PlaneIdeal::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const PlaneIdeal& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr Vector PlaneIdeal::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk geometric(const PlaneIdeal& a,const PointCenter& b) noexcept { return {
        .xy = a.z,
        .xz = -a.y,
        .yz = a.x
    }; }
    constexpr BivectorBulk PlaneIdeal::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const BivectorBulk& a,const Motor& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.xy * b.wy + a.xz * b.wz - a.yz * b.i),
        .wy = (a.xz * b.i + a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xy * b.i - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.xy * b.s + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz + a.xz * b.s - a.yz * b.xy),
        .yz = (a.xz * b.xy + a.yz * b.s - a.xy * b.xz),
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor BivectorBulk::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.xy * b.w,
        .wxz = a.xz * b.w,
        .wyz = a.yz * b.w,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector BivectorBulk::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const BivectorBulk& a,const Bivector& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz),
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor BivectorBulk::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.xz * b.x + a.yz * b.y),
        .wxz = (a.yz * b.z - a.xy * b.x),
        .wyz = (-a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector BivectorBulk::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Quaternion geometric(const BivectorBulk& a,const Quaternion& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .xy = (a.xy * b.s + a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz + a.xz * b.s - a.yz * b.xy),
        .yz = (a.xz * b.xy + a.yz * b.s - a.xy * b.xz)
    }; }
    constexpr Quaternion BivectorBulk::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const BivectorBulk& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy),
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor BivectorBulk::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const BivectorBulk& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy),
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor BivectorBulk::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.xz * b.x + a.yz * b.y),
        .wxz = (a.yz * b.z - a.xy * b.x),
        .wyz = (-a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector BivectorBulk::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.xz * b.x + a.yz * b.y),
        .wxz = (a.yz * b.z - a.xy * b.x),
        .wyz = (-a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector BivectorBulk::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector BivectorBulk::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Quaternion geometric(const BivectorBulk& a,const BivectorBulk& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Quaternion BivectorBulk::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const BivectorBulk& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    constexpr Motor BivectorBulk::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const BivectorBulk& a,const PseudoScalar& b) noexcept { return {
        .wx = -a.yz * b.i,
        .wy = a.xz * b.i,
        .wz = -a.xy * b.i
    }; }
    constexpr BivectorWeight BivectorBulk::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal geometric(const BivectorBulk& a,const PointCenter& b) noexcept { return {
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy
    }; }
    constexpr PlaneIdeal BivectorBulk::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const BivectorWeight& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.wy * b.s - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz + a.wz * b.s),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor BivectorWeight::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const BivectorWeight& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector BivectorWeight::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const BivectorWeight& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor BivectorWeight::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const BivectorWeight& a,const ProjectivePoint& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w
    }; }
    constexpr Vector BivectorWeight::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const BivectorWeight& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.wy * b.s - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz + a.wz * b.s),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor BivectorWeight::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const BivectorWeight& a,const ProjectiveTranslator& b) noexcept { return {
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s
    }; }
    constexpr BivectorWeight BivectorWeight::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const BivectorWeight& a,const Translator& b) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz
    }; }
    constexpr BivectorWeight BivectorWeight::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const BivectorWeight& a,const Point& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Vector BivectorWeight::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const BivectorWeight& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector BivectorWeight::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const BivectorWeight& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    constexpr Motor BivectorWeight::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const BivectorWeight& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Vector BivectorWeight::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const PseudoScalar& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .wx = -a.i * b.yz,
        .wy = a.i * b.xz,
        .wz = -a.i * b.xy,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.i * b.s
    }; }
    constexpr Motor PseudoScalar::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const PseudoScalar& a,const Plane& b) noexcept { return {
        .x = -a.i * b.x,
        .y = -a.i * b.y,
        .z = -a.i * b.z
    }; }
    constexpr Vector PseudoScalar::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const PseudoScalar& a,const Bivector& b) noexcept { return {
        .wx = -a.i * b.yz,
        .wy = a.i * b.xz,
        .wz = -a.i * b.xy
    }; }
    constexpr BivectorWeight PseudoScalar::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Plane geometric(const PseudoScalar& a,const ProjectivePoint& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.i * b.w
    }; }
    constexpr Plane PseudoScalar::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const PseudoScalar& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .wx = -a.i * b.yz,
        .wy = a.i * b.xz,
        .wz = -a.i * b.xy,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.i * b.s
    }; }
    constexpr Motor PseudoScalar::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr PseudoScalar geometric(const PseudoScalar& a,const ProjectiveTranslator& b) noexcept { return {
        .i = a.i * b.s
    }; }
    constexpr PseudoScalar PseudoScalar::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr PseudoScalar geometric(const PseudoScalar& a,const Translator& b) noexcept { return {
        .i = a.i
    }; }
    constexpr PseudoScalar PseudoScalar::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Plane geometric(const PseudoScalar& a,const Point& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.i
    }; }
    constexpr Plane PseudoScalar::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const PseudoScalar& a,const PlaneIdeal& b) noexcept { return {
        .x = -a.i * b.x,
        .y = -a.i * b.y,
        .z = -a.i * b.z
    }; }
    constexpr Vector PseudoScalar::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const PseudoScalar& a,const BivectorBulk& b) noexcept { return {
        .wx = -a.i * b.yz,
        .wy = a.i * b.xz,
        .wz = -a.i * b.xy
    }; }
    constexpr BivectorWeight PseudoScalar::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Plane geometric(const PseudoScalar& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.i
    }; }
    constexpr Plane PseudoScalar::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PointCenter& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = b.i,
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -b.wz,
        .wxz = b.wy,
        .wyz = -b.wx,
        .xyz = b.s,
        .i = 0.0
    }; }
    constexpr Multivector PointCenter::geometric(const Motor& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Motor geometric(const PointCenter& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x,
        .i = -b.w
    }; }
    constexpr Motor PointCenter::geometric(const Plane& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PointCenter& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -b.wz,
        .wxz = b.wy,
        .wyz = -b.wx,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector PointCenter::geometric(const Bivector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const PointCenter& a,const ProjectivePoint& b) noexcept { return {
        .s = -b.w,
        .wx = -b.x,
        .wy = -b.y,
        .wz = -b.z
    }; }
    constexpr ProjectiveTranslator PointCenter::geometric(const ProjectivePoint& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Multivector geometric(const PointCenter& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = b.s,
        .i = 0.0
    }; }
    constexpr Multivector PointCenter::geometric(const Quaternion& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint geometric(const PointCenter& a,const ProjectiveTranslator& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz,
        .w = b.s
    }; }
    constexpr ProjectivePoint PointCenter::geometric(const ProjectiveTranslator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Point geometric(const PointCenter& a,const Translator& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Point PointCenter::geometric(const Translator& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight geometric(const PointCenter& a,const Vector& b) noexcept { return {
        .wx = -b.x,
        .wy = -b.y,
        .wz = -b.z
    }; }
    constexpr BivectorWeight PointCenter::geometric(const Vector& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator geometric(const PointCenter& a,const Point& b) noexcept { return {
        .s = -1.0,
        .wx = -b.x,
        .wy = -b.y,
        .wz = -b.z
    }; }
    constexpr ProjectiveTranslator PointCenter::geometric(const Point& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk geometric(const PointCenter& a,const PlaneIdeal& b) noexcept { return {
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    constexpr BivectorBulk PointCenter::geometric(const PlaneIdeal& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal geometric(const PointCenter& a,const BivectorBulk& b) noexcept { return {
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy
    }; }
    constexpr PlaneIdeal PointCenter::geometric(const BivectorBulk& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Vector geometric(const PointCenter& a,const BivectorWeight& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Vector PointCenter::geometric(const BivectorWeight& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr Plane geometric(const PointCenter& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr Plane PointCenter::geometric(const PseudoScalar& b) const noexcept { return pga3d::geometric(*this, b); }

    [[nodiscard]] constexpr double geometric(const PointCenter& a,const PointCenter& b) noexcept { return -1.0; }
    constexpr double PointCenter::geometric(const PointCenter& b) const noexcept { return pga3d::geometric(*this, b); }

}

// opsQuaternion.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.QuaternionOpsGenerator

namespace pga3d {
    [[nodiscard]] inline Quaternion Quaternion::rotation(const Vector& from, const Vector& to) noexcept {
        return rotation(from.dual(), to.dual());
    }

    [[nodiscard]] inline Quaternion Quaternion::rotation(const PlaneIdeal& from, const PlaneIdeal& to) noexcept {
        const double norm = std::sqrt(from.normSquare() * to.normSquare());
        const Quaternion q2a = to.geometric(from) / norm;
        const double dot = q2a.s;

        if (dot > -1.0 + 1e-6) {
            const double newCos = std::sqrt((1.0 + dot) / 2);
            const double newSinDivSin2 = 0.5 / newCos;
            return Quaternion(newCos, q2a.xy * newSinDivSin2, q2a.xz * newSinDivSin2, q2a.yz * newSinDivSin2);
        }

        const double sin2a = std::sqrt(q2a.xy * q2a.xy + q2a.xz * q2a.xz + q2a.yz * q2a.yz);

        if (sin2a > 1e-8) {
            const double angle2 = std::atan2(sin2a, q2a.s);
            const double propAngle = angle2 * 0.5;
            const double mult = std::sin(propAngle) / sin2a;
            return Quaternion(std::cos(propAngle), q2a.xy * mult, q2a.xz * mult, q2a.yz * mult).normalizedByNorm();
        }

        // choose any axis
        const PlaneIdeal orthogonalPlane =
            (std::abs(from.x) > std::abs(from.z)) ? PlaneIdeal{-from.y, from.x, 0} : PlaneIdeal{0, -from.z, from.y};

        return Quaternion(0, orthogonalPlane.z, -orthogonalPlane.y, orthogonalPlane.x).normalizedByNorm();
    }

    [[nodiscard]] inline BivectorBulk Quaternion::log() const noexcept {
        const double scalar = s;
        if (s < 0.0) return (-(*this)).log();

        const double lenXYZ = std::sqrt(xy * xy + xz * xz + yz * yz);
        const double angle = std::atan2(lenXYZ, scalar);

         // 1 / sin^2
        const double a = 1.0 / (1.0 - scalar * scalar);

        // angle / sin(angle)
        const double b = (std::abs(angle) > 1e-5) ? angle * std::sqrt(a) : (1.0 + angle * angle / 6.0);

        return BivectorBulk {
            .xy = b * xy,
            .xz = b * xz,
            .yz = b * yz,
        };
    }

    [[nodiscard]] inline Quaternion Quaternion::pow(double p) const noexcept {
       return (log() * p).exp();
    }

    [[nodiscard]] inline Quaternion Quaternion::projectToRotationInPlane(const PlaneIdeal& plane) const noexcept {
        const Quaternion q = normalizedByNorm();
        const Quaternion qPart = Quaternion::rotation(q.sandwich(plane), plane);
        return qPart.geometric(q);
    }

    [[nodiscard]] inline double Quaternion::restoreRotationInPlane(const PlaneIdeal& plane) const noexcept {
        const Quaternion q0 = projectToRotationInPlane(plane);
        const BivectorWeight logDual = q0.log().dual();
        const double currentAngle = 2.0 * (logDual.wx * plane.x + logDual.wy * plane.y + logDual.wz * plane.z) / plane.norm();
        return currentAngle;
    }

    [[nodiscard]] constexpr Vector Quaternion::axisX() const noexcept { return {.x = (s * s + yz * yz - xy * xy - xz * xz), .y = 2.0 * (-s * xy - xz * yz), .z = 2.0 * (xy * yz - s * xz)}; }
    [[nodiscard]] constexpr Vector Quaternion::axisY() const noexcept { return {.x = 2.0 * (s * xy - xz * yz), .y = (s * s + xz * xz - xy * xy - yz * yz), .z = 2.0 * (-s * yz - xy * xz)}; }
    [[nodiscard]] constexpr Vector Quaternion::axisZ() const noexcept { return {.x = 2.0 * (s * xz + xy * yz), .y = 2.0 * (s * yz - xy * xz), .z = (s * s + xy * xy - xz * xz - yz * yz)}; }
}

// opsTranslator.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.TranslatorOpsGenerator

namespace pga3d {

    [[nodiscard]] constexpr Translator Translator::addVector(const Vector& v) noexcept {
        return {
            .wx = -0.5 * v.x,
            .wy = -0.5 * v.y,
            .wz = -0.5 * v.z
        };
    }

    [[nodiscard]] constexpr BivectorWeight Translator::log() const noexcept {
        return BivectorWeight {
            .wx = wx,
            .wy = wy,
            .wz = wz,
        };
    }

    [[nodiscard]] constexpr Translator Translator::pow(double p) const noexcept {
       return (log() * p).exp();
    }
}

// opsMotor.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.MotorOpsGenerator

namespace pga3d {

    [[nodiscard]] constexpr Motor Motor::addVector(const Vector& v) noexcept { return {.s = 1.0, .wx = v.x, .wy = v.y, .wz = v.z}; }

    [[nodiscard]] inline Bivector Motor::log() const noexcept {
        const double scalar = s;
        if (s < 0.0) return (-(*this)).log();

        const double lenXYZ = std::sqrt(xy * xy + xz * xz + yz * yz);
        const double angle = std::atan2(lenXYZ, scalar);

        // 1 / sin^2
        const double a = 1.0 / (1.0 - scalar * scalar);

        // angle / sin(angle)
        const double b = (std::abs(angle) > 1e-5)
            ? (angle * std::sqrt(a))
            : (1.0 + angle * angle / 6.0);

        const double c = (std::abs(angle) > 1e-5)
            ? (a * i * (1.0 - scalar * b))
            : ((1.0 + angle * angle / 2.0) * i / 3.0);

        return Bivector {
            .wx = (b * wx + c * yz),
            .wy = (b * wy - c * xz),
            .wz = (b * wz + c * xy),
            .xy = b * xy,
            .xz = b * xz,
            .yz = b * yz,
        };
    }

    [[nodiscard]] inline Motor Motor::pow(double p) const noexcept {
       return (log() * p).exp();
    }

    [[nodiscard]] constexpr QuaternionWithTranslator Motor::toQuaternionWithTranslator() const noexcept {
        return toTranslatorWithQuaternion().toQuaternionWithTranslator();
    }

    [[nodiscard]] constexpr TranslatorWithQuaternion Motor::toTranslatorWithQuaternion() const noexcept {
        const Quaternion q = toQuaternionUnsafe();
        const Vector shift = sandwich(PointCenter{}).toPoint().toVectorUnsafe();
        const Translator t = Translator::addVector(shift);
        return { t, q };
    }

    /**
     * see [[https://arxiv.org/abs/2206.07496]], page 14
     * and [[https://https://bivector.net/PGAdyn.pdf.net/PGAdyn.pdf]], page 42
     */
    [[nodiscard]] inline Motor Motor::renormalized() const noexcept {
        const double a2 = 1.0 / (s * s + xy * xy + xz * xz + yz * yz);
        const double a = std::sqrt(a2);
        const double b = (s * i - wx * yz + wy * xz - wz * xy) * a * a2;
        return Motor {
            .s = a * s,
            .wx = a * wx + b * yz,
            .wy = a * wy - b * xz,
            .wz = a * wz + b * xy,
            .xy = a * xy,
            .xz = a * xz,
            .yz = a * yz,
            .i = a * i - b * s,
        };
    }

    [[nodiscard]] constexpr Vector Motor::axisX() const noexcept { return toQuaternionUnsafe().axisX(); }
    [[nodiscard]] constexpr Vector Motor::axisY() const noexcept { return toQuaternionUnsafe().axisY(); }
    [[nodiscard]] constexpr Vector Motor::axisZ() const noexcept { return toQuaternionUnsafe().axisZ(); }
}

// opsBivector.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorOpsGenerator

namespace pga3d {

    inline std::pair<Bivector, BivectorWeight> Bivector::split() const noexcept {
        const double div = bulkNormSquare();
        if (div < 1e-100) {
            return {
                Bivector{ .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz },
                BivectorWeight{ .wx = wx, .wy = wy, .wz = wz }
            };
        }

        const double pseudoScalar = (wy * xz - wx * yz - wz * xy) / div;
        const BivectorWeight shiftAlongLine{
            .wx = -pseudoScalar * yz,
            .wy = pseudoScalar * xz,
            .wz = -pseudoScalar * xy
        };

        const Bivector line = (*this) - shiftAlongLine;
        return {line, shiftAlongLine};
    }

    inline Motor Bivector::exp() const noexcept {
        const double len = bulkNorm();
        const double cos = std::cos(len);

        const double sinDivLen = (len > 1e-5) ?
            (std::sin(len) / len) :
            (1.0 - (len * len) / 6.0);

        const double sinMinusCosDivLen2 = (len > 1e-5) ?
            (sinDivLen - cos) / (len * len) :
            (1.0 / 3.0) * (1.0 + 0.8 * len * len);

        return Motor {
          .s = cos,
          .wx = (sinDivLen * wx + sinMinusCosDivLen2 * yz * (wy * xz - wx * yz - wz * xy)),
          .wy = (sinDivLen * wy + sinMinusCosDivLen2 * xz * (wx * yz + wz * xy - wy * xz)),
          .wz = (sinDivLen * wz + sinMinusCosDivLen2 * xy * (wy * xz - wx * yz - wz * xy)),
          .xy = sinDivLen * xy,
          .xz = sinDivLen * xz,
          .yz = sinDivLen * yz,
          .i = sinDivLen * (wx * yz + wz * xy - wy * xz),
        };
    }
}

// opsBivectorBulk.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorBulkOpsGenerator

namespace pga3d {

    [[nodiscard]] inline Quaternion BivectorBulk::exp() const noexcept {
        const double len = bulkNorm();
        const double cos = std::cos(len);

        const double sinDivLen = (len > 1e-5)
            ? (std::sin(len) / len)
            : (1.0 - (len * len) / 6.0);

        return Quaternion{
            .s = cos,
            .xy = sinDivLen * xy,
            .xz = sinDivLen * xz,
            .yz = sinDivLen * yz,
        };
    }
}

// opsBivectorWeight.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorWeightOpsGenerator

namespace pga3d {

    [[nodiscard]] constexpr Translator BivectorWeight::exp() const noexcept {
        return Translator{
            .wx = wx,
            .wy = wy,
            .wz = wz,
        };
    }
}

// opsPoint.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.PointOpsGenerator

namespace pga3d {

    [[nodiscard]] inline double Point::distanceTo(const Point& other) const noexcept {
        return ((*this) - other).norm();
    }

    [[nodiscard]] constexpr Point Point::min(const Point& other) const noexcept {
        return Point{
            .x = std::min(x, other.x),
            .y = std::min(y, other.y),
            .z = std::min(z, other.z),
        };
    }

    [[nodiscard]] constexpr Point Point::max(const Point& other) const noexcept {
        return Point{
            .x = std::max(x, other.x),
            .y = std::max(y, other.y),
            .z = std::max(z, other.z),
        };
    }

    [[nodiscard]] constexpr Point Point::clamp(const Point& minV, const Point& maxV) const noexcept {
        return Point{
            .x = std::clamp(x, minV.x, maxV.x),
            .y = std::clamp(y, minV.y, maxV.y),
            .z = std::clamp(z, minV.z, maxV.z),
        };
    }
}

// opsVector.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.VectorOpsGenerator

namespace pga3d {

    [[nodiscard]] constexpr Vector Vector::min(const Vector& other) const noexcept {
        return Vector{
            .x = std::min(x, other.x),
            .y = std::min(y, other.y),
            .z = std::min(z, other.z),
        };
    }

    [[nodiscard]] constexpr Vector Vector::max(const Vector& other) const noexcept {
        return Vector{
            .x = std::max(x, other.x),
            .y = std::max(y, other.y),
            .z = std::max(z, other.z),
        };
    }

    [[nodiscard]] constexpr Vector Vector::clamp(const Vector& minV, const Vector& maxV) const noexcept {
        return Vector{
            .x = std::clamp(x, minV.x, maxV.x),
            .y = std::clamp(y, minV.y, maxV.y),
            .z = std::clamp(z, minV.z, maxV.z),
        };
    }
}

// opsDual.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

namespace pga3d {
    constexpr Multivector dual(const Multivector& a) noexcept { return {
        .s = a.i,
        .w = a.xyz,
        .x = -a.wyz,
        .y = a.wxz,
        .z = -a.wxy,
        .wx = a.yz,
        .wy = -a.xz,
        .wz = a.xy,
        .xy = a.wz,
        .xz = -a.wy,
        .yz = a.wx,
        .wxy = -a.z,
        .wxz = a.y,
        .wyz = -a.x,
        .xyz = a.w,
        .i = a.s
    }; }
    constexpr Multivector Multivector::dual() const noexcept { return pga3d::dual(*this); }

    constexpr Motor dual(const Motor& a) noexcept { return {
        .s = a.i,
        .wx = a.yz,
        .wy = -a.xz,
        .wz = a.xy,
        .xy = a.wz,
        .xz = -a.wy,
        .yz = a.wx,
        .i = a.s
    }; }
    constexpr Motor Motor::dual() const noexcept { return pga3d::dual(*this); }

    constexpr ProjectivePoint dual(const Plane& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .w = a.w
    }; }
    constexpr ProjectivePoint Plane::dual() const noexcept { return pga3d::dual(*this); }

    constexpr Bivector dual(const Bivector& a) noexcept { return {
        .wx = a.yz,
        .wy = -a.xz,
        .wz = a.xy,
        .xy = a.wz,
        .xz = -a.wy,
        .yz = a.wx
    }; }
    constexpr Bivector Bivector::dual() const noexcept { return pga3d::dual(*this); }

    constexpr Plane dual(const ProjectivePoint& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .w = a.w
    }; }
    constexpr Plane ProjectivePoint::dual() const noexcept { return pga3d::dual(*this); }

    constexpr Motor dual(const Quaternion& a) noexcept { return {
        .s = 0.0,
        .wx = a.yz,
        .wy = -a.xz,
        .wz = a.xy,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.s
    }; }
    constexpr Motor Quaternion::dual() const noexcept { return pga3d::dual(*this); }

    constexpr Motor dual(const ProjectiveTranslator& a) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = a.wz,
        .xz = -a.wy,
        .yz = a.wx,
        .i = a.s
    }; }
    constexpr Motor ProjectiveTranslator::dual() const noexcept { return pga3d::dual(*this); }

    constexpr Motor dual(const Translator& a) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = a.wz,
        .xz = -a.wy,
        .yz = a.wx,
        .i = 1.0
    }; }
    constexpr Motor Translator::dual() const noexcept { return pga3d::dual(*this); }

    constexpr PlaneIdeal dual(const Vector& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr PlaneIdeal Vector::dual() const noexcept { return pga3d::dual(*this); }

    constexpr Plane dual(const Point& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .w = 1.0
    }; }
    constexpr Plane Point::dual() const noexcept { return pga3d::dual(*this); }

    constexpr Vector dual(const PlaneIdeal& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr Vector PlaneIdeal::dual() const noexcept { return pga3d::dual(*this); }

    constexpr BivectorWeight dual(const BivectorBulk& a) noexcept { return {
        .wx = a.yz,
        .wy = -a.xz,
        .wz = a.xy
    }; }
    constexpr BivectorWeight BivectorBulk::dual() const noexcept { return pga3d::dual(*this); }

    constexpr BivectorBulk dual(const BivectorWeight& a) noexcept { return {
        .xy = a.wz,
        .xz = -a.wy,
        .yz = a.wx
    }; }
    constexpr BivectorBulk BivectorWeight::dual() const noexcept { return pga3d::dual(*this); }

    constexpr double dual(const PseudoScalar& a) noexcept { return a.i; }
    constexpr double PseudoScalar::dual() const noexcept { return pga3d::dual(*this); }

    constexpr Plane dual(const PointCenter& a) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = 1.0
    }; }
    constexpr Plane PointCenter::dual() const noexcept { return pga3d::dual(*this); }

}

// opsWeight.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

namespace pga3d {
    constexpr Multivector weight(const Multivector& a) noexcept { return {
        .s = 0.0,
        .w = a.w,
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wxy,
        .wxz = a.wxz,
        .wyz = a.wyz,
        .xyz = 0.0,
        .i = a.i
    }; }
    constexpr Multivector Multivector::weight() const noexcept { return pga3d::weight(*this); }

    constexpr Motor weight(const Motor& a) noexcept { return {
        .s = 0.0,
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.i
    }; }
    constexpr Motor Motor::weight() const noexcept { return pga3d::weight(*this); }

    constexpr Plane weight(const Plane& a) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.w
    }; }
    constexpr Plane Plane::weight() const noexcept { return pga3d::weight(*this); }

    constexpr BivectorWeight weight(const Bivector& a) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz
    }; }
    constexpr BivectorWeight Bivector::weight() const noexcept { return pga3d::weight(*this); }

    constexpr Vector weight(const ProjectivePoint& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr Vector ProjectivePoint::weight() const noexcept { return pga3d::weight(*this); }

    constexpr BivectorWeight weight(const ProjectiveTranslator& a) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz
    }; }
    constexpr BivectorWeight ProjectiveTranslator::weight() const noexcept { return pga3d::weight(*this); }

    constexpr BivectorWeight weight(const Translator& a) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz
    }; }
    constexpr BivectorWeight Translator::weight() const noexcept { return pga3d::weight(*this); }

    constexpr Vector weight(const Vector& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr Vector Vector::weight() const noexcept { return pga3d::weight(*this); }

    constexpr Vector weight(const Point& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr Vector Point::weight() const noexcept { return pga3d::weight(*this); }

    constexpr BivectorWeight weight(const BivectorWeight& a) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz
    }; }
    constexpr BivectorWeight BivectorWeight::weight() const noexcept { return pga3d::weight(*this); }

    constexpr PseudoScalar weight(const PseudoScalar& a) noexcept { return {
        .i = a.i
    }; }
    constexpr PseudoScalar PseudoScalar::weight() const noexcept { return pga3d::weight(*this); }

}

// opsBulk.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

namespace pga3d {
    constexpr Multivector bulk(const Multivector& a) noexcept { return {
        .s = a.s,
        .w = 0.0,
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = a.xyz,
        .i = 0.0
    }; }
    constexpr Multivector Multivector::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr Quaternion bulk(const Motor& a) noexcept { return {
        .s = a.s,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }
    constexpr Quaternion Motor::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr PlaneIdeal bulk(const Plane& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr PlaneIdeal Plane::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr BivectorBulk bulk(const Bivector& a) noexcept { return {
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }
    constexpr BivectorBulk Bivector::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr ProjectivePoint bulk(const ProjectivePoint& a) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.w
    }; }
    constexpr ProjectivePoint ProjectivePoint::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr Quaternion bulk(const Quaternion& a) noexcept { return {
        .s = a.s,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }
    constexpr Quaternion Quaternion::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr double bulk(const ProjectiveTranslator& a) noexcept { return a.s; }
    constexpr double ProjectiveTranslator::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr double bulk(const Translator& a) noexcept { return 1.0; }
    constexpr double Translator::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr PointCenter bulk(const Point& a) noexcept { return {}; }
    constexpr PointCenter Point::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr PlaneIdeal bulk(const PlaneIdeal& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr PlaneIdeal PlaneIdeal::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr BivectorBulk bulk(const BivectorBulk& a) noexcept { return {
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }
    constexpr BivectorBulk BivectorBulk::bulk() const noexcept { return pga3d::bulk(*this); }

    constexpr PointCenter bulk(const PointCenter& a) noexcept { return {}; }
    constexpr PointCenter PointCenter::bulk() const noexcept { return pga3d::bulk(*this); }

}

// opsReversed.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

namespace pga3d {
    constexpr Multivector reversed(const Multivector& a) noexcept { return {
        .s = a.s,
        .w = a.w,
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz,
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz,
        .wxy = -a.wxy,
        .wxz = -a.wxz,
        .wyz = -a.wyz,
        .xyz = -a.xyz,
        .i = a.i
    }; }
    constexpr Multivector Multivector::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr Motor reversed(const Motor& a) noexcept { return {
        .s = a.s,
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz,
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz,
        .i = a.i
    }; }
    constexpr Motor Motor::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr Plane reversed(const Plane& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .w = a.w
    }; }
    constexpr Plane Plane::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr Bivector reversed(const Bivector& a) noexcept { return {
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz,
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz
    }; }
    constexpr Bivector Bivector::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr ProjectivePoint reversed(const ProjectivePoint& a) noexcept { return {
        .x = -a.x,
        .y = -a.y,
        .z = -a.z,
        .w = -a.w
    }; }
    constexpr ProjectivePoint ProjectivePoint::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr Quaternion reversed(const Quaternion& a) noexcept { return {
        .s = a.s,
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz
    }; }
    constexpr Quaternion Quaternion::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr ProjectiveTranslator reversed(const ProjectiveTranslator& a) noexcept { return {
        .s = a.s,
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr Translator reversed(const Translator& a) noexcept { return {
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz
    }; }
    constexpr Translator Translator::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr Vector reversed(const Vector& a) noexcept { return {
        .x = -a.x,
        .y = -a.y,
        .z = -a.z
    }; }
    constexpr Vector Vector::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr ProjectivePoint reversed(const Point& a) noexcept { return {
        .x = -a.x,
        .y = -a.y,
        .z = -a.z,
        .w = -1.0
    }; }
    constexpr ProjectivePoint Point::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr PlaneIdeal reversed(const PlaneIdeal& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr PlaneIdeal PlaneIdeal::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr BivectorBulk reversed(const BivectorBulk& a) noexcept { return {
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz
    }; }
    constexpr BivectorBulk BivectorBulk::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr BivectorWeight reversed(const BivectorWeight& a) noexcept { return {
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz
    }; }
    constexpr BivectorWeight BivectorWeight::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr PseudoScalar reversed(const PseudoScalar& a) noexcept { return {
        .i = a.i
    }; }
    constexpr PseudoScalar PseudoScalar::reversed() const noexcept { return pga3d::reversed(*this); }

    constexpr ProjectivePoint reversed(const PointCenter& a) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -1.0
    }; }
    constexpr ProjectivePoint PointCenter::reversed() const noexcept { return pga3d::reversed(*this); }

}

// opsAntiReversed.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

namespace pga3d {
    constexpr Multivector antiReversed(const Multivector& a) noexcept { return {
        .s = a.s,
        .w = -a.w,
        .x = -a.x,
        .y = -a.y,
        .z = -a.z,
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz,
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz,
        .wxy = a.wxy,
        .wxz = a.wxz,
        .wyz = a.wyz,
        .xyz = a.xyz,
        .i = a.i
    }; }
    constexpr Multivector Multivector::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr Motor antiReversed(const Motor& a) noexcept { return {
        .s = a.s,
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz,
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz,
        .i = a.i
    }; }
    constexpr Motor Motor::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr Plane antiReversed(const Plane& a) noexcept { return {
        .x = -a.x,
        .y = -a.y,
        .z = -a.z,
        .w = -a.w
    }; }
    constexpr Plane Plane::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr Bivector antiReversed(const Bivector& a) noexcept { return {
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz,
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz
    }; }
    constexpr Bivector Bivector::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr ProjectivePoint antiReversed(const ProjectivePoint& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .w = a.w
    }; }
    constexpr ProjectivePoint ProjectivePoint::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr Quaternion antiReversed(const Quaternion& a) noexcept { return {
        .s = a.s,
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz
    }; }
    constexpr Quaternion Quaternion::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr ProjectiveTranslator antiReversed(const ProjectiveTranslator& a) noexcept { return {
        .s = a.s,
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr Translator antiReversed(const Translator& a) noexcept { return {
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz
    }; }
    constexpr Translator Translator::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr Vector antiReversed(const Vector& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr Vector Vector::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr Point antiReversed(const Point& a) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr Point Point::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr PlaneIdeal antiReversed(const PlaneIdeal& a) noexcept { return {
        .x = -a.x,
        .y = -a.y,
        .z = -a.z
    }; }
    constexpr PlaneIdeal PlaneIdeal::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr BivectorBulk antiReversed(const BivectorBulk& a) noexcept { return {
        .xy = -a.xy,
        .xz = -a.xz,
        .yz = -a.yz
    }; }
    constexpr BivectorBulk BivectorBulk::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr BivectorWeight antiReversed(const BivectorWeight& a) noexcept { return {
        .wx = -a.wx,
        .wy = -a.wy,
        .wz = -a.wz
    }; }
    constexpr BivectorWeight BivectorWeight::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr PseudoScalar antiReversed(const PseudoScalar& a) noexcept { return {
        .i = a.i
    }; }
    constexpr PseudoScalar PseudoScalar::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

    constexpr PointCenter antiReversed(const PointCenter& a) noexcept { return {}; }
    constexpr PointCenter PointCenter::antiReversed() const noexcept { return pga3d::antiReversed(*this); }

}

// opsTo.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

namespace pga3d {
    constexpr Motor Multivector::toMotorUnsafe() const noexcept { return {.s = s, .wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz, .i = i}; }
    constexpr Plane Multivector::toPlaneUnsafe() const noexcept { return {.x = x, .y = y, .z = z, .w = w}; }
    constexpr Bivector Multivector::toBivectorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectivePoint Multivector::toProjectivePointUnsafe() const noexcept { return {.x = -wyz, .y = wxz, .z = -wxy, .w = xyz}; }
    constexpr Quaternion Multivector::toQuaternionUnsafe() const noexcept { return {.s = s, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectiveTranslator Multivector::toProjectiveTranslatorUnsafe() const noexcept { return {.s = s, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr Translator Multivector::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr Vector Multivector::toVectorUnsafe() const noexcept { return {.x = -wyz, .y = wxz, .z = -wxy}; }
    constexpr Point Multivector::toPointUnsafe() const noexcept { return {.x = -wyz, .y = wxz, .z = -wxy}; }
    constexpr PlaneIdeal Multivector::toPlaneIdealUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorBulk Multivector::toBivectorBulkUnsafe() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr BivectorWeight Multivector::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector Motor::toMultivector() const noexcept { return {.s = s, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = i}; }
    constexpr Bivector Motor::toBivectorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr Quaternion Motor::toQuaternionUnsafe() const noexcept { return {.s = s, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectiveTranslator Motor::toProjectiveTranslatorUnsafe() const noexcept { return {.s = s, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr Translator Motor::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr BivectorBulk Motor::toBivectorBulkUnsafe() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr BivectorWeight Motor::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector Plane::toMultivector() const noexcept { return {.s = 0.0, .w = w, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr PlaneIdeal Plane::toPlaneIdealUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }

    constexpr Multivector Bivector::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Bivector::toMotor() const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz, .i = 0.0}; }
    constexpr Quaternion Bivector::toQuaternionUnsafe() const noexcept { return {.s = 0.0, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectiveTranslator Bivector::toProjectiveTranslatorUnsafe() const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr Translator Bivector::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr BivectorBulk Bivector::toBivectorBulkUnsafe() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr BivectorWeight Bivector::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector ProjectivePoint::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -z, .wxz = y, .wyz = -x, .xyz = w, .i = 0.0}; }
    constexpr Vector ProjectivePoint::toVectorUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr Point ProjectivePoint::toPointUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }

    constexpr Point ProjectivePoint::toPoint() const noexcept { const double inv = 1.0 / w; return { .x = x * inv, .y = y * inv, .z = z * inv }; }
    constexpr Multivector Quaternion::toMultivector() const noexcept { return {.s = s, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Quaternion::toMotor() const noexcept { return {.s = s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .i = 0.0}; }
    constexpr Bivector Quaternion::toBivectorUnsafe() const noexcept { return {.wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectiveTranslator Quaternion::toProjectiveTranslatorUnsafe() const noexcept { return {.s = s, .wx = 0.0, .wy = 0.0, .wz = 0.0}; }
    constexpr BivectorBulk Quaternion::toBivectorBulkUnsafe() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }

    constexpr Multivector ProjectiveTranslator::toMultivector() const noexcept { return {.s = s, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor ProjectiveTranslator::toMotor() const noexcept { return {.s = s, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr Bivector ProjectiveTranslator::toBivectorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr Quaternion ProjectiveTranslator::toQuaternionUnsafe() const noexcept { return {.s = s, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr Translator ProjectiveTranslator::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr BivectorWeight ProjectiveTranslator::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Translator ProjectiveTranslator::toTranslator() const noexcept { const double inv = 1.0 / s; return Translator{ .wx = wx * inv, .wy = wy * inv, .wz = wz * inv }; }
    constexpr Multivector Translator::toMultivector() const noexcept { return {.s = 1.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Translator::toMotor() const noexcept { return {.s = 1.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr Bivector Translator::toBivectorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr Quaternion Translator::toQuaternionUnsafe() const noexcept { return {.s = 1.0, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr ProjectiveTranslator Translator::toProjectiveTranslator() const noexcept { return {.s = 1.0, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr BivectorWeight Translator::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector Vector::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -z, .wxz = y, .wyz = -x, .xyz = 0.0, .i = 0.0}; }
    constexpr ProjectivePoint Vector::toProjectivePoint() const noexcept { return {.x = x, .y = y, .z = z, .w = 0.0}; }
    constexpr Point Vector::toPointUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }

    constexpr Multivector Point::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -z, .wxz = y, .wyz = -x, .xyz = 1.0, .i = 0.0}; }
    constexpr ProjectivePoint Point::toProjectivePoint() const noexcept { return {.x = x, .y = y, .z = z, .w = 1.0}; }
    constexpr Vector Point::toVectorUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }

    constexpr Multivector PlaneIdeal::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Plane PlaneIdeal::toPlane() const noexcept { return {.x = x, .y = y, .z = z, .w = 0.0}; }

    constexpr Multivector BivectorBulk::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor BivectorBulk::toMotor() const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .i = 0.0}; }
    constexpr Bivector BivectorBulk::toBivector() const noexcept { return {.wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr Quaternion BivectorBulk::toQuaternion() const noexcept { return {.s = 0.0, .xy = xy, .xz = xz, .yz = yz}; }

    constexpr Multivector BivectorWeight::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor BivectorWeight::toMotor() const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr Bivector BivectorWeight::toBivector() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr ProjectiveTranslator BivectorWeight::toProjectiveTranslator() const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr Translator BivectorWeight::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector PseudoScalar::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = i}; }
    constexpr Motor PseudoScalar::toMotor() const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = i}; }

    constexpr Multivector PointCenter::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 1.0, .i = 0.0}; }
    constexpr ProjectivePoint PointCenter::toProjectivePoint() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = 1.0}; }
    constexpr Vector PointCenter::toVectorUnsafe() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0}; }
    constexpr Point PointCenter::toPoint() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0}; }

}

// opsStr.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ToStreamOpGenerator

namespace pga3d {
    inline std::ostream &operator<<(std::ostream &os, const Multivector &v) {
        return os << "Multivector{" << ".s = " << v.s << ", "".w = " << v.w << ", "".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << ", "".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << ", "".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << ", "".wxy = " << v.wxy << ", "".wxz = " << v.wxz << ", "".wyz = " << v.wyz << ", "".xyz = " << v.xyz << ", "".i = " << v.i << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Motor &v) {
        return os << "Motor{" << ".s = " << v.s << ", "".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << ", "".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << ", "".i = " << v.i << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Plane &v) {
        return os << "Plane{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << ", "".w = " << v.w << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Bivector &v) {
        return os << "Bivector{" << ".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << ", "".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const ProjectivePoint &v) {
        return os << "ProjectivePoint{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << ", "".w = " << v.w << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Quaternion &v) {
        return os << "Quaternion{" << ".s = " << v.s << ", "".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const ProjectiveTranslator &v) {
        return os << "ProjectiveTranslator{" << ".s = " << v.s << ", "".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Translator &v) {
        return os << "Translator{" << ".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Vector &v) {
        return os << "Vector{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Point &v) {
        return os << "Point{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const PlaneIdeal &v) {
        return os << "PlaneIdeal{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const BivectorBulk &v) {
        return os << "BivectorBulk{" << ".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const BivectorWeight &v) {
        return os << "BivectorWeight{" << ".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const PseudoScalar &v) {
        return os << "PseudoScalar{" << ".i = " << v.i << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const PointCenter &v) {
        return os << "PointCenter{}";
    }
    inline std::ostream &operator<<(std::ostream &os, const QuaternionWithTranslator &v) {
       return os << "QuaternionWithTranslator{" << v.quaternion << ", " << v.translator << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const TranslatorWithQuaternion &v) {
        return os << "TranslatorWithQuaternion{" << v.translator << ", " << v.quaternion << "}";
    }

}

// opsDot.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

namespace pga3d {
    [[nodiscard]] constexpr Multivector dot(const Multivector& a,const Multivector& b) noexcept { return {
        .s = (a.s * b.s + a.x * b.x + a.y * b.y + a.z * b.z - a.xy * b.xy - a.xyz * b.xyz - a.xz * b.xz - a.yz * b.yz),
        .w = (a.s * b.w + a.w * b.s + a.wx * b.x + a.wy * b.y + a.wz * b.z + a.xyz * b.i - a.i * b.xyz - a.wxy * b.xy - a.wxz * b.xz - a.wyz * b.yz - a.x * b.wx - a.xy * b.wxy - a.xz * b.wxz - a.y * b.wy - a.yz * b.wyz - a.z * b.wz),
        .x = (a.s * b.x + a.x * b.s + a.xy * b.y + a.xz * b.z - a.xyz * b.yz - a.y * b.xy - a.yz * b.xyz - a.z * b.xz),
        .y = (a.s * b.y + a.x * b.xy + a.xyz * b.xz + a.xz * b.xyz + a.y * b.s + a.yz * b.z - a.xy * b.x - a.z * b.yz),
        .z = (a.s * b.z + a.x * b.xz + a.y * b.yz + a.z * b.s - a.xy * b.xyz - a.xyz * b.xy - a.xz * b.x - a.yz * b.y),
        .wx = (a.s * b.wx + a.wx * b.s + a.wxy * b.y + a.wxz * b.z + a.y * b.wxy + a.z * b.wxz - a.i * b.yz - a.yz * b.i),
        .wy = (a.i * b.xz + a.s * b.wy + a.wy * b.s + a.wyz * b.z + a.xz * b.i + a.z * b.wyz - a.wxy * b.x - a.x * b.wxy),
        .wz = (a.s * b.wz + a.wz * b.s - a.i * b.xy - a.wxz * b.x - a.wyz * b.y - a.x * b.wxz - a.xy * b.i - a.y * b.wyz),
        .xy = (a.s * b.xy + a.xy * b.s + a.xyz * b.z + a.z * b.xyz),
        .xz = (a.s * b.xz + a.xz * b.s - a.xyz * b.y - a.y * b.xyz),
        .yz = (a.s * b.yz + a.x * b.xyz + a.xyz * b.x + a.yz * b.s),
        .wxy = (a.i * b.z + a.s * b.wxy + a.wxy * b.s - a.z * b.i),
        .wxz = (a.s * b.wxz + a.wxz * b.s + a.y * b.i - a.i * b.y),
        .wyz = (a.i * b.x + a.s * b.wyz + a.wyz * b.s - a.x * b.i),
        .xyz = (a.s * b.xyz + a.xyz * b.s),
        .i = (a.i * b.s + a.s * b.i)
    }; }
    constexpr Multivector Multivector::dot(const Multivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Motor& a,const Motor& b) noexcept { return {
        .s = (a.s * b.s - a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.s * b.wx + a.wx * b.s - a.i * b.yz - a.yz * b.i),
        .wy = (a.i * b.xz + a.s * b.wy + a.wy * b.s + a.xz * b.i),
        .wz = (a.s * b.wz + a.wz * b.s - a.i * b.xy - a.xy * b.i),
        .xy = (a.s * b.xy + a.xy * b.s),
        .xz = (a.s * b.xz + a.xz * b.s),
        .yz = (a.s * b.yz + a.yz * b.s),
        .i = (a.i * b.s + a.s * b.i)
    }; }
    constexpr Motor Motor::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Motor& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = (a.s * b.w + a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.s * b.x + a.xy * b.y + a.xz * b.z),
        .y = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .z = (a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.i * b.z,
        .wxz = -a.i * b.y,
        .wyz = a.i * b.x,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Motor::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Motor& a,const Bivector& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.s * b.wx - a.i * b.yz),
        .wy = (a.i * b.xz + a.s * b.wy),
        .wz = (a.s * b.wz - a.i * b.xy),
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = 0.0
    }; }
    constexpr Motor Motor::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Motor& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.i * b.w - a.xz * b.y),
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.s * b.z,
        .wxz = a.s * b.y,
        .wyz = -a.s * b.x,
        .xyz = a.s * b.w,
        .i = 0.0
    }; }
    constexpr Multivector Motor::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Motor& a,const Quaternion& b) noexcept { return {
        .s = (a.s * b.s - a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.wx * b.s - a.i * b.yz),
        .wy = (a.i * b.xz + a.wy * b.s),
        .wz = (a.wz * b.s - a.i * b.xy),
        .xy = (a.s * b.xy + a.xy * b.s),
        .xz = (a.s * b.xz + a.xz * b.s),
        .yz = (a.s * b.yz + a.yz * b.s),
        .i = a.i * b.s
    }; }
    constexpr Motor Motor::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Motor& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s),
        .wy = (a.s * b.wy + a.wy * b.s),
        .wz = (a.s * b.wz + a.wz * b.s),
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = a.i * b.s
    }; }
    constexpr Motor Motor::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Motor& a,const Translator& b) noexcept { return {
        .s = a.s,
        .wx = (a.wx + a.s * b.wx),
        .wy = (a.wy + a.s * b.wy),
        .wz = (a.wz + a.s * b.wz),
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = a.i
    }; }
    constexpr Motor Motor::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Motor& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.s * b.z,
        .wxz = a.s * b.y,
        .wyz = -a.s * b.x,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Motor::dot(const Vector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Motor& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (-a.i + a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.s * b.z,
        .wxz = a.s * b.y,
        .wyz = -a.s * b.x,
        .xyz = a.s,
        .i = 0.0
    }; }
    constexpr Multivector Motor::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Motor& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.s * b.x + a.xy * b.y + a.xz * b.z),
        .y = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .z = (a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.i * b.z,
        .wxz = -a.i * b.y,
        .wyz = a.i * b.x,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Motor::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Motor& a,const BivectorBulk& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = -a.i * b.yz,
        .wy = a.i * b.xz,
        .wz = -a.i * b.xy,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = 0.0
    }; }
    constexpr Motor Motor::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const Motor& a,const BivectorWeight& b) noexcept { return {
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz
    }; }
    constexpr BivectorWeight Motor::dot(const BivectorWeight& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Motor& a,const PseudoScalar& b) noexcept { return {
        .s = 0.0,
        .wx = -a.yz * b.i,
        .wy = a.xz * b.i,
        .wz = -a.xy * b.i,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.s * b.i
    }; }
    constexpr Motor Motor::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Motor& a,const PointCenter& b) noexcept { return {
        .s = 0.0,
        .w = -a.i,
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = a.s,
        .i = 0.0
    }; }
    constexpr Multivector Motor::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Plane& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.w * b.s - a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = (a.x * b.s - a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz + a.z * b.s),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.i,
        .wxz = a.y * b.i,
        .wyz = -a.x * b.i,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Plane::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const Plane& a,const Plane& b) noexcept { return (a.x * b.x + a.y * b.y + a.z * b.z); }
    constexpr double Plane::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Plane& a,const Bivector& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane Plane::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const Plane& a,const ProjectivePoint& b) noexcept { return {
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = a.z * b.w,
        .xz = -a.y * b.w,
        .yz = a.x * b.w
    }; }
    constexpr Bivector Plane::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Plane& a,const Quaternion& b) noexcept { return {
        .x = (a.x * b.s - a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz + a.z * b.s),
        .w = a.w * b.s
    }; }
    constexpr Plane Plane::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Plane& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = (a.w * b.s - a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane Plane::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Plane& a,const Translator& b) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .w = (a.w - a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane Plane::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const Plane& a,const Vector& b) noexcept { return {
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y)
    }; }
    constexpr BivectorWeight Plane::dot(const Vector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const Plane& a,const Point& b) noexcept { return {
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = a.z,
        .xz = -a.y,
        .yz = a.x
    }; }
    constexpr Bivector Plane::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const Plane& a,const PlaneIdeal& b) noexcept { return (a.x * b.x + a.y * b.y + a.z * b.z); }
    constexpr double Plane::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const Plane& a,const BivectorBulk& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr PlaneIdeal Plane::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Plane& a,const BivectorWeight& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane Plane::dot(const BivectorWeight& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Vector dot(const Plane& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr Vector Plane::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk dot(const Plane& a,const PointCenter& b) noexcept { return {
        .xy = a.z,
        .xz = -a.y,
        .yz = a.x
    }; }
    constexpr BivectorBulk Plane::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Bivector& a,const Motor& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.wx * b.s - a.yz * b.i),
        .wy = (a.wy * b.s + a.xz * b.i),
        .wz = (a.wz * b.s - a.xy * b.i),
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = 0.0
    }; }
    constexpr Motor Bivector::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Bivector& a,const Plane& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane Bivector::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const Bivector& a,const Bivector& b) noexcept { return (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz); }
    constexpr double Bivector::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Bivector& a,const ProjectivePoint& b) noexcept { return {
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr Plane Bivector::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Bivector& a,const Quaternion& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = 0.0
    }; }
    constexpr Motor Bivector::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const Bivector& a,const ProjectiveTranslator& b) noexcept { return {
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s
    }; }
    constexpr Bivector Bivector::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const Bivector& a,const Translator& b) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }
    constexpr Bivector Bivector::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Bivector& a,const Vector& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr Plane Bivector::dot(const Vector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Bivector& a,const Point& b) noexcept { return {
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr Plane Bivector::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Bivector& a,const PlaneIdeal& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane Bivector::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const Bivector& a,const BivectorBulk& b) noexcept { return (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz); }
    constexpr double Bivector::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const Bivector& a,const PseudoScalar& b) noexcept { return {
        .wx = -a.yz * b.i,
        .wy = a.xz * b.i,
        .wz = -a.xy * b.i
    }; }
    constexpr BivectorWeight Bivector::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const Bivector& a,const PointCenter& b) noexcept { return {
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy
    }; }
    constexpr PlaneIdeal Bivector::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const ProjectivePoint& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.w * b.i + a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -a.w * b.yz,
        .y = a.w * b.xz,
        .z = -a.w * b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.s,
        .wxz = a.y * b.s,
        .wyz = -a.x * b.s,
        .xyz = a.w * b.s,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const ProjectivePoint& a,const Plane& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = a.w * b.z,
        .xz = -a.w * b.y,
        .yz = a.w * b.x
    }; }
    constexpr Bivector ProjectivePoint::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const ProjectivePoint& a,const Bivector& b) noexcept { return {
        .x = -a.w * b.yz,
        .y = a.w * b.xz,
        .z = -a.w * b.xy,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    constexpr Plane ProjectivePoint::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const ProjectivePoint& a,const ProjectivePoint& b) noexcept { return -a.w * b.w; }
    constexpr double ProjectivePoint::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const ProjectivePoint& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -a.w * b.yz,
        .y = a.w * b.xz,
        .z = -a.w * b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.s,
        .wxz = a.y * b.s,
        .wyz = -a.x * b.s,
        .xyz = a.w * b.s,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint dot(const ProjectivePoint& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = a.w * b.s
    }; }
    constexpr ProjectivePoint ProjectivePoint::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint dot(const ProjectivePoint& a,const Translator& b) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .w = a.w
    }; }
    constexpr ProjectivePoint ProjectivePoint::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const ProjectivePoint& a,const Point& b) noexcept { return -a.w; }
    constexpr double ProjectivePoint::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const ProjectivePoint& a,const PlaneIdeal& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = a.w * b.z,
        .xz = -a.w * b.y,
        .yz = a.w * b.x
    }; }
    constexpr Bivector ProjectivePoint::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const ProjectivePoint& a,const BivectorBulk& b) noexcept { return {
        .x = -a.w * b.yz,
        .y = a.w * b.xz,
        .z = -a.w * b.xy,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    constexpr Plane ProjectivePoint::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const ProjectivePoint& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.w * b.i
    }; }
    constexpr Plane ProjectivePoint::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const ProjectivePoint& a,const PointCenter& b) noexcept { return -a.w; }
    constexpr double ProjectivePoint::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Quaternion& a,const Motor& b) noexcept { return {
        .s = (a.s * b.s - a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = (a.s * b.wx - a.yz * b.i),
        .wy = (a.s * b.wy + a.xz * b.i),
        .wz = (a.s * b.wz - a.xy * b.i),
        .xy = (a.s * b.xy + a.xy * b.s),
        .xz = (a.s * b.xz + a.xz * b.s),
        .yz = (a.s * b.yz + a.yz * b.s),
        .i = a.s * b.i
    }; }
    constexpr Motor Quaternion::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Quaternion& a,const Plane& b) noexcept { return {
        .x = (a.s * b.x + a.xy * b.y + a.xz * b.z),
        .y = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .z = (a.s * b.z - a.xz * b.x - a.yz * b.y),
        .w = a.s * b.w
    }; }
    constexpr Plane Quaternion::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Quaternion& a,const Bivector& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = 0.0
    }; }
    constexpr Motor Quaternion::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Quaternion& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.s * b.z,
        .wxz = a.s * b.y,
        .wyz = -a.s * b.x,
        .xyz = a.s * b.w,
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Quaternion dot(const Quaternion& a,const Quaternion& b) noexcept { return {
        .s = (a.s * b.s - a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .xy = (a.s * b.xy + a.xy * b.s),
        .xz = (a.s * b.xz + a.xz * b.s),
        .yz = (a.s * b.yz + a.yz * b.s)
    }; }
    constexpr Quaternion Quaternion::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Quaternion& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.s * b.s,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = 0.0
    }; }
    constexpr Motor Quaternion::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Quaternion& a,const Translator& b) noexcept { return {
        .s = a.s,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = 0.0
    }; }
    constexpr Motor Quaternion::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Quaternion& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.s * b.z,
        .wxz = a.s * b.y,
        .wyz = -a.s * b.x,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::dot(const Vector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Quaternion& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.s * b.z,
        .wxz = a.s * b.y,
        .wyz = -a.s * b.x,
        .xyz = a.s,
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const Quaternion& a,const PlaneIdeal& b) noexcept { return {
        .x = (a.s * b.x + a.xy * b.y + a.xz * b.z),
        .y = (a.s * b.y + a.yz * b.z - a.xy * b.x),
        .z = (a.s * b.z - a.xz * b.x - a.yz * b.y)
    }; }
    constexpr PlaneIdeal Quaternion::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Quaternion dot(const Quaternion& a,const BivectorBulk& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz
    }; }
    constexpr Quaternion Quaternion::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const Quaternion& a,const BivectorWeight& b) noexcept { return {
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz
    }; }
    constexpr BivectorWeight Quaternion::dot(const BivectorWeight& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Quaternion& a,const PseudoScalar& b) noexcept { return {
        .s = 0.0,
        .wx = -a.yz * b.i,
        .wy = a.xz * b.i,
        .wz = -a.xy * b.i,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.s * b.i
    }; }
    constexpr Motor Quaternion::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Quaternion& a,const PointCenter& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = a.s,
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const ProjectiveTranslator& a,const Motor& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s),
        .wy = (a.s * b.wy + a.wy * b.s),
        .wz = (a.s * b.wz + a.wz * b.s),
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = a.s * b.i
    }; }
    constexpr Motor ProjectiveTranslator::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const ProjectiveTranslator& a,const Plane& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = (a.s * b.w + a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane ProjectiveTranslator::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const ProjectiveTranslator& a,const Bivector& b) noexcept { return {
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz
    }; }
    constexpr Bivector ProjectiveTranslator::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint dot(const ProjectiveTranslator& a,const ProjectivePoint& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = a.s * b.w
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const ProjectiveTranslator& a,const Quaternion& b) noexcept { return {
        .s = a.s * b.s,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = 0.0
    }; }
    constexpr Motor ProjectiveTranslator::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator dot(const ProjectiveTranslator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s),
        .wy = (a.s * b.wy + a.wy * b.s),
        .wz = (a.s * b.wz + a.wz * b.s)
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator dot(const ProjectiveTranslator& a,const Translator& b) noexcept { return {
        .s = a.s,
        .wx = (a.wx + a.s * b.wx),
        .wy = (a.wy + a.s * b.wy),
        .wz = (a.wz + a.s * b.wz)
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Vector dot(const ProjectiveTranslator& a,const Vector& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z
    }; }
    constexpr Vector ProjectiveTranslator::dot(const Vector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint dot(const ProjectiveTranslator& a,const Point& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = a.s
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const ProjectiveTranslator& a,const PlaneIdeal& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane ProjectiveTranslator::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk dot(const ProjectiveTranslator& a,const BivectorBulk& b) noexcept { return {
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz
    }; }
    constexpr BivectorBulk ProjectiveTranslator::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const ProjectiveTranslator& a,const BivectorWeight& b) noexcept { return {
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz
    }; }
    constexpr BivectorWeight ProjectiveTranslator::dot(const BivectorWeight& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar dot(const ProjectiveTranslator& a,const PseudoScalar& b) noexcept { return {
        .i = a.s * b.i
    }; }
    constexpr PseudoScalar ProjectiveTranslator::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint dot(const ProjectiveTranslator& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.s
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Translator& a,const Motor& b) noexcept { return {
        .s = b.s,
        .wx = (b.wx + a.wx * b.s),
        .wy = (b.wy + a.wy * b.s),
        .wz = (b.wz + a.wz * b.s),
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = b.i
    }; }
    constexpr Motor Translator::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Translator& a,const Plane& b) noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .w = (b.w + a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane Translator::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const Translator& a,const Bivector& b) noexcept { return {
        .wx = b.wx,
        .wy = b.wy,
        .wz = b.wz,
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz
    }; }
    constexpr Bivector Translator::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint dot(const Translator& a,const ProjectivePoint& b) noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .w = b.w
    }; }
    constexpr ProjectivePoint Translator::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const Translator& a,const Quaternion& b) noexcept { return {
        .s = b.s,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = 0.0
    }; }
    constexpr Motor Translator::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator dot(const Translator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = b.s,
        .wx = (b.wx + a.wx * b.s),
        .wy = (b.wy + a.wy * b.s),
        .wz = (b.wz + a.wz * b.s)
    }; }
    constexpr ProjectiveTranslator Translator::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Translator dot(const Translator& a,const Translator& b) noexcept { return {
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz)
    }; }
    constexpr Translator Translator::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Vector dot(const Translator& a,const Vector& b) noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z
    }; }
    constexpr Vector Translator::dot(const Vector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Point dot(const Translator& a,const Point& b) noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z
    }; }
    constexpr Point Translator::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Translator& a,const PlaneIdeal& b) noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane Translator::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk dot(const Translator& a,const BivectorBulk& b) noexcept { return {
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz
    }; }
    constexpr BivectorBulk Translator::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const Translator& a,const BivectorWeight& b) noexcept { return {
        .wx = b.wx,
        .wy = b.wy,
        .wz = b.wz
    }; }
    constexpr BivectorWeight Translator::dot(const BivectorWeight& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar dot(const Translator& a,const PseudoScalar& b) noexcept { return {
        .i = b.i
    }; }
    constexpr PseudoScalar Translator::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PointCenter dot(const Translator& a,const PointCenter& b) noexcept { return {}; }
    constexpr PointCenter Translator::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Vector& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.s,
        .wxz = a.y * b.s,
        .wyz = -a.x * b.s,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const Vector& a,const Plane& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x)
    }; }
    constexpr BivectorWeight Vector::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Vector& a,const Bivector& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    constexpr Plane Vector::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Vector& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.s,
        .wxz = a.y * b.s,
        .wyz = -a.x * b.s,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Vector dot(const Vector& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s
    }; }
    constexpr Vector Vector::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Vector dot(const Vector& a,const Translator& b) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr Vector Vector::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const Vector& a,const PlaneIdeal& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x)
    }; }
    constexpr BivectorWeight Vector::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Vector& a,const BivectorBulk& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    constexpr Plane Vector::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Point& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (b.i + a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.s,
        .wxz = a.y * b.s,
        .wyz = -a.x * b.s,
        .xyz = b.s,
        .i = 0.0
    }; }
    constexpr Multivector Point::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const Point& a,const Plane& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    constexpr Bivector Point::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Point& a,const Bivector& b) noexcept { return {
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    constexpr Plane Point::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const Point& a,const ProjectivePoint& b) noexcept { return -b.w; }
    constexpr double Point::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const Point& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.s,
        .wxz = a.y * b.s,
        .wyz = -a.x * b.s,
        .xyz = b.s,
        .i = 0.0
    }; }
    constexpr Multivector Point::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint dot(const Point& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = b.s
    }; }
    constexpr ProjectivePoint Point::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Point dot(const Point& a,const Translator& b) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    constexpr Point Point::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const Point& a,const Point& b) noexcept { return -1.0; }
    constexpr double Point::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const Point& a,const PlaneIdeal& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    constexpr Bivector Point::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Point& a,const BivectorBulk& b) noexcept { return {
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    constexpr Plane Point::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const Point& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr Plane Point::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const Point& a,const PointCenter& b) noexcept { return -1.0; }
    constexpr double Point::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const PlaneIdeal& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = (a.x * b.s - a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz + a.z * b.s),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.i,
        .wxz = a.y * b.i,
        .wyz = -a.x * b.i,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const PlaneIdeal& a,const Plane& b) noexcept { return (a.x * b.x + a.y * b.y + a.z * b.z); }
    constexpr double PlaneIdeal::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const PlaneIdeal& a,const Bivector& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane PlaneIdeal::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const PlaneIdeal& a,const ProjectivePoint& b) noexcept { return {
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = a.z * b.w,
        .xz = -a.y * b.w,
        .yz = a.x * b.w
    }; }
    constexpr Bivector PlaneIdeal::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const PlaneIdeal& a,const Quaternion& b) noexcept { return {
        .x = (a.x * b.s - a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy + a.y * b.s - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz + a.z * b.s)
    }; }
    constexpr PlaneIdeal PlaneIdeal::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const PlaneIdeal& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane PlaneIdeal::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const PlaneIdeal& a,const Translator& b) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane PlaneIdeal::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const PlaneIdeal& a,const Vector& b) noexcept { return {
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y)
    }; }
    constexpr BivectorWeight PlaneIdeal::dot(const Vector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Bivector dot(const PlaneIdeal& a,const Point& b) noexcept { return {
        .wx = (a.z * b.y - a.y * b.z),
        .wy = (a.x * b.z - a.z * b.x),
        .wz = (a.y * b.x - a.x * b.y),
        .xy = a.z,
        .xz = -a.y,
        .yz = a.x
    }; }
    constexpr Bivector PlaneIdeal::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const PlaneIdeal& a,const PlaneIdeal& b) noexcept { return (a.x * b.x + a.y * b.y + a.z * b.z); }
    constexpr double PlaneIdeal::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const PlaneIdeal& a,const BivectorBulk& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr PlaneIdeal PlaneIdeal::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const PlaneIdeal& a,const BivectorWeight& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane PlaneIdeal::dot(const BivectorWeight& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Vector dot(const PlaneIdeal& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr Vector PlaneIdeal::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk dot(const PlaneIdeal& a,const PointCenter& b) noexcept { return {
        .xy = a.z,
        .xz = -a.y,
        .yz = a.x
    }; }
    constexpr BivectorBulk PlaneIdeal::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const BivectorBulk& a,const Motor& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .wx = -a.yz * b.i,
        .wy = a.xz * b.i,
        .wz = -a.xy * b.i,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = 0.0
    }; }
    constexpr Motor BivectorBulk::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const BivectorBulk& a,const Plane& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr PlaneIdeal BivectorBulk::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const BivectorBulk& a,const Bivector& b) noexcept { return (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz); }
    constexpr double BivectorBulk::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const BivectorBulk& a,const ProjectivePoint& b) noexcept { return {
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr Plane BivectorBulk::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Quaternion dot(const BivectorBulk& a,const Quaternion& b) noexcept { return {
        .s = (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz),
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s
    }; }
    constexpr Quaternion BivectorBulk::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk dot(const BivectorBulk& a,const ProjectiveTranslator& b) noexcept { return {
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s
    }; }
    constexpr BivectorBulk BivectorBulk::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk dot(const BivectorBulk& a,const Translator& b) noexcept { return {
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz
    }; }
    constexpr BivectorBulk BivectorBulk::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const BivectorBulk& a,const Vector& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr Plane BivectorBulk::dot(const Vector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const BivectorBulk& a,const Point& b) noexcept { return {
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr Plane BivectorBulk::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const BivectorBulk& a,const PlaneIdeal& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr PlaneIdeal BivectorBulk::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const BivectorBulk& a,const BivectorBulk& b) noexcept { return (-a.xy * b.xy - a.xz * b.xz - a.yz * b.yz); }
    constexpr double BivectorBulk::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const BivectorBulk& a,const PseudoScalar& b) noexcept { return {
        .wx = -a.yz * b.i,
        .wy = a.xz * b.i,
        .wz = -a.xy * b.i
    }; }
    constexpr BivectorWeight BivectorBulk::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const BivectorBulk& a,const PointCenter& b) noexcept { return {
        .x = -a.yz,
        .y = a.xz,
        .z = -a.xy
    }; }
    constexpr PlaneIdeal BivectorBulk::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& a,const Motor& b) noexcept { return {
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s
    }; }
    constexpr BivectorWeight BivectorWeight::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const BivectorWeight& a,const Plane& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane BivectorWeight::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& a,const Quaternion& b) noexcept { return {
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s
    }; }
    constexpr BivectorWeight BivectorWeight::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& a,const ProjectiveTranslator& b) noexcept { return {
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s
    }; }
    constexpr BivectorWeight BivectorWeight::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& a,const Translator& b) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz
    }; }
    constexpr BivectorWeight BivectorWeight::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const BivectorWeight& a,const PlaneIdeal& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane BivectorWeight::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const PseudoScalar& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .wx = -a.i * b.yz,
        .wy = a.i * b.xz,
        .wz = -a.i * b.xy,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.i * b.s
    }; }
    constexpr Motor PseudoScalar::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Vector dot(const PseudoScalar& a,const Plane& b) noexcept { return {
        .x = -a.i * b.x,
        .y = -a.i * b.y,
        .z = -a.i * b.z
    }; }
    constexpr Vector PseudoScalar::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const PseudoScalar& a,const Bivector& b) noexcept { return {
        .wx = -a.i * b.yz,
        .wy = a.i * b.xz,
        .wz = -a.i * b.xy
    }; }
    constexpr BivectorWeight PseudoScalar::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const PseudoScalar& a,const ProjectivePoint& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.i * b.w
    }; }
    constexpr Plane PseudoScalar::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Motor dot(const PseudoScalar& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .wx = -a.i * b.yz,
        .wy = a.i * b.xz,
        .wz = -a.i * b.xy,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = a.i * b.s
    }; }
    constexpr Motor PseudoScalar::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar dot(const PseudoScalar& a,const ProjectiveTranslator& b) noexcept { return {
        .i = a.i * b.s
    }; }
    constexpr PseudoScalar PseudoScalar::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar dot(const PseudoScalar& a,const Translator& b) noexcept { return {
        .i = a.i
    }; }
    constexpr PseudoScalar PseudoScalar::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const PseudoScalar& a,const Point& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.i
    }; }
    constexpr Plane PseudoScalar::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Vector dot(const PseudoScalar& a,const PlaneIdeal& b) noexcept { return {
        .x = -a.i * b.x,
        .y = -a.i * b.y,
        .z = -a.i * b.z
    }; }
    constexpr Vector PseudoScalar::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight dot(const PseudoScalar& a,const BivectorBulk& b) noexcept { return {
        .wx = -a.i * b.yz,
        .wy = a.i * b.xz,
        .wz = -a.i * b.xy
    }; }
    constexpr BivectorWeight PseudoScalar::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const PseudoScalar& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.i
    }; }
    constexpr Plane PseudoScalar::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const PointCenter& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = b.i,
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = b.s,
        .i = 0.0
    }; }
    constexpr Multivector PointCenter::dot(const Motor& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk dot(const PointCenter& a,const Plane& b) noexcept { return {
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    constexpr BivectorBulk PointCenter::dot(const Plane& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const PointCenter& a,const Bivector& b) noexcept { return {
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy
    }; }
    constexpr PlaneIdeal PointCenter::dot(const Bivector& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const PointCenter& a,const ProjectivePoint& b) noexcept { return -b.w; }
    constexpr double PointCenter::dot(const ProjectivePoint& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Multivector dot(const PointCenter& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = b.s,
        .i = 0.0
    }; }
    constexpr Multivector PointCenter::dot(const Quaternion& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint dot(const PointCenter& a,const ProjectiveTranslator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.s
    }; }
    constexpr ProjectivePoint PointCenter::dot(const ProjectiveTranslator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PointCenter dot(const PointCenter& a,const Translator& b) noexcept { return {}; }
    constexpr PointCenter PointCenter::dot(const Translator& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const PointCenter& a,const Point& b) noexcept { return -1.0; }
    constexpr double PointCenter::dot(const Point& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk dot(const PointCenter& a,const PlaneIdeal& b) noexcept { return {
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    constexpr BivectorBulk PointCenter::dot(const PlaneIdeal& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal dot(const PointCenter& a,const BivectorBulk& b) noexcept { return {
        .x = -b.yz,
        .y = b.xz,
        .z = -b.xy
    }; }
    constexpr PlaneIdeal PointCenter::dot(const BivectorBulk& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr Plane dot(const PointCenter& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr Plane PointCenter::dot(const PseudoScalar& b) const noexcept { return pga3d::dot(*this, b); }

    [[nodiscard]] constexpr double dot(const PointCenter& a,const PointCenter& b) noexcept { return -1.0; }
    constexpr double PointCenter::dot(const PointCenter& b) const noexcept { return pga3d::dot(*this, b); }

}

// opsProject.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

namespace pga3d {
    [[nodiscard]] constexpr Bivector Bivector::projectOntoPlane(const Plane& plane) const noexcept { return -plane.dot(*this).geometric(plane).toBivectorUnsafe(); }
    [[nodiscard]] constexpr Bivector Bivector::projectOntoPlane(const PlaneIdeal& plane) const noexcept { return -plane.dot(*this).geometric(plane).toBivectorUnsafe(); }
    [[nodiscard]] constexpr ProjectivePoint ProjectivePoint::projectOntoPlane(const Plane& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint ProjectivePoint::projectOntoPlane(const PlaneIdeal& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint ProjectivePoint::projectOntoLine(const Bivector& line) const noexcept { return -line.dot(*this).geometric(line).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint Point::projectOntoPlane(const Plane& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint Point::projectOntoPlane(const PlaneIdeal& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint Point::projectOntoLine(const Bivector& line) const noexcept { return -line.dot(*this).geometric(line).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint PointCenter::projectOntoPlane(const Plane& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint PointCenter::projectOntoPlane(const PlaneIdeal& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint PointCenter::projectOntoLine(const Bivector& line) const noexcept { return -line.dot(*this).geometric(line).toProjectivePointUnsafe(); };
}

// opsAntiGeometric.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

namespace pga3d {
    [[nodiscard]] constexpr Multivector antiGeometric(const Multivector& a,const Multivector& b) noexcept { return {
        .s = (a.i * b.s + a.s * b.i + a.wx * b.yz + a.wxz * b.y + a.wz * b.xy + a.x * b.wyz + a.xy * b.wz + a.xyz * b.w + a.yz * b.wx + a.z * b.wxy - a.w * b.xyz - a.wxy * b.z - a.wy * b.xz - a.wyz * b.x - a.xz * b.wy - a.y * b.wxz),
        .w = (a.i * b.w + a.w * b.i + a.wxz * b.wy + a.wy * b.wxz - a.wx * b.wyz - a.wxy * b.wz - a.wyz * b.wx - a.wz * b.wxy),
        .x = (a.i * b.x + a.s * b.wyz + a.w * b.yz + a.wxz * b.xy + a.wz * b.y + a.x * b.i + a.xy * b.wxz + a.z * b.wy - a.wx * b.xyz - a.wxy * b.xz - a.wy * b.z - a.wyz * b.s - a.xyz * b.wx - a.xz * b.wxy - a.y * b.wz - a.yz * b.w),
        .y = (a.i * b.y + a.wx * b.z + a.wxz * b.s + a.wyz * b.xy + a.x * b.wz + a.xy * b.wyz + a.xz * b.w + a.y * b.i - a.s * b.wxz - a.w * b.xz - a.wxy * b.yz - a.wy * b.xyz - a.wz * b.x - a.xyz * b.wy - a.yz * b.wxy - a.z * b.wx),
        .z = (a.i * b.z + a.s * b.wxy + a.w * b.xy + a.wy * b.x + a.wyz * b.xz + a.xz * b.wyz + a.y * b.wx + a.z * b.i - a.wx * b.y - a.wxy * b.s - a.wxz * b.yz - a.wz * b.xyz - a.x * b.wy - a.xy * b.w - a.xyz * b.wz - a.yz * b.wxz),
        .wx = (a.i * b.wx + a.wx * b.i + a.wxy * b.wxz + a.wz * b.wy - a.w * b.wyz - a.wxz * b.wxy - a.wy * b.wz - a.wyz * b.w),
        .wy = (a.i * b.wy + a.w * b.wxz + a.wx * b.wz + a.wxy * b.wyz + a.wxz * b.w + a.wy * b.i - a.wyz * b.wxy - a.wz * b.wx),
        .wz = (a.i * b.wz + a.wxz * b.wyz + a.wy * b.wx + a.wz * b.i - a.w * b.wxy - a.wx * b.wy - a.wxy * b.w - a.wyz * b.wxz),
        .xy = (a.i * b.xy + a.wx * b.xz + a.wxy * b.xyz + a.wxz * b.x + a.wy * b.yz + a.wyz * b.y + a.x * b.wxz + a.xy * b.i + a.y * b.wyz + a.z * b.w - a.s * b.wz - a.w * b.z - a.wz * b.s - a.xyz * b.wxy - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.i * b.xz + a.s * b.wy + a.w * b.y + a.wxz * b.xyz + a.wy * b.s + a.wyz * b.z + a.wz * b.yz + a.xy * b.wx + a.xz * b.i + a.z * b.wyz - a.wx * b.xy - a.wxy * b.x - a.x * b.wxy - a.xyz * b.wxz - a.y * b.w - a.yz * b.wz),
        .yz = (a.i * b.yz + a.wyz * b.xyz + a.x * b.w + a.xy * b.wy + a.xz * b.wz + a.yz * b.i - a.s * b.wx - a.w * b.x - a.wx * b.s - a.wxy * b.y - a.wxz * b.z - a.wy * b.xy - a.wz * b.xz - a.xyz * b.wyz - a.y * b.wxy - a.z * b.wxz),
        .wxy = (a.i * b.wxy + a.w * b.wz + a.wx * b.wxz + a.wxy * b.i + a.wy * b.wyz + a.wz * b.w - a.wxz * b.wx - a.wyz * b.wy),
        .wxz = (a.i * b.wxz + a.wxy * b.wx + a.wxz * b.i + a.wz * b.wyz - a.w * b.wy - a.wx * b.wxy - a.wy * b.w - a.wyz * b.wz),
        .wyz = (a.i * b.wyz + a.w * b.wx + a.wx * b.w + a.wxy * b.wy + a.wxz * b.wz + a.wyz * b.i - a.wy * b.wxy - a.wz * b.wxz),
        .xyz = (a.i * b.xyz + a.w * b.s + a.wx * b.x + a.wxy * b.xy + a.wxz * b.xz + a.wy * b.y + a.wyz * b.yz + a.wz * b.z + a.x * b.wx + a.xyz * b.i + a.y * b.wy + a.z * b.wz - a.s * b.w - a.xy * b.wxy - a.xz * b.wxz - a.yz * b.wyz),
        .i = (a.i * b.i + a.wxy * b.wxy + a.wxz * b.wxz + a.wyz * b.wyz - a.w * b.w - a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Multivector Multivector::antiGeometric(const Multivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Motor& a,const Motor& b) noexcept { return {
        .s = (a.i * b.s + a.s * b.i + a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy),
        .wx = (a.i * b.wx + a.wx * b.i + a.wz * b.wy - a.wy * b.wz),
        .wy = (a.i * b.wy + a.wx * b.wz + a.wy * b.i - a.wz * b.wx),
        .wz = (a.i * b.wz + a.wy * b.wx + a.wz * b.i - a.wx * b.wy),
        .xy = (a.i * b.xy + a.wx * b.xz + a.wy * b.yz + a.xy * b.i - a.s * b.wz - a.wz * b.s - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.i * b.xz + a.s * b.wy + a.wy * b.s + a.wz * b.yz + a.xy * b.wx + a.xz * b.i - a.wx * b.xy - a.yz * b.wz),
        .yz = (a.i * b.yz + a.xy * b.wy + a.xz * b.wz + a.yz * b.i - a.s * b.wx - a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .i = (a.i * b.i - a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Motor& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = a.i * b.w,
        .x = (a.i * b.x + a.wz * b.y - a.wy * b.z - a.yz * b.w),
        .y = (a.i * b.y + a.wx * b.z + a.xz * b.w - a.wz * b.x),
        .z = (a.i * b.z + a.wy * b.x - a.wx * b.y - a.xy * b.w),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wz * b.w,
        .wxz = -a.wy * b.w,
        .wyz = a.wx * b.w,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z - a.s * b.w),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Motor& a,const Bivector& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy),
        .wx = (a.i * b.wx + a.wz * b.wy - a.wy * b.wz),
        .wy = (a.i * b.wy + a.wx * b.wz - a.wz * b.wx),
        .wz = (a.i * b.wz + a.wy * b.wx - a.wx * b.wy),
        .xy = (a.i * b.xy + a.wx * b.xz + a.wy * b.yz - a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.i * b.xz + a.s * b.wy + a.wz * b.yz + a.xy * b.wx - a.wx * b.xy - a.yz * b.wz),
        .yz = (a.i * b.yz + a.xy * b.wy + a.xz * b.wz - a.s * b.wx - a.wy * b.xy - a.wz * b.xz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Motor& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z - a.s * b.x - a.wx * b.w),
        .y = (a.yz * b.z - a.s * b.y - a.wy * b.w - a.xy * b.x),
        .z = (-a.s * b.z - a.wz * b.w - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.i * b.z - a.wy * b.x),
        .wxz = (a.i * b.y + a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.i * b.x - a.wz * b.y),
        .xyz = (a.i * b.w + a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Motor& a,const Quaternion& b) noexcept { return {
        .s = (a.i * b.s + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.i * b.xy + a.wx * b.xz + a.wy * b.yz - a.wz * b.s),
        .xz = (a.i * b.xz + a.wy * b.s + a.wz * b.yz - a.wx * b.xy),
        .yz = (a.i * b.yz - a.wx * b.s - a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion Motor::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Motor& a,const ProjectiveTranslator& b) noexcept { return {
        .s = (a.i * b.s + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .wx = (a.i * b.wx + a.wz * b.wy - a.wy * b.wz),
        .wy = (a.i * b.wy + a.wx * b.wz - a.wz * b.wx),
        .wz = (a.i * b.wz + a.wy * b.wx - a.wx * b.wy),
        .xy = (-a.s * b.wz - a.wz * b.s - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.s * b.wy + a.wy * b.s + a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz - a.s * b.wx - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Motor& a,const Translator& b) noexcept { return {
        .s = (a.i + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .wx = (a.i * b.wx + a.wz * b.wy - a.wy * b.wz),
        .wy = (a.i * b.wy + a.wx * b.wz - a.wz * b.wx),
        .wz = (a.i * b.wz + a.wy * b.wx - a.wx * b.wy),
        .xy = (-a.wz - a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.wy + a.s * b.wy + a.xy * b.wx - a.yz * b.wz),
        .yz = (-a.wx + a.xy * b.wy + a.xz * b.wz - a.s * b.wx),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Motor& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z - a.s * b.x),
        .y = (a.yz * b.z - a.s * b.y - a.xy * b.x),
        .z = (-a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.i * b.z - a.wy * b.x),
        .wxz = (a.i * b.y + a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.i * b.x - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Motor& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (-a.wx + a.xy * b.y + a.xz * b.z - a.s * b.x),
        .y = (-a.wy + a.yz * b.z - a.s * b.y - a.xy * b.x),
        .z = (-a.wz - a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.i * b.z - a.wy * b.x),
        .wxz = (a.i * b.y + a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.i * b.x - a.wz * b.y),
        .xyz = (a.i + a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Motor& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.i * b.x + a.wz * b.y - a.wy * b.z),
        .y = (a.i * b.y + a.wx * b.z - a.wz * b.x),
        .z = (a.i * b.z + a.wy * b.x - a.wx * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Motor& a,const BivectorBulk& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.i * b.xy + a.wx * b.xz + a.wy * b.yz),
        .xz = (a.i * b.xz + a.wz * b.yz - a.wx * b.xy),
        .yz = (a.i * b.yz - a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion Motor::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Motor& a,const BivectorWeight& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .wx = (a.i * b.wx + a.wz * b.wy - a.wy * b.wz),
        .wy = (a.i * b.wy + a.wx * b.wz - a.wz * b.wx),
        .wz = (a.i * b.wz + a.wy * b.wx - a.wx * b.wy),
        .xy = (-a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.s * b.wy + a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz - a.s * b.wx),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Motor& a,const PseudoScalar& b) noexcept { return {
        .s = a.s * b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i,
        .i = a.i * b.i
    }; }
    constexpr Motor Motor::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Motor& a,const PointCenter& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = a.i,
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Plane& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = a.w * b.i,
        .x = (a.w * b.yz + a.x * b.i + a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz + a.y * b.i - a.w * b.xz - a.z * b.wx),
        .z = (a.w * b.xy + a.y * b.wx + a.z * b.i - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.w * b.wz,
        .wxz = -a.w * b.wy,
        .wyz = a.w * b.wx,
        .xyz = (a.w * b.s + a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Plane& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = (a.z * b.w - a.w * b.z),
        .xz = (a.w * b.y - a.y * b.w),
        .yz = (a.x * b.w - a.w * b.x),
        .i = -a.w * b.w
    }; }
    constexpr Motor Plane::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Plane& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.w * b.yz + a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.w * b.xz - a.z * b.wx),
        .z = (a.w * b.xy + a.y * b.wx - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.w * b.wz,
        .wxz = -a.w * b.wy,
        .wyz = a.w * b.wx,
        .xyz = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Plane& a,const ProjectivePoint& b) noexcept { return {
        .s = (-a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z),
        .wx = a.w * b.x,
        .wy = a.w * b.y,
        .wz = a.w * b.z,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y),
        .i = 0.0
    }; }
    constexpr Motor Plane::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Plane& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.w * b.yz,
        .y = -a.w * b.xz,
        .z = a.w * b.xy,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = a.w * b.s,
        .i = 0.0
    }; }
    constexpr Multivector Plane::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Plane& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.w * b.wz,
        .wxz = -a.w * b.wy,
        .wyz = a.w * b.wx,
        .xyz = (a.w * b.s + a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Plane& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.w * b.wz,
        .wxz = -a.w * b.wy,
        .wyz = a.w * b.wx,
        .xyz = (a.w + a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Plane& a,const Vector& b) noexcept { return {
        .s = (-a.x * b.x - a.y * b.y - a.z * b.z),
        .wx = a.w * b.x,
        .wy = a.w * b.y,
        .wz = a.w * b.z,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y),
        .i = 0.0
    }; }
    constexpr Motor Plane::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Plane& a,const Point& b) noexcept { return {
        .s = (-a.w - a.x * b.x - a.y * b.y - a.z * b.z),
        .wx = a.w * b.x,
        .wy = a.w * b.y,
        .wz = a.w * b.z,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y),
        .i = 0.0
    }; }
    constexpr Motor Plane::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const Plane& a,const PlaneIdeal& b) noexcept { return {
        .xy = -a.w * b.z,
        .xz = a.w * b.y,
        .yz = -a.w * b.x
    }; }
    constexpr BivectorBulk Plane::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const Plane& a,const BivectorBulk& b) noexcept { return {
        .x = a.w * b.yz,
        .y = -a.w * b.xz,
        .z = a.w * b.xy
    }; }
    constexpr PlaneIdeal Plane::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Plane& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.w * b.wz,
        .wxz = -a.w * b.wy,
        .wyz = a.w * b.wx,
        .xyz = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Plane antiGeometric(const Plane& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = a.w * b.i
    }; }
    constexpr Plane Plane::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr double antiGeometric(const Plane& a,const PointCenter& b) noexcept { return -a.w; }
    constexpr double Plane::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Bivector& a,const Motor& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy),
        .wx = (a.wx * b.i + a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz + a.wy * b.i - a.wz * b.wx),
        .wz = (a.wy * b.wx + a.wz * b.i - a.wx * b.wy),
        .xy = (a.wx * b.xz + a.wy * b.yz + a.xy * b.i - a.wz * b.s - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.wy * b.s + a.wz * b.yz + a.xy * b.wx + a.xz * b.i - a.wx * b.xy - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz + a.yz * b.i - a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Bivector::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.wz * b.y - a.wy * b.z - a.yz * b.w),
        .y = (a.wx * b.z + a.xz * b.w - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y - a.xy * b.w),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wz * b.w,
        .wxz = -a.wy * b.w,
        .wyz = a.wx * b.w,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .i = 0.0
    }; }
    constexpr Multivector Bivector::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Bivector& a,const Bivector& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy),
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (a.wx * b.xz + a.wy * b.yz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.wz * b.yz + a.xy * b.wx - a.wx * b.xy - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz - a.wy * b.xy - a.wz * b.xz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Bivector::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z - a.wx * b.w),
        .y = (a.yz * b.z - a.wy * b.w - a.xy * b.x),
        .z = (-a.wz * b.w - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Bivector::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Bivector& a,const Quaternion& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.wx * b.xz + a.wy * b.yz - a.wz * b.s),
        .xz = (a.wy * b.s + a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wx * b.s - a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion Bivector::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Bivector& a,const ProjectiveTranslator& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (-a.wz * b.s - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.wy * b.s + a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Bivector::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Bivector& a,const Translator& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (-a.wz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.wy + a.xy * b.wx - a.yz * b.wz),
        .yz = (-a.wx + a.xy * b.wy + a.xz * b.wz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Bivector::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Bivector::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (-a.wx + a.xy * b.y + a.xz * b.z),
        .y = (-a.wy + a.yz * b.z - a.xy * b.x),
        .z = (-a.wz - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Bivector::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .i = 0.0
    }; }
    constexpr Multivector Bivector::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Bivector& a,const BivectorBulk& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.wx * b.xz + a.wy * b.yz),
        .xz = (a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion Bivector::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Bivector& a,const BivectorWeight& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (-a.xz * b.wx - a.yz * b.wy),
        .xz = (a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Bivector::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Bivector antiGeometric(const Bivector& a,const PseudoScalar& b) noexcept { return {
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    constexpr Bivector Bivector::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const Bivector& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr PlaneIdeal Bivector::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (a.x * b.s + a.y * b.xy + a.z * b.xz - a.w * b.wx),
        .y = (a.y * b.s + a.z * b.yz - a.w * b.wy - a.x * b.xy),
        .z = (a.z * b.s - a.w * b.wz - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx - a.z * b.i),
        .wxz = (a.x * b.wz + a.y * b.i - a.z * b.wx),
        .wyz = (a.y * b.wz - a.x * b.i - a.z * b.wy),
        .xyz = (a.w * b.i + a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& a,const Plane& b) noexcept { return {
        .s = (a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z),
        .wx = a.x * b.w,
        .wy = a.y * b.w,
        .wz = a.z * b.w,
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z),
        .i = 0.0
    }; }
    constexpr Motor ProjectivePoint::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (a.y * b.xy + a.z * b.xz - a.w * b.wx),
        .y = (a.z * b.yz - a.w * b.wy - a.x * b.xy),
        .z = (-a.w * b.wz - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = (a.w * b.z - a.z * b.w),
        .xz = (a.y * b.w - a.w * b.y),
        .yz = (a.w * b.x - a.x * b.w),
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor ProjectivePoint::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.x * b.s + a.y * b.xy + a.z * b.xz),
        .y = (a.y * b.s + a.z * b.yz - a.x * b.xy),
        .z = (a.z * b.s - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (a.x * b.s - a.w * b.wx),
        .y = (a.y * b.s - a.w * b.wy),
        .z = (a.z * b.s - a.w * b.wz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (a.x - a.w * b.wx),
        .y = (a.y - a.w * b.wy),
        .z = (a.z - a.w * b.wz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = a.w * b.z,
        .xz = -a.w * b.y,
        .yz = a.w * b.x,
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor ProjectivePoint::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& a,const Point& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = (-a.z + a.w * b.z),
        .xz = (a.y - a.w * b.y),
        .yz = (-a.x + a.w * b.x),
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor ProjectivePoint::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const ProjectivePoint& a,const PlaneIdeal& b) noexcept { return {
        .s = (a.x * b.x + a.y * b.y + a.z * b.z),
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z)
    }; }
    constexpr Quaternion ProjectivePoint::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = -a.w * b.wx,
        .y = -a.w * b.wy,
        .z = -a.w * b.wz,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiGeometric(const ProjectivePoint& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = a.w * b.i
    }; }
    constexpr ProjectivePoint ProjectivePoint::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const ProjectivePoint& a,const PointCenter& b) noexcept { return {
        .xy = -a.z,
        .xz = a.y,
        .yz = -a.x
    }; }
    constexpr BivectorBulk ProjectivePoint::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& a,const Motor& b) noexcept { return {
        .s = (a.s * b.i + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (a.xy * b.i - a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.s * b.wy + a.xy * b.wx + a.xz * b.i - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz + a.yz * b.i - a.s * b.wx)
    }; }
    constexpr Quaternion Quaternion::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = -a.s * b.w,
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& a,const Bivector& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (-a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.s * b.wy + a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz - a.s * b.wx)
    }; }
    constexpr Quaternion Quaternion::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.xy * b.y + a.xz * b.z - a.s * b.x),
        .y = (a.yz * b.z - a.s * b.y - a.xy * b.x),
        .z = (-a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& a,const ProjectiveTranslator& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (-a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.s * b.wy + a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz - a.s * b.wx)
    }; }
    constexpr Quaternion Quaternion::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& a,const Translator& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (-a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.s * b.wy + a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz - a.s * b.wx)
    }; }
    constexpr Quaternion Quaternion::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.xy * b.y + a.xz * b.z - a.s * b.x),
        .y = (a.yz * b.z - a.s * b.y - a.xy * b.x),
        .z = (-a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.xy * b.y + a.xz * b.z - a.s * b.x),
        .y = (a.yz * b.z - a.s * b.y - a.xy * b.x),
        .z = (-a.s * b.z - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& a,const BivectorWeight& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (-a.s * b.wz - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.s * b.wy + a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz - a.s * b.wx)
    }; }
    constexpr Quaternion Quaternion::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& a,const PseudoScalar& b) noexcept { return {
        .s = a.s * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    constexpr Quaternion Quaternion::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& a,const Motor& b) noexcept { return {
        .s = (a.s * b.i + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .wx = (a.wx * b.i + a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz + a.wy * b.i - a.wz * b.wx),
        .wz = (a.wy * b.wx + a.wz * b.i - a.wx * b.wy),
        .xy = (a.wx * b.xz + a.wy * b.yz - a.s * b.wz - a.wz * b.s),
        .xz = (a.s * b.wy + a.wy * b.s + a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.s * b.wx - a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wz * b.w,
        .wxz = -a.wy * b.w,
        .wyz = a.wx * b.w,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z - a.s * b.w),
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& a,const Bivector& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (a.wx * b.xz + a.wy * b.yz - a.s * b.wz),
        .xz = (a.s * b.wy + a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.s * b.wx - a.wy * b.xy - a.wz * b.xz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (-a.s * b.x - a.wx * b.w),
        .y = (-a.s * b.y - a.wy * b.w),
        .z = (-a.s * b.z - a.wz * b.w),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const ProjectiveTranslator& a,const Quaternion& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.wx * b.xz + a.wy * b.yz - a.wz * b.s),
        .xz = (a.wy * b.s + a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wx * b.s - a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion ProjectiveTranslator::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (-a.s * b.wz - a.wz * b.s),
        .xz = (a.s * b.wy + a.wy * b.s),
        .yz = (-a.s * b.wx - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (-a.wz - a.s * b.wz),
        .xz = (a.wy + a.s * b.wy),
        .yz = (-a.wx - a.s * b.wx),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (-a.wx - a.s * b.x),
        .y = (-a.wy - a.s * b.y),
        .z = (-a.wz - a.s * b.z),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const ProjectiveTranslator& a,const BivectorBulk& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.wx * b.xz + a.wy * b.yz),
        .xz = (a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion ProjectiveTranslator::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = -a.s * b.wz,
        .xz = a.s * b.wy,
        .yz = -a.s * b.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const ProjectiveTranslator& a,const PseudoScalar& b) noexcept { return {
        .s = a.s * b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const ProjectiveTranslator& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr PlaneIdeal ProjectiveTranslator::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Translator& a,const Motor& b) noexcept { return {
        .s = (b.i + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .wx = (a.wx * b.i + a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz + a.wy * b.i - a.wz * b.wx),
        .wz = (a.wy * b.wx + a.wz * b.i - a.wx * b.wy),
        .xy = (-b.wz + a.wx * b.xz + a.wy * b.yz - a.wz * b.s),
        .xz = (b.wy + a.wy * b.s + a.wz * b.yz - a.wx * b.xy),
        .yz = (-b.wx - a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Translator& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wz * b.w,
        .wxz = -a.wy * b.w,
        .wyz = a.wx * b.w,
        .xyz = (-b.w + a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .i = 0.0
    }; }
    constexpr Multivector Translator::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Translator& a,const Bivector& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (-b.wz + a.wx * b.xz + a.wy * b.yz),
        .xz = (b.wy + a.wz * b.yz - a.wx * b.xy),
        .yz = (-b.wx - a.wy * b.xy - a.wz * b.xz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Translator& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (-b.x - a.wx * b.w),
        .y = (-b.y - a.wy * b.w),
        .z = (-b.z - a.wz * b.w),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Translator& a,const Quaternion& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.wx * b.xz + a.wy * b.yz - a.wz * b.s),
        .xz = (a.wy * b.s + a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wx * b.s - a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion Translator::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Translator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (-b.wz - a.wz * b.s),
        .xz = (b.wy + a.wy * b.s),
        .yz = (-b.wx - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Translator& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (-a.wz - b.wz),
        .xz = (a.wy + b.wy),
        .yz = (-a.wx - b.wx),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Translator& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = -b.x,
        .y = -b.y,
        .z = -b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Translator& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (-a.wx - b.x),
        .y = (-a.wy - b.y),
        .z = (-a.wz - b.z),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Translator& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .i = 0.0
    }; }
    constexpr Multivector Translator::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Translator& a,const BivectorBulk& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.wx * b.xz + a.wy * b.yz),
        .xz = (a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion Translator::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Translator& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = -b.wz,
        .xz = b.wy,
        .yz = -b.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const Translator& a,const PseudoScalar& b) noexcept { return {
        .s = b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    constexpr ProjectiveTranslator Translator::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const Translator& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr PlaneIdeal Translator::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Vector& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (a.x * b.s + a.y * b.xy + a.z * b.xz),
        .y = (a.y * b.s + a.z * b.yz - a.x * b.xy),
        .z = (a.z * b.s - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx - a.z * b.i),
        .wxz = (a.x * b.wz + a.y * b.i - a.z * b.wx),
        .wyz = (a.y * b.wz - a.x * b.i - a.z * b.wy),
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Vector& a,const Plane& b) noexcept { return {
        .s = (a.x * b.x + a.y * b.y + a.z * b.z),
        .wx = a.x * b.w,
        .wy = a.y * b.w,
        .wz = a.z * b.w,
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z),
        .i = 0.0
    }; }
    constexpr Motor Vector::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Vector& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Vector& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = -a.z * b.w,
        .xz = a.y * b.w,
        .yz = -a.x * b.w,
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor Vector::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Vector& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.x * b.s + a.y * b.xy + a.z * b.xz),
        .y = (a.y * b.s + a.z * b.yz - a.x * b.xy),
        .z = (a.z * b.s - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Vector& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Vector& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Vector& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor Vector::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Vector& a,const Point& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = -a.z,
        .xz = a.y,
        .yz = -a.x,
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor Vector::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Vector& a,const PlaneIdeal& b) noexcept { return {
        .s = (a.x * b.x + a.y * b.y + a.z * b.z),
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z)
    }; }
    constexpr Quaternion Vector::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Vector& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Vector& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Vector antiGeometric(const Vector& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr Vector Vector::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const Vector& a,const PointCenter& b) noexcept { return {
        .xy = -a.z,
        .xz = a.y,
        .yz = -a.x
    }; }
    constexpr BivectorBulk Vector::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Point& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (-b.wx + a.x * b.s + a.y * b.xy + a.z * b.xz),
        .y = (-b.wy + a.y * b.s + a.z * b.yz - a.x * b.xy),
        .z = (-b.wz + a.z * b.s - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx - a.z * b.i),
        .wxz = (a.x * b.wz + a.y * b.i - a.z * b.wx),
        .wyz = (a.y * b.wz - a.x * b.i - a.z * b.wy),
        .xyz = (b.i + a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Point::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Point& a,const Plane& b) noexcept { return {
        .s = (b.w + a.x * b.x + a.y * b.y + a.z * b.z),
        .wx = a.x * b.w,
        .wy = a.y * b.w,
        .wz = a.z * b.w,
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z),
        .i = 0.0
    }; }
    constexpr Motor Point::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Point& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (-b.wx + a.y * b.xy + a.z * b.xz),
        .y = (-b.wy + a.z * b.yz - a.x * b.xy),
        .z = (-b.wz - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Point::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Point& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = (b.z - a.z * b.w),
        .xz = (-b.y + a.y * b.w),
        .yz = (b.x - a.x * b.w),
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor Point::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Point& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.x * b.s + a.y * b.xy + a.z * b.xz),
        .y = (a.y * b.s + a.z * b.yz - a.x * b.xy),
        .z = (a.z * b.s - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Point::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Point& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (-b.wx + a.x * b.s),
        .y = (-b.wy + a.y * b.s),
        .z = (-b.wz + a.z * b.s),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Point::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Point& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (a.x - b.wx),
        .y = (a.y - b.wy),
        .z = (a.z - b.wz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Point::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Point& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x,
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor Point::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const Point& a,const Point& b) noexcept { return {
        .s = 0.0,
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = (b.z - a.z),
        .xz = (a.y - b.y),
        .yz = (b.x - a.x),
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr Motor Point::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const Point& a,const PlaneIdeal& b) noexcept { return {
        .s = (a.x * b.x + a.y * b.y + a.z * b.z),
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z)
    }; }
    constexpr Quaternion Point::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Point& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Point::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const Point& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Point::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiGeometric(const Point& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = b.i
    }; }
    constexpr ProjectivePoint Point::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const Point& a,const PointCenter& b) noexcept { return {
        .xy = -a.z,
        .xz = a.y,
        .yz = -a.x
    }; }
    constexpr BivectorBulk Point::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.x * b.i + a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz + a.y * b.i - a.z * b.wx),
        .z = (a.y * b.wx + a.z * b.i - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const PlaneIdeal& a,const Plane& b) noexcept { return {
        .xy = a.z * b.w,
        .xz = -a.y * b.w,
        .yz = a.x * b.w
    }; }
    constexpr BivectorBulk PlaneIdeal::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const PlaneIdeal& a,const ProjectivePoint& b) noexcept { return {
        .s = (-a.x * b.x - a.y * b.y - a.z * b.z),
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Quaternion PlaneIdeal::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const PlaneIdeal& a,const Vector& b) noexcept { return {
        .s = (-a.x * b.x - a.y * b.y - a.z * b.z),
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Quaternion PlaneIdeal::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const PlaneIdeal& a,const Point& b) noexcept { return {
        .s = (-a.x * b.x - a.y * b.y - a.z * b.z),
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Quaternion PlaneIdeal::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PlaneIdeal& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr PlaneIdeal PlaneIdeal::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& a,const Motor& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (a.xy * b.i - a.xz * b.wx - a.yz * b.wy),
        .xz = (a.xy * b.wx + a.xz * b.i - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz + a.yz * b.i)
    }; }
    constexpr Quaternion BivectorBulk::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const BivectorBulk& a,const Plane& b) noexcept { return {
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w
    }; }
    constexpr PlaneIdeal BivectorBulk::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& a,const Bivector& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (-a.xz * b.wx - a.yz * b.wy),
        .xz = (a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz)
    }; }
    constexpr Quaternion BivectorBulk::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const BivectorBulk& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector BivectorBulk::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& a,const ProjectiveTranslator& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (-a.xz * b.wx - a.yz * b.wy),
        .xz = (a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz)
    }; }
    constexpr Quaternion BivectorBulk::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& a,const Translator& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (-a.xz * b.wx - a.yz * b.wy),
        .xz = (a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz)
    }; }
    constexpr Quaternion BivectorBulk::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const BivectorBulk& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector BivectorBulk::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const BivectorBulk& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector BivectorBulk::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& a,const BivectorWeight& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = (-a.xz * b.wx - a.yz * b.wy),
        .xz = (a.xy * b.wx - a.yz * b.wz),
        .yz = (a.xy * b.wy + a.xz * b.wz)
    }; }
    constexpr Quaternion BivectorBulk::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const BivectorBulk& a,const PseudoScalar& b) noexcept { return {
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    constexpr BivectorBulk BivectorBulk::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& a,const Motor& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .wx = (a.wx * b.i + a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz + a.wy * b.i - a.wz * b.wx),
        .wz = (a.wy * b.wx + a.wz * b.i - a.wx * b.wy),
        .xy = (a.wx * b.xz + a.wy * b.yz - a.wz * b.s),
        .xz = (a.wy * b.s + a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wx * b.s - a.wy * b.xy - a.wz * b.xz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor BivectorWeight::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wz * b.w,
        .wxz = -a.wy * b.w,
        .wyz = a.wx * b.w,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .i = 0.0
    }; }
    constexpr Multivector BivectorWeight::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& a,const Bivector& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = (a.wx * b.xz + a.wy * b.yz),
        .xz = (a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wy * b.xy - a.wz * b.xz),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor BivectorWeight::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector BivectorWeight::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorWeight& a,const Quaternion& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.wx * b.xz + a.wy * b.yz - a.wz * b.s),
        .xz = (a.wy * b.s + a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wx * b.s - a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion BivectorWeight::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = -a.wz * b.s,
        .xz = a.wy * b.s,
        .yz = -a.wx * b.s,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor BivectorWeight::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = -a.wz,
        .xz = a.wy,
        .yz = -a.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor BivectorWeight::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector BivectorWeight::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector BivectorWeight::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .i = 0.0
    }; }
    constexpr Multivector BivectorWeight::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorWeight& a,const BivectorBulk& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = (a.wx * b.xz + a.wy * b.yz),
        .xz = (a.wz * b.yz - a.wx * b.xy),
        .yz = (-a.wy * b.xy - a.wz * b.xz)
    }; }
    constexpr Quaternion BivectorWeight::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = (a.wz * b.wy - a.wy * b.wz),
        .wy = (a.wx * b.wz - a.wz * b.wx),
        .wz = (a.wy * b.wx - a.wx * b.wy),
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor BivectorWeight::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight antiGeometric(const BivectorWeight& a,const PseudoScalar& b) noexcept { return {
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    constexpr BivectorWeight BivectorWeight::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const BivectorWeight& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr PlaneIdeal BivectorWeight::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Motor antiGeometric(const PseudoScalar& a,const Motor& b) noexcept { return {
        .s = a.i * b.s,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz,
        .i = a.i * b.i
    }; }
    constexpr Motor PseudoScalar::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Plane antiGeometric(const PseudoScalar& a,const Plane& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i * b.w
    }; }
    constexpr Plane PseudoScalar::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Bivector antiGeometric(const PseudoScalar& a,const Bivector& b) noexcept { return {
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    constexpr Bivector PseudoScalar::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PseudoScalar& a,const ProjectivePoint& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i * b.w
    }; }
    constexpr ProjectivePoint PseudoScalar::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Quaternion antiGeometric(const PseudoScalar& a,const Quaternion& b) noexcept { return {
        .s = a.i * b.s,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    constexpr Quaternion PseudoScalar::antiGeometric(const Quaternion& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const PseudoScalar& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.i * b.s,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    constexpr ProjectiveTranslator PseudoScalar::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const PseudoScalar& a,const Translator& b) noexcept { return {
        .s = a.i,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    constexpr ProjectiveTranslator PseudoScalar::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Vector antiGeometric(const PseudoScalar& a,const Vector& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z
    }; }
    constexpr Vector PseudoScalar::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PseudoScalar& a,const Point& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i
    }; }
    constexpr ProjectivePoint PseudoScalar::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PseudoScalar& a,const PlaneIdeal& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z
    }; }
    constexpr PlaneIdeal PseudoScalar::antiGeometric(const PlaneIdeal& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const PseudoScalar& a,const BivectorBulk& b) noexcept { return {
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    constexpr BivectorBulk PseudoScalar::antiGeometric(const BivectorBulk& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorWeight antiGeometric(const PseudoScalar& a,const BivectorWeight& b) noexcept { return {
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    constexpr BivectorWeight PseudoScalar::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiGeometric(const PseudoScalar& a,const PseudoScalar& b) noexcept { return {
        .i = a.i * b.i
    }; }
    constexpr PseudoScalar PseudoScalar::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PseudoScalar& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.i
    }; }
    constexpr ProjectivePoint PseudoScalar::antiGeometric(const PointCenter& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr Multivector antiGeometric(const PointCenter& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = b.i,
        .i = 0.0
    }; }
    constexpr Multivector PointCenter::antiGeometric(const Motor& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr double antiGeometric(const PointCenter& a,const Plane& b) noexcept { return b.w; }
    constexpr double PointCenter::antiGeometric(const Plane& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& a,const Bivector& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz
    }; }
    constexpr PlaneIdeal PointCenter::antiGeometric(const Bivector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const PointCenter& a,const ProjectivePoint& b) noexcept { return {
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    constexpr BivectorBulk PointCenter::antiGeometric(const ProjectivePoint& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& a,const ProjectiveTranslator& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz
    }; }
    constexpr PlaneIdeal PointCenter::antiGeometric(const ProjectiveTranslator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& a,const Translator& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz
    }; }
    constexpr PlaneIdeal PointCenter::antiGeometric(const Translator& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const PointCenter& a,const Vector& b) noexcept { return {
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    constexpr BivectorBulk PointCenter::antiGeometric(const Vector& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiGeometric(const PointCenter& a,const Point& b) noexcept { return {
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    constexpr BivectorBulk PointCenter::antiGeometric(const Point& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& a,const BivectorWeight& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz
    }; }
    constexpr PlaneIdeal PointCenter::antiGeometric(const BivectorWeight& b) const noexcept { return pga3d::antiGeometric(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PointCenter& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr ProjectivePoint PointCenter::antiGeometric(const PseudoScalar& b) const noexcept { return pga3d::antiGeometric(*this, b); }

}

// opsAntiDot.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

namespace pga3d {
    [[nodiscard]] constexpr Multivector antiDot(const Multivector& a,const Multivector& b) noexcept { return {
        .s = (a.i * b.s + a.s * b.i),
        .w = (a.i * b.w + a.w * b.i),
        .x = (a.i * b.x + a.s * b.wyz + a.x * b.i - a.wyz * b.s),
        .y = (a.i * b.y + a.wxz * b.s + a.y * b.i - a.s * b.wxz),
        .z = (a.i * b.z + a.s * b.wxy + a.z * b.i - a.wxy * b.s),
        .wx = (a.i * b.wx + a.wx * b.i - a.w * b.wyz - a.wyz * b.w),
        .wy = (a.i * b.wy + a.w * b.wxz + a.wxz * b.w + a.wy * b.i),
        .wz = (a.i * b.wz + a.wz * b.i - a.w * b.wxy - a.wxy * b.w),
        .xy = (a.i * b.xy + a.wxz * b.x + a.wyz * b.y + a.x * b.wxz + a.xy * b.i + a.y * b.wyz - a.s * b.wz - a.wz * b.s),
        .xz = (a.i * b.xz + a.s * b.wy + a.wy * b.s + a.wyz * b.z + a.xz * b.i + a.z * b.wyz - a.wxy * b.x - a.x * b.wxy),
        .yz = (a.i * b.yz + a.yz * b.i - a.s * b.wx - a.wx * b.s - a.wxy * b.y - a.wxz * b.z - a.y * b.wxy - a.z * b.wxz),
        .wxy = (a.i * b.wxy + a.w * b.wz + a.wx * b.wxz + a.wxy * b.i + a.wy * b.wyz + a.wz * b.w - a.wxz * b.wx - a.wyz * b.wy),
        .wxz = (a.i * b.wxz + a.wxy * b.wx + a.wxz * b.i + a.wz * b.wyz - a.w * b.wy - a.wx * b.wxy - a.wy * b.w - a.wyz * b.wz),
        .wyz = (a.i * b.wyz + a.w * b.wx + a.wx * b.w + a.wxy * b.wy + a.wxz * b.wz + a.wyz * b.i - a.wy * b.wxy - a.wz * b.wxz),
        .xyz = (a.i * b.xyz + a.w * b.s + a.wx * b.x + a.wxy * b.xy + a.wxz * b.xz + a.wy * b.y + a.wyz * b.yz + a.wz * b.z + a.x * b.wx + a.xyz * b.i + a.y * b.wy + a.z * b.wz - a.s * b.w - a.xy * b.wxy - a.xz * b.wxz - a.yz * b.wyz),
        .i = (a.i * b.i + a.wxy * b.wxy + a.wxz * b.wxz + a.wyz * b.wyz - a.w * b.w - a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Multivector Multivector::antiDot(const Multivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Motor& a,const Motor& b) noexcept { return {
        .s = (a.i * b.s + a.s * b.i),
        .wx = (a.i * b.wx + a.wx * b.i),
        .wy = (a.i * b.wy + a.wy * b.i),
        .wz = (a.i * b.wz + a.wz * b.i),
        .xy = (a.i * b.xy + a.xy * b.i - a.s * b.wz - a.wz * b.s),
        .xz = (a.i * b.xz + a.s * b.wy + a.wy * b.s + a.xz * b.i),
        .yz = (a.i * b.yz + a.yz * b.i - a.s * b.wx - a.wx * b.s),
        .i = (a.i * b.i - a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Motor& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = a.i * b.w,
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wz * b.w,
        .wxz = -a.wy * b.w,
        .wyz = a.wx * b.w,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z - a.s * b.w),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Motor& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = (a.i * b.xy - a.s * b.wz),
        .xz = (a.i * b.xz + a.s * b.wy),
        .yz = (a.i * b.yz - a.s * b.wx),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Motor& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.i * b.z - a.wy * b.x),
        .wxz = (a.i * b.y + a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.i * b.x - a.wz * b.y),
        .xyz = (a.i * b.w + a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Quaternion antiDot(const Motor& a,const Quaternion& b) noexcept { return {
        .s = a.i * b.s,
        .xy = (a.i * b.xy - a.wz * b.s),
        .xz = (a.i * b.xz + a.wy * b.s),
        .yz = (a.i * b.yz - a.wx * b.s)
    }; }
    constexpr Quaternion Motor::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Motor& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.i * b.s,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = (-a.s * b.wz - a.wz * b.s),
        .xz = (a.s * b.wy + a.wy * b.s),
        .yz = (-a.s * b.wx - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Motor& a,const Translator& b) noexcept { return {
        .s = a.i,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = (-a.wz - a.s * b.wz),
        .xz = (a.wy + a.s * b.wy),
        .yz = (-a.wx - a.s * b.wx),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Motor& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.i * b.z - a.wy * b.x),
        .wxz = (a.i * b.y + a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.i * b.x - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Motor& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.i * b.z - a.wy * b.x),
        .wxz = (a.i * b.y + a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.i * b.x - a.wz * b.y),
        .xyz = (a.i + a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Motor& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiDot(const PlaneIdeal& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const Motor& a,const BivectorBulk& b) noexcept { return {
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    constexpr BivectorBulk Motor::antiDot(const BivectorBulk& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Motor& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = -a.s * b.wz,
        .xz = a.s * b.wy,
        .yz = -a.s * b.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Motor::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Motor& a,const PseudoScalar& b) noexcept { return {
        .s = a.s * b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i,
        .i = a.i * b.i
    }; }
    constexpr Motor Motor::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Motor& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.i
    }; }
    constexpr ProjectivePoint Motor::antiDot(const PointCenter& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Plane& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = a.w * b.i,
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.w * b.wz,
        .wxz = -a.w * b.wy,
        .wyz = a.w * b.wx,
        .xyz = (a.w * b.s + a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector Plane::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const Plane& a,const Plane& b) noexcept { return {
        .i = -a.w * b.w
    }; }
    constexpr PseudoScalar Plane::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& a,const Bivector& b) noexcept { return {
        .x = -a.w * b.wx,
        .y = -a.w * b.wy,
        .z = -a.w * b.wz,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    constexpr ProjectivePoint Plane::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Bivector antiDot(const Plane& a,const ProjectivePoint& b) noexcept { return {
        .wx = a.w * b.x,
        .wy = a.w * b.y,
        .wz = a.w * b.z,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Bivector Plane::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& a,const Quaternion& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.w * b.s
    }; }
    constexpr ProjectivePoint Plane::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& a,const ProjectiveTranslator& b) noexcept { return {
        .x = -a.w * b.wx,
        .y = -a.w * b.wy,
        .z = -a.w * b.wz,
        .w = (a.w * b.s + a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    constexpr ProjectivePoint Plane::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& a,const Translator& b) noexcept { return {
        .x = -a.w * b.wx,
        .y = -a.w * b.wy,
        .z = -a.w * b.wz,
        .w = (a.w + a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    constexpr ProjectivePoint Plane::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Bivector antiDot(const Plane& a,const Vector& b) noexcept { return {
        .wx = a.w * b.x,
        .wy = a.w * b.y,
        .wz = a.w * b.z,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Bivector Plane::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Bivector antiDot(const Plane& a,const Point& b) noexcept { return {
        .wx = a.w * b.x,
        .wy = a.w * b.y,
        .wz = a.w * b.z,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Bivector Plane::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& a,const BivectorWeight& b) noexcept { return {
        .x = -a.w * b.wx,
        .y = -a.w * b.wy,
        .z = -a.w * b.wz,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    constexpr ProjectivePoint Plane::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Plane antiDot(const Plane& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = a.w * b.i
    }; }
    constexpr Plane Plane::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Bivector& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = (a.xy * b.i - a.wz * b.s),
        .xz = (a.wy * b.s + a.xz * b.i),
        .yz = (a.yz * b.i - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Bivector::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& a,const Plane& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const Bivector& a,const Bivector& b) noexcept { return {
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr PseudoScalar Bivector::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& a,const ProjectivePoint& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const Bivector& a,const Quaternion& b) noexcept { return {
        .xy = -a.wz * b.s,
        .xz = a.wy * b.s,
        .yz = -a.wx * b.s
    }; }
    constexpr BivectorBulk Bivector::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Bivector& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -a.wz * b.s,
        .xz = a.wy * b.s,
        .yz = -a.wx * b.s,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Bivector::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Bivector& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -a.wz,
        .xz = a.wy,
        .yz = -a.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Bivector::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& a,const Vector& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& a,const Point& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& a,const PlaneIdeal& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const PlaneIdeal& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const Bivector& a,const BivectorWeight& b) noexcept { return {
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr PseudoScalar Bivector::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Bivector antiDot(const Bivector& a,const PseudoScalar& b) noexcept { return {
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    constexpr Bivector Bivector::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx - a.z * b.i),
        .wxz = (a.x * b.wz + a.y * b.i - a.z * b.wx),
        .wyz = (a.y * b.wz - a.x * b.i - a.z * b.wy),
        .xyz = (a.w * b.i + a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Bivector antiDot(const ProjectivePoint& a,const Plane& b) noexcept { return {
        .wx = a.x * b.w,
        .wy = a.y * b.w,
        .wz = a.z * b.w,
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z)
    }; }
    constexpr Bivector ProjectivePoint::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectivePoint& a,const Bivector& b) noexcept { return {
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .w = (a.y * b.xz - a.x * b.yz - a.z * b.xy)
    }; }
    constexpr ProjectivePoint ProjectivePoint::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const ProjectivePoint& a,const ProjectivePoint& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar ProjectivePoint::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const ProjectivePoint& a,const Vector& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar ProjectivePoint::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const ProjectivePoint& a,const Point& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar ProjectivePoint::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const ProjectivePoint& a,const PlaneIdeal& b) noexcept { return {
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z)
    }; }
    constexpr BivectorBulk ProjectivePoint::antiDot(const PlaneIdeal& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectivePoint& a,const BivectorBulk& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.y * b.xz - a.x * b.yz - a.z * b.xy)
    }; }
    constexpr ProjectivePoint ProjectivePoint::antiDot(const BivectorBulk& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Vector antiDot(const ProjectivePoint& a,const BivectorWeight& b) noexcept { return {
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy)
    }; }
    constexpr Vector ProjectivePoint::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectivePoint& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = a.w * b.i
    }; }
    constexpr ProjectivePoint ProjectivePoint::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Quaternion antiDot(const Quaternion& a,const Motor& b) noexcept { return {
        .s = a.s * b.i,
        .xy = (a.xy * b.i - a.s * b.wz),
        .xz = (a.s * b.wy + a.xz * b.i),
        .yz = (a.yz * b.i - a.s * b.wx)
    }; }
    constexpr Quaternion Quaternion::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Quaternion& a,const Plane& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.s * b.w
    }; }
    constexpr ProjectivePoint Quaternion::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& a,const Bivector& b) noexcept { return {
        .xy = -a.s * b.wz,
        .xz = a.s * b.wy,
        .yz = -a.s * b.wx
    }; }
    constexpr BivectorBulk Quaternion::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Quaternion& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& a,const ProjectiveTranslator& b) noexcept { return {
        .xy = -a.s * b.wz,
        .xz = a.s * b.wy,
        .yz = -a.s * b.wx
    }; }
    constexpr BivectorBulk Quaternion::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& a,const Translator& b) noexcept { return {
        .xy = -a.s * b.wz,
        .xz = a.s * b.wy,
        .yz = -a.s * b.wx
    }; }
    constexpr BivectorBulk Quaternion::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Quaternion& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Quaternion& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& a,const BivectorWeight& b) noexcept { return {
        .xy = -a.s * b.wz,
        .xz = a.s * b.wy,
        .yz = -a.s * b.wx
    }; }
    constexpr BivectorBulk Quaternion::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Quaternion antiDot(const Quaternion& a,const PseudoScalar& b) noexcept { return {
        .s = a.s * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    constexpr Quaternion Quaternion::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& a,const Motor& b) noexcept { return {
        .s = a.s * b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = (-a.s * b.wz - a.wz * b.s),
        .xz = (a.s * b.wy + a.wy * b.s),
        .yz = (-a.s * b.wx - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectiveTranslator& a,const Plane& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z - a.s * b.w)
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -a.s * b.wz,
        .xz = a.s * b.wy,
        .yz = -a.s * b.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const ProjectiveTranslator& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const ProjectiveTranslator& a,const Quaternion& b) noexcept { return {
        .xy = -a.wz * b.s,
        .xz = a.wy * b.s,
        .yz = -a.wx * b.s
    }; }
    constexpr BivectorBulk ProjectiveTranslator::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = (-a.s * b.wz - a.wz * b.s),
        .xz = (a.s * b.wy + a.wy * b.s),
        .yz = (-a.s * b.wx - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = (-a.wz - a.s * b.wz),
        .xz = (a.wy + a.s * b.wy),
        .yz = (-a.wx - a.s * b.wx),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const ProjectiveTranslator& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const ProjectiveTranslator& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.s * b.x,
        .y = -a.s * b.y,
        .z = -a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectiveTranslator& a,const PlaneIdeal& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::antiDot(const PlaneIdeal& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -a.s * b.wz,
        .xz = a.s * b.wy,
        .yz = -a.s * b.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiDot(const ProjectiveTranslator& a,const PseudoScalar& b) noexcept { return {
        .s = a.s * b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Translator& a,const Motor& b) noexcept { return {
        .s = b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = (-b.wz - a.wz * b.s),
        .xz = (b.wy + a.wy * b.s),
        .yz = (-b.wx - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Translator& a,const Plane& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w,
        .w = (-b.w + a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr ProjectivePoint Translator::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Translator& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -b.wz,
        .xz = b.wy,
        .yz = -b.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Translator& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x,
        .y = -b.y,
        .z = -b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const Translator& a,const Quaternion& b) noexcept { return {
        .xy = -a.wz * b.s,
        .xz = a.wy * b.s,
        .yz = -a.wx * b.s
    }; }
    constexpr BivectorBulk Translator::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Translator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = (-b.wz - a.wz * b.s),
        .xz = (b.wy + a.wy * b.s),
        .yz = (-b.wx - a.wx * b.s),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Translator& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = (-a.wz - b.wz),
        .xz = (a.wy + b.wy),
        .yz = (-a.wx - b.wx),
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Translator& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x,
        .y = -b.y,
        .z = -b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Translator& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x,
        .y = -b.y,
        .z = -b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Translator& a,const PlaneIdeal& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr ProjectivePoint Translator::antiDot(const PlaneIdeal& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const Translator& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -b.wz,
        .xz = b.wy,
        .yz = -b.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor Translator::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiDot(const Translator& a,const PseudoScalar& b) noexcept { return {
        .s = b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    constexpr ProjectiveTranslator Translator::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Vector& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx - a.z * b.i),
        .wxz = (a.x * b.wz + a.y * b.i - a.z * b.wx),
        .wyz = (a.y * b.wz - a.x * b.i - a.z * b.wy),
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Bivector antiDot(const Vector& a,const Plane& b) noexcept { return {
        .wx = a.x * b.w,
        .wy = a.y * b.w,
        .wz = a.z * b.w,
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z)
    }; }
    constexpr Bivector Vector::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Vector& a,const Bivector& b) noexcept { return {
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .w = (a.y * b.xz - a.x * b.yz - a.z * b.xy)
    }; }
    constexpr ProjectivePoint Vector::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const Vector& a,const ProjectivePoint& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar Vector::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Vector& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Vector& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Vector& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const Vector& a,const Vector& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar Vector::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const Vector& a,const Point& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar Vector::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const Vector& a,const PlaneIdeal& b) noexcept { return {
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z)
    }; }
    constexpr BivectorBulk Vector::antiDot(const PlaneIdeal& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Vector& a,const BivectorBulk& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.y * b.xz - a.x * b.yz - a.z * b.xy)
    }; }
    constexpr ProjectivePoint Vector::antiDot(const BivectorBulk& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Vector antiDot(const Vector& a,const BivectorWeight& b) noexcept { return {
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy)
    }; }
    constexpr Vector Vector::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Vector antiDot(const Vector& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr Vector Vector::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Point& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx - a.z * b.i),
        .wxz = (a.x * b.wz + a.y * b.i - a.z * b.wx),
        .wyz = (a.y * b.wz - a.x * b.i - a.z * b.wy),
        .xyz = (b.i + a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Point::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Bivector antiDot(const Point& a,const Plane& b) noexcept { return {
        .wx = a.x * b.w,
        .wy = a.y * b.w,
        .wz = a.z * b.w,
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z)
    }; }
    constexpr Bivector Point::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Point& a,const Bivector& b) noexcept { return {
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy),
        .w = (a.y * b.xz - a.x * b.yz - a.z * b.xy)
    }; }
    constexpr ProjectivePoint Point::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const Point& a,const ProjectivePoint& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar Point::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Point& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.y * b.xz - a.x * b.yz - a.z * b.xy),
        .i = 0.0
    }; }
    constexpr Multivector Point::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Point& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Point::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const Point& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.x * b.wy - a.y * b.wx),
        .wxz = (a.x * b.wz - a.z * b.wx),
        .wyz = (a.y * b.wz - a.z * b.wy),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Point::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const Point& a,const Vector& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar Point::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const Point& a,const Point& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar Point::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const Point& a,const PlaneIdeal& b) noexcept { return {
        .xy = (a.y * b.x - a.x * b.y),
        .xz = (a.z * b.x - a.x * b.z),
        .yz = (a.z * b.y - a.y * b.z)
    }; }
    constexpr BivectorBulk Point::antiDot(const PlaneIdeal& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Point& a,const BivectorBulk& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.y * b.xz - a.x * b.yz - a.z * b.xy)
    }; }
    constexpr ProjectivePoint Point::antiDot(const BivectorBulk& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Vector antiDot(const Point& a,const BivectorWeight& b) noexcept { return {
        .x = (a.z * b.wy - a.y * b.wz),
        .y = (a.x * b.wz - a.z * b.wx),
        .z = (a.y * b.wx - a.x * b.wy)
    }; }
    constexpr Vector Point::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const Point& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = b.i
    }; }
    constexpr ProjectivePoint Point::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Multivector antiDot(const PlaneIdeal& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& a,const Bivector& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const PlaneIdeal& a,const ProjectivePoint& b) noexcept { return {
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr BivectorBulk PlaneIdeal::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& a,const ProjectiveTranslator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& a,const Translator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const PlaneIdeal& a,const Vector& b) noexcept { return {
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr BivectorBulk PlaneIdeal::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const PlaneIdeal& a,const Point& b) noexcept { return {
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr BivectorBulk PlaneIdeal::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& a,const BivectorWeight& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiDot(const PlaneIdeal& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr PlaneIdeal PlaneIdeal::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const BivectorBulk& a,const Motor& b) noexcept { return {
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    constexpr BivectorBulk BivectorBulk::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorBulk& a,const ProjectivePoint& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr ProjectivePoint BivectorBulk::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorBulk& a,const Vector& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr ProjectivePoint BivectorBulk::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorBulk& a,const Point& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    constexpr ProjectivePoint BivectorBulk::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const BivectorBulk& a,const PseudoScalar& b) noexcept { return {
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    constexpr BivectorBulk BivectorBulk::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const BivectorWeight& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = -a.wz * b.s,
        .xz = a.wy * b.s,
        .yz = -a.wx * b.s,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor BivectorWeight::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorWeight& a,const Plane& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr ProjectivePoint BivectorWeight::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const BivectorWeight& a,const Bivector& b) noexcept { return {
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr PseudoScalar BivectorWeight::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Vector antiDot(const BivectorWeight& a,const ProjectivePoint& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y)
    }; }
    constexpr Vector BivectorWeight::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const BivectorWeight& a,const Quaternion& b) noexcept { return {
        .xy = -a.wz * b.s,
        .xz = a.wy * b.s,
        .yz = -a.wx * b.s
    }; }
    constexpr BivectorBulk BivectorWeight::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const BivectorWeight& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -a.wz * b.s,
        .xz = a.wy * b.s,
        .yz = -a.wx * b.s,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor BivectorWeight::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const BivectorWeight& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -a.wz,
        .xz = a.wy,
        .yz = -a.wx,
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr Motor BivectorWeight::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Vector antiDot(const BivectorWeight& a,const Vector& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y)
    }; }
    constexpr Vector BivectorWeight::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Vector antiDot(const BivectorWeight& a,const Point& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y)
    }; }
    constexpr Vector BivectorWeight::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorWeight& a,const PlaneIdeal& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr ProjectivePoint BivectorWeight::antiDot(const PlaneIdeal& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const BivectorWeight& a,const BivectorWeight& b) noexcept { return {
        .i = (-a.wx * b.wx - a.wy * b.wy - a.wz * b.wz)
    }; }
    constexpr PseudoScalar BivectorWeight::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight antiDot(const BivectorWeight& a,const PseudoScalar& b) noexcept { return {
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    constexpr BivectorWeight BivectorWeight::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Motor antiDot(const PseudoScalar& a,const Motor& b) noexcept { return {
        .s = a.i * b.s,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz,
        .i = a.i * b.i
    }; }
    constexpr Motor PseudoScalar::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Plane antiDot(const PseudoScalar& a,const Plane& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i * b.w
    }; }
    constexpr Plane PseudoScalar::antiDot(const Plane& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Bivector antiDot(const PseudoScalar& a,const Bivector& b) noexcept { return {
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    constexpr Bivector PseudoScalar::antiDot(const Bivector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const PseudoScalar& a,const ProjectivePoint& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i * b.w
    }; }
    constexpr ProjectivePoint PseudoScalar::antiDot(const ProjectivePoint& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Quaternion antiDot(const PseudoScalar& a,const Quaternion& b) noexcept { return {
        .s = a.i * b.s,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    constexpr Quaternion PseudoScalar::antiDot(const Quaternion& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiDot(const PseudoScalar& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.i * b.s,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    constexpr ProjectiveTranslator PseudoScalar::antiDot(const ProjectiveTranslator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiDot(const PseudoScalar& a,const Translator& b) noexcept { return {
        .s = a.i,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    constexpr ProjectiveTranslator PseudoScalar::antiDot(const Translator& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr Vector antiDot(const PseudoScalar& a,const Vector& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z
    }; }
    constexpr Vector PseudoScalar::antiDot(const Vector& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const PseudoScalar& a,const Point& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i
    }; }
    constexpr ProjectivePoint PseudoScalar::antiDot(const Point& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiDot(const PseudoScalar& a,const PlaneIdeal& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z
    }; }
    constexpr PlaneIdeal PseudoScalar::antiDot(const PlaneIdeal& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiDot(const PseudoScalar& a,const BivectorBulk& b) noexcept { return {
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    constexpr BivectorBulk PseudoScalar::antiDot(const BivectorBulk& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr BivectorWeight antiDot(const PseudoScalar& a,const BivectorWeight& b) noexcept { return {
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    constexpr BivectorWeight PseudoScalar::antiDot(const BivectorWeight& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiDot(const PseudoScalar& a,const PseudoScalar& b) noexcept { return {
        .i = a.i * b.i
    }; }
    constexpr PseudoScalar PseudoScalar::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const PseudoScalar& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.i
    }; }
    constexpr ProjectivePoint PseudoScalar::antiDot(const PointCenter& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const PointCenter& a,const Motor& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr ProjectivePoint PointCenter::antiDot(const Motor& b) const noexcept { return pga3d::antiDot(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiDot(const PointCenter& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr ProjectivePoint PointCenter::antiDot(const PseudoScalar& b) const noexcept { return pga3d::antiDot(*this, b); }

}

// opsWedge.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

namespace pga3d {
    [[nodiscard]] constexpr Multivector wedge(const Multivector& a,const Multivector& b) noexcept { return {
        .s = a.s * b.s,
        .w = (a.s * b.w + a.w * b.s),
        .x = (a.s * b.x + a.x * b.s),
        .y = (a.s * b.y + a.y * b.s),
        .z = (a.s * b.z + a.z * b.s),
        .wx = (a.s * b.wx + a.w * b.x + a.wx * b.s - a.x * b.w),
        .wy = (a.s * b.wy + a.w * b.y + a.wy * b.s - a.y * b.w),
        .wz = (a.s * b.wz + a.w * b.z + a.wz * b.s - a.z * b.w),
        .xy = (a.s * b.xy + a.x * b.y + a.xy * b.s - a.y * b.x),
        .xz = (a.s * b.xz + a.x * b.z + a.xz * b.s - a.z * b.x),
        .yz = (a.s * b.yz + a.y * b.z + a.yz * b.s - a.z * b.y),
        .wxy = (a.s * b.wxy + a.w * b.xy + a.wx * b.y + a.wxy * b.s + a.xy * b.w + a.y * b.wx - a.wy * b.x - a.x * b.wy),
        .wxz = (a.s * b.wxz + a.w * b.xz + a.wx * b.z + a.wxz * b.s + a.xz * b.w + a.z * b.wx - a.wz * b.x - a.x * b.wz),
        .wyz = (a.s * b.wyz + a.w * b.yz + a.wy * b.z + a.wyz * b.s + a.yz * b.w + a.z * b.wy - a.wz * b.y - a.y * b.wz),
        .xyz = (a.s * b.xyz + a.x * b.yz + a.xy * b.z + a.xyz * b.s + a.yz * b.x + a.z * b.xy - a.xz * b.y - a.y * b.xz),
        .i = (a.i * b.s + a.s * b.i + a.w * b.xyz + a.wx * b.yz + a.wxy * b.z + a.wyz * b.x + a.wz * b.xy + a.xy * b.wz + a.y * b.wxz + a.yz * b.wx - a.wxz * b.y - a.wy * b.xz - a.x * b.wyz - a.xyz * b.w - a.xz * b.wy - a.z * b.wxy)
    }; }
    [[nodiscard]] constexpr Multivector meet(const Multivector& a,const Multivector& b) noexcept { return wedge(a, b); }
    constexpr Multivector Multivector::wedge(const Multivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Multivector::meet(const Multivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Motor& a,const Motor& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s),
        .wy = (a.s * b.wy + a.wy * b.s),
        .wz = (a.s * b.wz + a.wz * b.s),
        .xy = (a.s * b.xy + a.xy * b.s),
        .xz = (a.s * b.xz + a.xz * b.s),
        .yz = (a.s * b.yz + a.yz * b.s),
        .i = (a.i * b.s + a.s * b.i + a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Motor& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Motor Motor::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Motor::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Motor& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = a.s * b.w,
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y + a.xy * b.w - a.wy * b.x),
        .wxz = (a.wx * b.z + a.xz * b.w - a.wz * b.x),
        .wyz = (a.wy * b.z + a.yz * b.w - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Motor& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr Multivector Motor::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Motor::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Motor& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Motor& a,const Bivector& b) noexcept { return wedge(a, b); }
    constexpr Motor Motor::wedge(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Motor::meet(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Motor& a,const ProjectivePoint& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = a.s * b.w
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Motor& a,const ProjectivePoint& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Motor::wedge(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Motor::meet(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Motor& a,const Quaternion& b) noexcept { return {
        .s = a.s * b.s,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = (a.s * b.xy + a.xy * b.s),
        .xz = (a.s * b.xz + a.xz * b.s),
        .yz = (a.s * b.yz + a.yz * b.s),
        .i = (a.i * b.s + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const Motor& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr Motor Motor::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Motor::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Motor& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s),
        .wy = (a.s * b.wy + a.wy * b.s),
        .wz = (a.s * b.wz + a.wz * b.s),
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.i * b.s + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Motor& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr Motor Motor::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Motor::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Motor& a,const Translator& b) noexcept { return {
        .s = a.s,
        .wx = (a.wx + a.s * b.wx),
        .wy = (a.wy + a.s * b.wy),
        .wz = (a.wz + a.s * b.wz),
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = (a.i + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Motor& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr Motor Motor::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Motor::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const Motor& a,const Vector& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z
    }; }
    [[nodiscard]] constexpr Vector meet(const Motor& a,const Vector& b) noexcept { return wedge(a, b); }
    constexpr Vector Motor::wedge(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector Motor::meet(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Motor& a,const Point& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = a.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Motor& a,const Point& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Motor::wedge(const Point& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Motor::meet(const Point& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Motor& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Motor& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr Multivector Motor::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Motor::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Motor& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const Motor& a,const BivectorBulk& b) noexcept { return wedge(a, b); }
    constexpr Motor Motor::wedge(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Motor::meet(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Motor& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Motor& a,const BivectorWeight& b) noexcept { return wedge(a, b); }
    constexpr Motor Motor::wedge(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Motor::meet(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Motor& a,const PseudoScalar& b) noexcept { return {
        .i = a.s * b.i
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Motor& a,const PseudoScalar& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Motor::wedge(const PseudoScalar& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Motor::meet(const PseudoScalar& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Motor& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Motor& a,const PointCenter& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Motor::wedge(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Motor::meet(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Plane& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = a.w * b.s,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.w * b.xy + a.y * b.wx - a.x * b.wy),
        .wxz = (a.w * b.xz + a.z * b.wx - a.x * b.wz),
        .wyz = (a.w * b.yz + a.z * b.wy - a.y * b.wz),
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Plane& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Multivector Plane::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Plane::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Bivector wedge(const Plane& a,const Plane& b) noexcept { return {
        .wx = (a.w * b.x - a.x * b.w),
        .wy = (a.w * b.y - a.y * b.w),
        .wz = (a.w * b.z - a.z * b.w),
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    [[nodiscard]] constexpr Bivector meet(const Plane& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr Bivector Plane::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Bivector Plane::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Plane& a,const Bivector& b) noexcept { return {
        .x = (a.y * b.wz - a.w * b.yz - a.z * b.wy),
        .y = (a.w * b.xz + a.z * b.wx - a.x * b.wz),
        .z = (a.x * b.wy - a.w * b.xy - a.y * b.wx),
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Plane& a,const Bivector& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Plane::wedge(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Plane::meet(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Plane& a,const ProjectivePoint& b) noexcept { return {
        .i = (a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Plane& a,const ProjectivePoint& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Plane::wedge(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Plane::meet(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Plane& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = a.w * b.s,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.w * b.xy,
        .wxz = a.w * b.xz,
        .wyz = a.w * b.yz,
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Plane& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr Multivector Plane::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Plane::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Plane& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = a.w * b.s,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Plane& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr Multivector Plane::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Plane::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Plane& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = a.w,
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Plane& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr Multivector Plane::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Plane::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Plane& a,const Vector& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Plane& a,const Vector& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Plane::wedge(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Plane::meet(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Plane& a,const Point& b) noexcept { return {
        .i = (a.w + a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Plane& a,const Point& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Plane::wedge(const Point& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Plane::meet(const Point& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Bivector wedge(const Plane& a,const PlaneIdeal& b) noexcept { return {
        .wx = a.w * b.x,
        .wy = a.w * b.y,
        .wz = a.w * b.z,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    [[nodiscard]] constexpr Bivector meet(const Plane& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr Bivector Plane::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Bivector Plane::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Plane& a,const BivectorBulk& b) noexcept { return {
        .x = -a.w * b.yz,
        .y = a.w * b.xz,
        .z = -a.w * b.xy,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Plane& a,const BivectorBulk& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Plane::wedge(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Plane::meet(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const Plane& a,const BivectorWeight& b) noexcept { return {
        .x = (a.y * b.wz - a.z * b.wy),
        .y = (a.z * b.wx - a.x * b.wz),
        .z = (a.x * b.wy - a.y * b.wx)
    }; }
    [[nodiscard]] constexpr Vector meet(const Plane& a,const BivectorWeight& b) noexcept { return wedge(a, b); }
    constexpr Vector Plane::wedge(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector Plane::meet(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Plane& a,const PointCenter& b) noexcept { return {
        .i = a.w
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Plane& a,const PointCenter& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Plane::wedge(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Plane::meet(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Bivector& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Bivector& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Motor Bivector::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Bivector::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Bivector& a,const Plane& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z - a.yz * b.w),
        .y = (a.wx * b.z + a.xz * b.w - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y - a.xy * b.w),
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Bivector& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Bivector::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Bivector::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Bivector& a,const Bivector& b) noexcept { return {
        .i = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Bivector& a,const Bivector& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Bivector::wedge(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Bivector::meet(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Bivector& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const Bivector& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr Motor Bivector::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Bivector::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Bivector& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Bivector& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr Motor Bivector::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Bivector::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Bivector& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Bivector& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr Motor Bivector::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Bivector::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Bivector& a,const PlaneIdeal& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y),
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Bivector& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Bivector::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Bivector::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Bivector& a,const BivectorBulk& b) noexcept { return {
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Bivector& a,const BivectorBulk& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Bivector::wedge(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Bivector::meet(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Bivector& a,const BivectorWeight& b) noexcept { return {
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Bivector& a,const BivectorWeight& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Bivector::wedge(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Bivector::meet(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& a,const Motor& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = a.w * b.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const ProjectivePoint& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint ProjectivePoint::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint ProjectivePoint::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const ProjectivePoint& a,const Plane& b) noexcept { return {
        .i = (-a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const ProjectivePoint& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar ProjectivePoint::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar ProjectivePoint::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& a,const Quaternion& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = a.w * b.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const ProjectivePoint& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint ProjectivePoint::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint ProjectivePoint::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = a.w * b.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const ProjectivePoint& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint ProjectivePoint::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint ProjectivePoint::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& a,const Translator& b) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .w = a.w
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const ProjectivePoint& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint ProjectivePoint::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint ProjectivePoint::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const ProjectivePoint& a,const PlaneIdeal& b) noexcept { return {
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const ProjectivePoint& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar ProjectivePoint::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar ProjectivePoint::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Quaternion& a,const Motor& b) noexcept { return {
        .s = a.s * b.s,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = (a.s * b.xy + a.xy * b.s),
        .xz = (a.s * b.xz + a.xz * b.s),
        .yz = (a.s * b.yz + a.yz * b.s),
        .i = (a.s * b.i + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Quaternion& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Motor Quaternion::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Quaternion::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Quaternion& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = a.s * b.w,
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.xy * b.w,
        .wxz = a.xz * b.w,
        .wyz = a.yz * b.w,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Quaternion& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr Multivector Quaternion::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Quaternion::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Quaternion& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Quaternion& a,const Bivector& b) noexcept { return wedge(a, b); }
    constexpr Motor Quaternion::wedge(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Quaternion::meet(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Quaternion& a,const ProjectivePoint& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = a.s * b.w
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Quaternion& a,const ProjectivePoint& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Quaternion::wedge(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Quaternion::meet(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Quaternion wedge(const Quaternion& a,const Quaternion& b) noexcept { return {
        .s = a.s * b.s,
        .xy = (a.s * b.xy + a.xy * b.s),
        .xz = (a.s * b.xz + a.xz * b.s),
        .yz = (a.s * b.yz + a.yz * b.s)
    }; }
    [[nodiscard]] constexpr Quaternion meet(const Quaternion& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr Quaternion Quaternion::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Quaternion Quaternion::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Quaternion& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.s * b.s,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Quaternion& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr Motor Quaternion::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Quaternion::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Quaternion& a,const Translator& b) noexcept { return {
        .s = a.s,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Quaternion& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr Motor Quaternion::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Quaternion::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const Quaternion& a,const Vector& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z
    }; }
    [[nodiscard]] constexpr Vector meet(const Quaternion& a,const Vector& b) noexcept { return wedge(a, b); }
    constexpr Vector Quaternion::wedge(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector Quaternion::meet(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Quaternion& a,const Point& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = a.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Quaternion& a,const Point& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Quaternion::wedge(const Point& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Quaternion::meet(const Point& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Quaternion& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.xy * b.z + a.yz * b.x - a.xz * b.y),
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Quaternion& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr Multivector Quaternion::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Quaternion::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk wedge(const Quaternion& a,const BivectorBulk& b) noexcept { return {
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz
    }; }
    [[nodiscard]] constexpr BivectorBulk meet(const Quaternion& a,const BivectorBulk& b) noexcept { return wedge(a, b); }
    constexpr BivectorBulk Quaternion::wedge(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr BivectorBulk Quaternion::meet(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Quaternion& a,const BivectorWeight& b) noexcept { return {
        .s = 0.0,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const Quaternion& a,const BivectorWeight& b) noexcept { return wedge(a, b); }
    constexpr Motor Quaternion::wedge(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Quaternion::meet(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Quaternion& a,const PseudoScalar& b) noexcept { return {
        .i = a.s * b.i
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Quaternion& a,const PseudoScalar& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Quaternion::wedge(const PseudoScalar& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Quaternion::meet(const PseudoScalar& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Quaternion& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Quaternion& a,const PointCenter& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Quaternion::wedge(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Quaternion::meet(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& a,const Motor& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s),
        .wy = (a.s * b.wy + a.wy * b.s),
        .wz = (a.s * b.wz + a.wz * b.s),
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.s * b.i + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const ProjectiveTranslator& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Motor ProjectiveTranslator::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor ProjectiveTranslator::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const ProjectiveTranslator& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = a.s * b.w,
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const ProjectiveTranslator& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr Multivector ProjectiveTranslator::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector ProjectiveTranslator::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const ProjectiveTranslator& a,const Bivector& b) noexcept { return wedge(a, b); }
    constexpr Motor ProjectiveTranslator::wedge(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor ProjectiveTranslator::meet(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectiveTranslator& a,const ProjectivePoint& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = a.s * b.w
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const ProjectiveTranslator& a,const ProjectivePoint& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint ProjectiveTranslator::wedge(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint ProjectiveTranslator::meet(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& a,const Quaternion& b) noexcept { return {
        .s = a.s * b.s,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const ProjectiveTranslator& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr Motor ProjectiveTranslator::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor ProjectiveTranslator::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator wedge(const ProjectiveTranslator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.s * b.s,
        .wx = (a.s * b.wx + a.wx * b.s),
        .wy = (a.s * b.wy + a.wy * b.s),
        .wz = (a.s * b.wz + a.wz * b.s)
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator meet(const ProjectiveTranslator& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr ProjectiveTranslator ProjectiveTranslator::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectiveTranslator ProjectiveTranslator::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator wedge(const ProjectiveTranslator& a,const Translator& b) noexcept { return {
        .s = a.s,
        .wx = (a.wx + a.s * b.wx),
        .wy = (a.wy + a.s * b.wy),
        .wz = (a.wz + a.s * b.wz)
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator meet(const ProjectiveTranslator& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr ProjectiveTranslator ProjectiveTranslator::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectiveTranslator ProjectiveTranslator::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const ProjectiveTranslator& a,const Vector& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z
    }; }
    [[nodiscard]] constexpr Vector meet(const ProjectiveTranslator& a,const Vector& b) noexcept { return wedge(a, b); }
    constexpr Vector ProjectiveTranslator::wedge(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector ProjectiveTranslator::meet(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectiveTranslator& a,const Point& b) noexcept { return {
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .w = a.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const ProjectiveTranslator& a,const Point& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint ProjectiveTranslator::wedge(const Point& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint ProjectiveTranslator::meet(const Point& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const ProjectiveTranslator& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.s * b.x,
        .y = a.s * b.y,
        .z = a.s * b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const ProjectiveTranslator& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr Multivector ProjectiveTranslator::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector ProjectiveTranslator::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = a.s * b.xy,
        .xz = a.s * b.xz,
        .yz = a.s * b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const ProjectiveTranslator& a,const BivectorBulk& b) noexcept { return wedge(a, b); }
    constexpr Motor ProjectiveTranslator::wedge(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor ProjectiveTranslator::meet(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr BivectorWeight wedge(const ProjectiveTranslator& a,const BivectorWeight& b) noexcept { return {
        .wx = a.s * b.wx,
        .wy = a.s * b.wy,
        .wz = a.s * b.wz
    }; }
    [[nodiscard]] constexpr BivectorWeight meet(const ProjectiveTranslator& a,const BivectorWeight& b) noexcept { return wedge(a, b); }
    constexpr BivectorWeight ProjectiveTranslator::wedge(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr BivectorWeight ProjectiveTranslator::meet(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const ProjectiveTranslator& a,const PseudoScalar& b) noexcept { return {
        .i = a.s * b.i
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const ProjectiveTranslator& a,const PseudoScalar& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar ProjectiveTranslator::wedge(const PseudoScalar& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar ProjectiveTranslator::meet(const PseudoScalar& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectiveTranslator& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const ProjectiveTranslator& a,const PointCenter& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint ProjectiveTranslator::wedge(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint ProjectiveTranslator::meet(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Translator& a,const Motor& b) noexcept { return {
        .s = b.s,
        .wx = (b.wx + a.wx * b.s),
        .wy = (b.wy + a.wy * b.s),
        .wz = (b.wz + a.wz * b.s),
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (b.i + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const Translator& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Motor Translator::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Translator::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Translator& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = b.w,
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Translator& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr Multivector Translator::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Translator::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Translator& a,const Bivector& b) noexcept { return {
        .s = 0.0,
        .wx = b.wx,
        .wy = b.wy,
        .wz = b.wz,
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const Translator& a,const Bivector& b) noexcept { return wedge(a, b); }
    constexpr Motor Translator::wedge(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Translator::meet(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Translator& a,const ProjectivePoint& b) noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .w = b.w
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Translator& a,const ProjectivePoint& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Translator::wedge(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Translator::meet(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Translator& a,const Quaternion& b) noexcept { return {
        .s = b.s,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const Translator& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr Motor Translator::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Translator::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator wedge(const Translator& a,const ProjectiveTranslator& b) noexcept { return {
        .s = b.s,
        .wx = (b.wx + a.wx * b.s),
        .wy = (b.wy + a.wy * b.s),
        .wz = (b.wz + a.wz * b.s)
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator meet(const Translator& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr ProjectiveTranslator Translator::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectiveTranslator Translator::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Translator wedge(const Translator& a,const Translator& b) noexcept { return {
        .wx = (a.wx + b.wx),
        .wy = (a.wy + b.wy),
        .wz = (a.wz + b.wz)
    }; }
    [[nodiscard]] constexpr Translator meet(const Translator& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr Translator Translator::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Translator Translator::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const Translator& a,const Vector& b) noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z
    }; }
    [[nodiscard]] constexpr Vector meet(const Translator& a,const Vector& b) noexcept { return wedge(a, b); }
    constexpr Vector Translator::wedge(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector Translator::meet(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Point wedge(const Translator& a,const Point& b) noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z
    }; }
    [[nodiscard]] constexpr Point meet(const Translator& a,const Point& b) noexcept { return wedge(a, b); }
    constexpr Point Translator::wedge(const Point& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Point Translator::meet(const Point& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const Translator& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wx * b.y - a.wy * b.x),
        .wxz = (a.wx * b.z - a.wz * b.x),
        .wyz = (a.wy * b.z - a.wz * b.y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const Translator& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr Multivector Translator::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector Translator::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const Translator& a,const BivectorBulk& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const Translator& a,const BivectorBulk& b) noexcept { return wedge(a, b); }
    constexpr Motor Translator::wedge(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor Translator::meet(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr BivectorWeight wedge(const Translator& a,const BivectorWeight& b) noexcept { return {
        .wx = b.wx,
        .wy = b.wy,
        .wz = b.wz
    }; }
    [[nodiscard]] constexpr BivectorWeight meet(const Translator& a,const BivectorWeight& b) noexcept { return wedge(a, b); }
    constexpr BivectorWeight Translator::wedge(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr BivectorWeight Translator::meet(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Translator& a,const PseudoScalar& b) noexcept { return {
        .i = b.i
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Translator& a,const PseudoScalar& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Translator::wedge(const PseudoScalar& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Translator::meet(const PseudoScalar& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PointCenter wedge(const Translator& a,const PointCenter& b) noexcept { return {}; }
    [[nodiscard]] constexpr PointCenter meet(const Translator& a,const PointCenter& b) noexcept { return wedge(a, b); }
    constexpr PointCenter Translator::wedge(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PointCenter Translator::meet(const PointCenter& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const Vector& a,const Motor& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s
    }; }
    [[nodiscard]] constexpr Vector meet(const Vector& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Vector Vector::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector Vector::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Vector& a,const Plane& b) noexcept { return {
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Vector& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Vector::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Vector::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const Vector& a,const Quaternion& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s
    }; }
    [[nodiscard]] constexpr Vector meet(const Vector& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr Vector Vector::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector Vector::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const Vector& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s
    }; }
    [[nodiscard]] constexpr Vector meet(const Vector& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr Vector Vector::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector Vector::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const Vector& a,const Translator& b) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    [[nodiscard]] constexpr Vector meet(const Vector& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr Vector Vector::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector Vector::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Vector& a,const PlaneIdeal& b) noexcept { return {
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Vector& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Vector::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Vector::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Point& a,const Motor& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = b.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Point& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Point::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Point::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Point& a,const Plane& b) noexcept { return {
        .i = (-b.w - a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Point& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Point::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Point::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Point& a,const Quaternion& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = b.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Point& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Point::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Point::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const Point& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .w = b.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const Point& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint Point::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint Point::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Point wedge(const Point& a,const Translator& b) noexcept { return {
        .x = a.x,
        .y = a.y,
        .z = a.z
    }; }
    [[nodiscard]] constexpr Point meet(const Point& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr Point Point::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Point Point::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const Point& a,const PlaneIdeal& b) noexcept { return {
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const Point& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar Point::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar Point::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const PlaneIdeal& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Multivector PlaneIdeal::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector PlaneIdeal::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Bivector wedge(const PlaneIdeal& a,const Plane& b) noexcept { return {
        .wx = -a.x * b.w,
        .wy = -a.y * b.w,
        .wz = -a.z * b.w,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    [[nodiscard]] constexpr Bivector meet(const PlaneIdeal& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr Bivector PlaneIdeal::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Bivector PlaneIdeal::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const PlaneIdeal& a,const Bivector& b) noexcept { return {
        .x = (a.y * b.wz - a.z * b.wy),
        .y = (a.z * b.wx - a.x * b.wz),
        .z = (a.x * b.wy - a.y * b.wx),
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const PlaneIdeal& a,const Bivector& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint PlaneIdeal::wedge(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint PlaneIdeal::meet(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const PlaneIdeal& a,const ProjectivePoint& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const PlaneIdeal& a,const ProjectivePoint& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar PlaneIdeal::wedge(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar PlaneIdeal::meet(const ProjectivePoint& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (a.x * b.yz + a.z * b.xy - a.y * b.xz),
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const PlaneIdeal& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr Multivector PlaneIdeal::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector PlaneIdeal::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x * b.s,
        .y = a.y * b.s,
        .z = a.z * b.s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const PlaneIdeal& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr Multivector PlaneIdeal::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector PlaneIdeal::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = a.x,
        .y = a.y,
        .z = a.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.y * b.wx - a.x * b.wy),
        .wxz = (a.z * b.wx - a.x * b.wz),
        .wyz = (a.z * b.wy - a.y * b.wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector meet(const PlaneIdeal& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr Multivector PlaneIdeal::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Multivector PlaneIdeal::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const PlaneIdeal& a,const Vector& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const PlaneIdeal& a,const Vector& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar PlaneIdeal::wedge(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar PlaneIdeal::meet(const Vector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const PlaneIdeal& a,const Point& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const PlaneIdeal& a,const Point& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar PlaneIdeal::wedge(const Point& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar PlaneIdeal::meet(const Point& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk wedge(const PlaneIdeal& a,const PlaneIdeal& b) noexcept { return {
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    [[nodiscard]] constexpr BivectorBulk meet(const PlaneIdeal& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr BivectorBulk PlaneIdeal::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr BivectorBulk PlaneIdeal::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const PlaneIdeal& a,const BivectorBulk& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.yz + a.z * b.xy - a.y * b.xz)
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const PlaneIdeal& a,const BivectorBulk& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint PlaneIdeal::wedge(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint PlaneIdeal::meet(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const PlaneIdeal& a,const BivectorWeight& b) noexcept { return {
        .x = (a.y * b.wz - a.z * b.wy),
        .y = (a.z * b.wx - a.x * b.wz),
        .z = (a.x * b.wy - a.y * b.wx)
    }; }
    [[nodiscard]] constexpr Vector meet(const PlaneIdeal& a,const BivectorWeight& b) noexcept { return wedge(a, b); }
    constexpr Vector PlaneIdeal::wedge(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector PlaneIdeal::meet(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const BivectorBulk& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const BivectorBulk& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Motor BivectorBulk::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor BivectorBulk::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const BivectorBulk& a,const Plane& b) noexcept { return {
        .x = -a.yz * b.w,
        .y = a.xz * b.w,
        .z = -a.xy * b.w,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const BivectorBulk& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint BivectorBulk::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint BivectorBulk::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const BivectorBulk& a,const Bivector& b) noexcept { return {
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const BivectorBulk& a,const Bivector& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar BivectorBulk::wedge(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar BivectorBulk::meet(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk wedge(const BivectorBulk& a,const Quaternion& b) noexcept { return {
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s
    }; }
    [[nodiscard]] constexpr BivectorBulk meet(const BivectorBulk& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr BivectorBulk BivectorBulk::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr BivectorBulk BivectorBulk::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const BivectorBulk& a,const ProjectiveTranslator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = a.xy * b.s,
        .xz = a.xz * b.s,
        .yz = a.yz * b.s,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const BivectorBulk& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr Motor BivectorBulk::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor BivectorBulk::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const BivectorBulk& a,const Translator& b) noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = a.xy,
        .xz = a.xz,
        .yz = a.yz,
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr Motor meet(const BivectorBulk& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr Motor BivectorBulk::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor BivectorBulk::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const BivectorBulk& a,const PlaneIdeal& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.xy * b.z + a.yz * b.x - a.xz * b.y)
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const BivectorBulk& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint BivectorBulk::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint BivectorBulk::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const BivectorBulk& a,const BivectorWeight& b) noexcept { return {
        .i = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const BivectorBulk& a,const BivectorWeight& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar BivectorBulk::wedge(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar BivectorBulk::meet(const BivectorWeight& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const BivectorWeight& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const BivectorWeight& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr Motor BivectorWeight::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor BivectorWeight::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const BivectorWeight& a,const Plane& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y)
    }; }
    [[nodiscard]] constexpr Vector meet(const BivectorWeight& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr Vector BivectorWeight::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector BivectorWeight::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const BivectorWeight& a,const Bivector& b) noexcept { return {
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const BivectorWeight& a,const Bivector& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar BivectorWeight::wedge(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar BivectorWeight::meet(const Bivector& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Motor wedge(const BivectorWeight& a,const Quaternion& b) noexcept { return {
        .s = 0.0,
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr Motor meet(const BivectorWeight& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr Motor BivectorWeight::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Motor BivectorWeight::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr BivectorWeight wedge(const BivectorWeight& a,const ProjectiveTranslator& b) noexcept { return {
        .wx = a.wx * b.s,
        .wy = a.wy * b.s,
        .wz = a.wz * b.s
    }; }
    [[nodiscard]] constexpr BivectorWeight meet(const BivectorWeight& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr BivectorWeight BivectorWeight::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr BivectorWeight BivectorWeight::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr BivectorWeight wedge(const BivectorWeight& a,const Translator& b) noexcept { return {
        .wx = a.wx,
        .wy = a.wy,
        .wz = a.wz
    }; }
    [[nodiscard]] constexpr BivectorWeight meet(const BivectorWeight& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr BivectorWeight BivectorWeight::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr BivectorWeight BivectorWeight::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr Vector wedge(const BivectorWeight& a,const PlaneIdeal& b) noexcept { return {
        .x = (a.wz * b.y - a.wy * b.z),
        .y = (a.wx * b.z - a.wz * b.x),
        .z = (a.wy * b.x - a.wx * b.y)
    }; }
    [[nodiscard]] constexpr Vector meet(const BivectorWeight& a,const PlaneIdeal& b) noexcept { return wedge(a, b); }
    constexpr Vector BivectorWeight::wedge(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr Vector BivectorWeight::meet(const PlaneIdeal& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const BivectorWeight& a,const BivectorBulk& b) noexcept { return {
        .i = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz)
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const BivectorWeight& a,const BivectorBulk& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar BivectorWeight::wedge(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar BivectorWeight::meet(const BivectorBulk& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& a,const Motor& b) noexcept { return {
        .i = a.i * b.s
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const PseudoScalar& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar PseudoScalar::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar PseudoScalar::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& a,const Quaternion& b) noexcept { return {
        .i = a.i * b.s
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const PseudoScalar& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar PseudoScalar::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar PseudoScalar::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& a,const ProjectiveTranslator& b) noexcept { return {
        .i = a.i * b.s
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const PseudoScalar& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar PseudoScalar::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar PseudoScalar::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& a,const Translator& b) noexcept { return {
        .i = a.i
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const PseudoScalar& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar PseudoScalar::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar PseudoScalar::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const PointCenter& a,const Motor& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const PointCenter& a,const Motor& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint PointCenter::wedge(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint PointCenter::meet(const Motor& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar wedge(const PointCenter& a,const Plane& b) noexcept { return {
        .i = -b.w
    }; }
    [[nodiscard]] constexpr PseudoScalar meet(const PointCenter& a,const Plane& b) noexcept { return wedge(a, b); }
    constexpr PseudoScalar PointCenter::wedge(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PseudoScalar PointCenter::meet(const Plane& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const PointCenter& a,const Quaternion& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const PointCenter& a,const Quaternion& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint PointCenter::wedge(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint PointCenter::meet(const Quaternion& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint wedge(const PointCenter& a,const ProjectiveTranslator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.s
    }; }
    [[nodiscard]] constexpr ProjectivePoint meet(const PointCenter& a,const ProjectiveTranslator& b) noexcept { return wedge(a, b); }
    constexpr ProjectivePoint PointCenter::wedge(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr ProjectivePoint PointCenter::meet(const ProjectiveTranslator& b) const noexcept { return pga3d::wedge(*this, b); }

    [[nodiscard]] constexpr PointCenter wedge(const PointCenter& a,const Translator& b) noexcept { return {}; }
    [[nodiscard]] constexpr PointCenter meet(const PointCenter& a,const Translator& b) noexcept { return wedge(a, b); }
    constexpr PointCenter PointCenter::wedge(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }
    constexpr PointCenter PointCenter::meet(const Translator& b) const noexcept { return pga3d::wedge(*this, b); }

}

// opsAntiWedge.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

namespace pga3d {
    [[nodiscard]] constexpr Multivector antiWedge(const Multivector& a,const Multivector& b) noexcept { return {
        .s = (a.i * b.s + a.s * b.i + a.wx * b.yz + a.wxz * b.y + a.wz * b.xy + a.x * b.wyz + a.xy * b.wz + a.xyz * b.w + a.yz * b.wx + a.z * b.wxy - a.w * b.xyz - a.wxy * b.z - a.wy * b.xz - a.wyz * b.x - a.xz * b.wy - a.y * b.wxz),
        .w = (a.i * b.w + a.w * b.i + a.wxz * b.wy + a.wy * b.wxz - a.wx * b.wyz - a.wxy * b.wz - a.wyz * b.wx - a.wz * b.wxy),
        .x = (a.i * b.x + a.wxz * b.xy + a.x * b.i + a.xy * b.wxz - a.wx * b.xyz - a.wxy * b.xz - a.xyz * b.wx - a.xz * b.wxy),
        .y = (a.i * b.y + a.wyz * b.xy + a.xy * b.wyz + a.y * b.i - a.wxy * b.yz - a.wy * b.xyz - a.xyz * b.wy - a.yz * b.wxy),
        .z = (a.i * b.z + a.wyz * b.xz + a.xz * b.wyz + a.z * b.i - a.wxz * b.yz - a.wz * b.xyz - a.xyz * b.wz - a.yz * b.wxz),
        .wx = (a.i * b.wx + a.wx * b.i + a.wxy * b.wxz - a.wxz * b.wxy),
        .wy = (a.i * b.wy + a.wxy * b.wyz + a.wy * b.i - a.wyz * b.wxy),
        .wz = (a.i * b.wz + a.wxz * b.wyz + a.wz * b.i - a.wyz * b.wxz),
        .xy = (a.i * b.xy + a.wxy * b.xyz + a.xy * b.i - a.xyz * b.wxy),
        .xz = (a.i * b.xz + a.wxz * b.xyz + a.xz * b.i - a.xyz * b.wxz),
        .yz = (a.i * b.yz + a.wyz * b.xyz + a.yz * b.i - a.xyz * b.wyz),
        .wxy = (a.i * b.wxy + a.wxy * b.i),
        .wxz = (a.i * b.wxz + a.wxz * b.i),
        .wyz = (a.i * b.wyz + a.wyz * b.i),
        .xyz = (a.i * b.xyz + a.xyz * b.i),
        .i = a.i * b.i
    }; }
    [[nodiscard]] constexpr Multivector join(const Multivector& a,const Multivector& b) noexcept { return antiWedge(a, b); }
    constexpr Multivector Multivector::antiWedge(const Multivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Multivector Multivector::join(const Multivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Motor antiWedge(const Motor& a,const Motor& b) noexcept { return {
        .s = (a.i * b.s + a.s * b.i + a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy),
        .wx = (a.i * b.wx + a.wx * b.i),
        .wy = (a.i * b.wy + a.wy * b.i),
        .wz = (a.i * b.wz + a.wz * b.i),
        .xy = (a.i * b.xy + a.xy * b.i),
        .xz = (a.i * b.xz + a.xz * b.i),
        .yz = (a.i * b.yz + a.yz * b.i),
        .i = a.i * b.i
    }; }
    [[nodiscard]] constexpr Motor join(const Motor& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Motor Motor::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Motor Motor::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Motor& a,const Plane& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i * b.w
    }; }
    [[nodiscard]] constexpr Plane join(const Motor& a,const Plane& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Motor::antiWedge(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Motor::join(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Motor antiWedge(const Motor& a,const Bivector& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy),
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Motor join(const Motor& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr Motor Motor::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Motor Motor::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Multivector antiWedge(const Motor& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z - a.wx * b.w),
        .y = (a.yz * b.z - a.wy * b.w - a.xy * b.x),
        .z = (-a.wz * b.w - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.i * b.z,
        .wxz = a.i * b.y,
        .wyz = -a.i * b.x,
        .xyz = a.i * b.w,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector join(const Motor& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr Multivector Motor::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Multivector Motor::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Quaternion antiWedge(const Motor& a,const Quaternion& b) noexcept { return {
        .s = (a.i * b.s + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    [[nodiscard]] constexpr Quaternion join(const Motor& a,const Quaternion& b) noexcept { return antiWedge(a, b); }
    constexpr Quaternion Motor::antiWedge(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Quaternion Motor::join(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Motor& a,const ProjectiveTranslator& b) noexcept { return {
        .s = (a.i * b.s + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const Motor& a,const ProjectiveTranslator& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator Motor::antiWedge(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator Motor::join(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Motor& a,const Translator& b) noexcept { return {
        .s = (a.i + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const Motor& a,const Translator& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator Motor::antiWedge(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator Motor::join(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Multivector antiWedge(const Motor& a,const Vector& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.i * b.z,
        .wxz = a.i * b.y,
        .wyz = -a.i * b.x,
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector join(const Motor& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr Multivector Motor::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Multivector Motor::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Multivector antiWedge(const Motor& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (-a.wx + a.xy * b.y + a.xz * b.z),
        .y = (-a.wy + a.yz * b.z - a.xy * b.x),
        .z = (-a.wz - a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.i * b.z,
        .wxz = a.i * b.y,
        .wyz = -a.i * b.x,
        .xyz = a.i,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector join(const Motor& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr Multivector Motor::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Multivector Motor::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Motor& a,const PlaneIdeal& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Motor& a,const PlaneIdeal& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Motor::antiWedge(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Motor::join(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Quaternion antiWedge(const Motor& a,const BivectorBulk& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    [[nodiscard]] constexpr Quaternion join(const Motor& a,const BivectorBulk& b) noexcept { return antiWedge(a, b); }
    constexpr Quaternion Motor::antiWedge(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Quaternion Motor::join(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Motor& a,const BivectorWeight& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const Motor& a,const BivectorWeight& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator Motor::antiWedge(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator Motor::join(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Motor antiWedge(const Motor& a,const PseudoScalar& b) noexcept { return {
        .s = a.s * b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i,
        .i = a.i * b.i
    }; }
    [[nodiscard]] constexpr Motor join(const Motor& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr Motor Motor::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Motor Motor::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Multivector antiWedge(const Motor& a,const PointCenter& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = a.i,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector join(const Motor& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr Multivector Motor::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Multivector Motor::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Plane& a,const Motor& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = a.w * b.i
    }; }
    [[nodiscard]] constexpr Plane join(const Plane& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Plane::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Plane::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Plane& a,const ProjectivePoint& b) noexcept { return (-a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z); }
    [[nodiscard]] constexpr double join(const Plane& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr double Plane::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Plane::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Plane& a,const Vector& b) noexcept { return (-a.x * b.x - a.y * b.y - a.z * b.z); }
    [[nodiscard]] constexpr double join(const Plane& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr double Plane::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Plane::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Plane& a,const Point& b) noexcept { return (-a.w - a.x * b.x - a.y * b.y - a.z * b.z); }
    [[nodiscard]] constexpr double join(const Plane& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr double Plane::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Plane::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Plane& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = a.w * b.i
    }; }
    [[nodiscard]] constexpr Plane join(const Plane& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Plane::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Plane::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Plane& a,const PointCenter& b) noexcept { return -a.w; }
    [[nodiscard]] constexpr double join(const Plane& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr double Plane::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Plane::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Motor antiWedge(const Bivector& a,const Motor& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy),
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Motor join(const Bivector& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Motor Bivector::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Motor Bivector::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Bivector& a,const Bivector& b) noexcept { return (a.wx * b.yz + a.wz * b.xy + a.xy * b.wz + a.yz * b.wx - a.wy * b.xz - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const Bivector& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr double Bivector::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Bivector::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Bivector& a,const ProjectivePoint& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z - a.wx * b.w),
        .y = (a.yz * b.z - a.wy * b.w - a.xy * b.x),
        .z = (-a.wz * b.w - a.xz * b.x - a.yz * b.y),
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const Bivector& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Bivector::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Bivector::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Bivector& a,const Quaternion& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const Bivector& a,const Quaternion& b) noexcept { return antiWedge(a, b); }
    constexpr double Bivector::antiWedge(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Bivector::join(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Bivector& a,const ProjectiveTranslator& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const Bivector& a,const ProjectiveTranslator& b) noexcept { return antiWedge(a, b); }
    constexpr double Bivector::antiWedge(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Bivector::join(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Bivector& a,const Translator& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const Bivector& a,const Translator& b) noexcept { return antiWedge(a, b); }
    constexpr double Bivector::antiWedge(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Bivector::join(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Bivector& a,const Vector& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const Bivector& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Bivector::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Bivector::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Bivector& a,const Point& b) noexcept { return {
        .x = (-a.wx + a.xy * b.y + a.xz * b.z),
        .y = (-a.wy + a.yz * b.z - a.xy * b.x),
        .z = (-a.wz - a.xz * b.x - a.yz * b.y),
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const Bivector& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Bivector::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Bivector::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Bivector& a,const BivectorBulk& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const Bivector& a,const BivectorBulk& b) noexcept { return antiWedge(a, b); }
    constexpr double Bivector::antiWedge(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Bivector::join(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Bivector& a,const BivectorWeight& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const Bivector& a,const BivectorWeight& b) noexcept { return antiWedge(a, b); }
    constexpr double Bivector::antiWedge(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Bivector::join(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const Bivector& a,const PseudoScalar& b) noexcept { return {
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    [[nodiscard]] constexpr Bivector join(const Bivector& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector Bivector::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector Bivector::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Bivector& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Bivector& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Bivector::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Bivector::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Multivector antiWedge(const ProjectivePoint& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (a.y * b.xy + a.z * b.xz - a.w * b.wx),
        .y = (a.z * b.yz - a.w * b.wy - a.x * b.xy),
        .z = (-a.w * b.wz - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.i,
        .wxz = a.y * b.i,
        .wyz = -a.x * b.i,
        .xyz = a.w * b.i,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector join(const ProjectivePoint& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Multivector ProjectivePoint::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Multivector ProjectivePoint::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const ProjectivePoint& a,const Plane& b) noexcept { return (a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z); }
    [[nodiscard]] constexpr double join(const ProjectivePoint& a,const Plane& b) noexcept { return antiWedge(a, b); }
    constexpr double ProjectivePoint::antiWedge(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double ProjectivePoint::join(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& a,const Bivector& b) noexcept { return {
        .x = (a.y * b.xy + a.z * b.xz - a.w * b.wx),
        .y = (a.z * b.yz - a.w * b.wy - a.x * b.xy),
        .z = (-a.w * b.wz - a.x * b.xz - a.y * b.yz),
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const ProjectivePoint& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr Plane ProjectivePoint::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane ProjectivePoint::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const ProjectivePoint& a,const ProjectivePoint& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = (a.w * b.z - a.z * b.w),
        .xz = (a.y * b.w - a.w * b.y),
        .yz = (a.w * b.x - a.x * b.w)
    }; }
    [[nodiscard]] constexpr Bivector join(const ProjectivePoint& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector ProjectivePoint::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector ProjectivePoint::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const ProjectivePoint& a,const Quaternion& b) noexcept { return {
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const ProjectivePoint& a,const Quaternion& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal ProjectivePoint::antiWedge(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal ProjectivePoint::join(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& a,const ProjectiveTranslator& b) noexcept { return {
        .x = -a.w * b.wx,
        .y = -a.w * b.wy,
        .z = -a.w * b.wz,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const ProjectivePoint& a,const ProjectiveTranslator& b) noexcept { return antiWedge(a, b); }
    constexpr Plane ProjectivePoint::antiWedge(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane ProjectivePoint::join(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& a,const Translator& b) noexcept { return {
        .x = -a.w * b.wx,
        .y = -a.w * b.wy,
        .z = -a.w * b.wz,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const ProjectivePoint& a,const Translator& b) noexcept { return antiWedge(a, b); }
    constexpr Plane ProjectivePoint::antiWedge(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane ProjectivePoint::join(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const ProjectivePoint& a,const Vector& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = a.w * b.z,
        .xz = -a.w * b.y,
        .yz = a.w * b.x
    }; }
    [[nodiscard]] constexpr Bivector join(const ProjectivePoint& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector ProjectivePoint::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector ProjectivePoint::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const ProjectivePoint& a,const Point& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = (-a.z + a.w * b.z),
        .xz = (a.y - a.w * b.y),
        .yz = (-a.x + a.w * b.x)
    }; }
    [[nodiscard]] constexpr Bivector join(const ProjectivePoint& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector ProjectivePoint::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector ProjectivePoint::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const ProjectivePoint& a,const PlaneIdeal& b) noexcept { return (a.x * b.x + a.y * b.y + a.z * b.z); }
    [[nodiscard]] constexpr double join(const ProjectivePoint& a,const PlaneIdeal& b) noexcept { return antiWedge(a, b); }
    constexpr double ProjectivePoint::antiWedge(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double ProjectivePoint::join(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const ProjectivePoint& a,const BivectorBulk& b) noexcept { return {
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const ProjectivePoint& a,const BivectorBulk& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal ProjectivePoint::antiWedge(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal ProjectivePoint::join(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& a,const BivectorWeight& b) noexcept { return {
        .x = -a.w * b.wx,
        .y = -a.w * b.wy,
        .z = -a.w * b.wz,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const ProjectivePoint& a,const BivectorWeight& b) noexcept { return antiWedge(a, b); }
    constexpr Plane ProjectivePoint::antiWedge(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane ProjectivePoint::join(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiWedge(const ProjectivePoint& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = a.w * b.i
    }; }
    [[nodiscard]] constexpr ProjectivePoint join(const ProjectivePoint& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectivePoint ProjectivePoint::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectivePoint ProjectivePoint::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiWedge(const ProjectivePoint& a,const PointCenter& b) noexcept { return {
        .xy = -a.z,
        .xz = a.y,
        .yz = -a.x
    }; }
    [[nodiscard]] constexpr BivectorBulk join(const ProjectivePoint& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorBulk ProjectivePoint::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorBulk ProjectivePoint::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Quaternion antiWedge(const Quaternion& a,const Motor& b) noexcept { return {
        .s = (a.s * b.i + a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    [[nodiscard]] constexpr Quaternion join(const Quaternion& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Quaternion Quaternion::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Quaternion Quaternion::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Quaternion& a,const Bivector& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const Quaternion& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr double Quaternion::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Quaternion::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Quaternion& a,const ProjectivePoint& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Quaternion& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Quaternion::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Quaternion::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Quaternion& a,const ProjectiveTranslator& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const Quaternion& a,const ProjectiveTranslator& b) noexcept { return antiWedge(a, b); }
    constexpr double Quaternion::antiWedge(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Quaternion::join(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Quaternion& a,const Translator& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const Quaternion& a,const Translator& b) noexcept { return antiWedge(a, b); }
    constexpr double Quaternion::antiWedge(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Quaternion::join(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Quaternion& a,const Vector& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Quaternion& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Quaternion::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Quaternion::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Quaternion& a,const Point& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Quaternion& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Quaternion::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Quaternion::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Quaternion& a,const BivectorWeight& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const Quaternion& a,const BivectorWeight& b) noexcept { return antiWedge(a, b); }
    constexpr double Quaternion::antiWedge(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Quaternion::join(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Quaternion antiWedge(const Quaternion& a,const PseudoScalar& b) noexcept { return {
        .s = a.s * b.i,
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    [[nodiscard]] constexpr Quaternion join(const Quaternion& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr Quaternion Quaternion::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Quaternion Quaternion::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const ProjectiveTranslator& a,const Motor& b) noexcept { return {
        .s = (a.s * b.i + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const ProjectiveTranslator& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator ProjectiveTranslator::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const ProjectiveTranslator& a,const Bivector& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const ProjectiveTranslator& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr double ProjectiveTranslator::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double ProjectiveTranslator::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const ProjectiveTranslator& a,const ProjectivePoint& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const ProjectiveTranslator& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr Plane ProjectiveTranslator::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane ProjectiveTranslator::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const ProjectiveTranslator& a,const Quaternion& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const ProjectiveTranslator& a,const Quaternion& b) noexcept { return antiWedge(a, b); }
    constexpr double ProjectiveTranslator::antiWedge(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double ProjectiveTranslator::join(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const ProjectiveTranslator& a,const Vector& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const ProjectiveTranslator& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr Plane ProjectiveTranslator::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane ProjectiveTranslator::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const ProjectiveTranslator& a,const Point& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const ProjectiveTranslator& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr Plane ProjectiveTranslator::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane ProjectiveTranslator::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const ProjectiveTranslator& a,const BivectorBulk& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const ProjectiveTranslator& a,const BivectorBulk& b) noexcept { return antiWedge(a, b); }
    constexpr double ProjectiveTranslator::antiWedge(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double ProjectiveTranslator::join(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const ProjectiveTranslator& a,const PseudoScalar& b) noexcept { return {
        .s = a.s * b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const ProjectiveTranslator& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator ProjectiveTranslator::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const ProjectiveTranslator& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const ProjectiveTranslator& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal ProjectiveTranslator::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal ProjectiveTranslator::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Translator& a,const Motor& b) noexcept { return {
        .s = (b.i + a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const Translator& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator Translator::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator Translator::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Translator& a,const Bivector& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const Translator& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr double Translator::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Translator::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Translator& a,const ProjectivePoint& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const Translator& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Translator::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Translator::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Translator& a,const Quaternion& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const Translator& a,const Quaternion& b) noexcept { return antiWedge(a, b); }
    constexpr double Translator::antiWedge(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Translator::join(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Translator& a,const Vector& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const Translator& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Translator::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Translator::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Translator& a,const Point& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const Translator& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Translator::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Translator::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Translator& a,const BivectorBulk& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const Translator& a,const BivectorBulk& b) noexcept { return antiWedge(a, b); }
    constexpr double Translator::antiWedge(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Translator::join(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Translator& a,const PseudoScalar& b) noexcept { return {
        .s = b.i,
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const Translator& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator Translator::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator Translator::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Translator& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Translator& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Translator::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Translator::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Multivector antiWedge(const Vector& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.i,
        .wxz = a.y * b.i,
        .wyz = -a.x * b.i,
        .xyz = 0.0,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector join(const Vector& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Multivector Vector::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Multivector Vector::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Vector& a,const Plane& b) noexcept { return (a.x * b.x + a.y * b.y + a.z * b.z); }
    [[nodiscard]] constexpr double join(const Vector& a,const Plane& b) noexcept { return antiWedge(a, b); }
    constexpr double Vector::antiWedge(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Vector::join(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Vector& a,const Bivector& b) noexcept { return {
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz),
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const Vector& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Vector::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Vector::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const Vector& a,const ProjectivePoint& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = -a.z * b.w,
        .xz = a.y * b.w,
        .yz = -a.x * b.w
    }; }
    [[nodiscard]] constexpr Bivector join(const Vector& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector Vector::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector Vector::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Vector& a,const Quaternion& b) noexcept { return {
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Vector& a,const Quaternion& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Vector::antiWedge(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Vector::join(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Vector& a,const ProjectiveTranslator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const Vector& a,const ProjectiveTranslator& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Vector::antiWedge(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Vector::join(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Vector& a,const Translator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const Vector& a,const Translator& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Vector::antiWedge(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Vector::join(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorWeight antiWedge(const Vector& a,const Vector& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x)
    }; }
    [[nodiscard]] constexpr BivectorWeight join(const Vector& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorWeight Vector::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorWeight Vector::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const Vector& a,const Point& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = -a.z,
        .xz = a.y,
        .yz = -a.x
    }; }
    [[nodiscard]] constexpr Bivector join(const Vector& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector Vector::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector Vector::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Vector& a,const PlaneIdeal& b) noexcept { return (a.x * b.x + a.y * b.y + a.z * b.z); }
    [[nodiscard]] constexpr double join(const Vector& a,const PlaneIdeal& b) noexcept { return antiWedge(a, b); }
    constexpr double Vector::antiWedge(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Vector::join(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Vector& a,const BivectorBulk& b) noexcept { return {
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Vector& a,const BivectorBulk& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Vector::antiWedge(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Vector::join(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Vector& a,const BivectorWeight& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const Vector& a,const BivectorWeight& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Vector::antiWedge(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Vector::join(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Vector antiWedge(const Vector& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    [[nodiscard]] constexpr Vector join(const Vector& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr Vector Vector::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Vector Vector::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiWedge(const Vector& a,const PointCenter& b) noexcept { return {
        .xy = -a.z,
        .xz = a.y,
        .yz = -a.x
    }; }
    [[nodiscard]] constexpr BivectorBulk join(const Vector& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorBulk Vector::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorBulk Vector::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Multivector antiWedge(const Point& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz),
        .x = (-b.wx + a.y * b.xy + a.z * b.xz),
        .y = (-b.wy + a.z * b.yz - a.x * b.xy),
        .z = (-b.wz - a.x * b.xz - a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.i,
        .wxz = a.y * b.i,
        .wyz = -a.x * b.i,
        .xyz = b.i,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector join(const Point& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Multivector Point::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Multivector Point::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Point& a,const Plane& b) noexcept { return (b.w + a.x * b.x + a.y * b.y + a.z * b.z); }
    [[nodiscard]] constexpr double join(const Point& a,const Plane& b) noexcept { return antiWedge(a, b); }
    constexpr double Point::antiWedge(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Point::join(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Point& a,const Bivector& b) noexcept { return {
        .x = (-b.wx + a.y * b.xy + a.z * b.xz),
        .y = (-b.wy + a.z * b.yz - a.x * b.xy),
        .z = (-b.wz - a.x * b.xz - a.y * b.yz),
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const Point& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Point::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Point::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const Point& a,const ProjectivePoint& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = (b.z - a.z * b.w),
        .xz = (-b.y + a.y * b.w),
        .yz = (b.x - a.x * b.w)
    }; }
    [[nodiscard]] constexpr Bivector join(const Point& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector Point::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector Point::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Point& a,const Quaternion& b) noexcept { return {
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Point& a,const Quaternion& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Point::antiWedge(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Point::join(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Point& a,const ProjectiveTranslator& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const Point& a,const ProjectiveTranslator& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Point::antiWedge(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Point::join(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Point& a,const Translator& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const Point& a,const Translator& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Point::antiWedge(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Point::join(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const Point& a,const Vector& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    [[nodiscard]] constexpr Bivector join(const Point& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector Point::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector Point::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const Point& a,const Point& b) noexcept { return {
        .wx = (a.y * b.z - a.z * b.y),
        .wy = (a.z * b.x - a.x * b.z),
        .wz = (a.x * b.y - a.y * b.x),
        .xy = (b.z - a.z),
        .xz = (a.y - b.y),
        .yz = (b.x - a.x)
    }; }
    [[nodiscard]] constexpr Bivector join(const Point& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector Point::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector Point::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const Point& a,const PlaneIdeal& b) noexcept { return (a.x * b.x + a.y * b.y + a.z * b.z); }
    [[nodiscard]] constexpr double join(const Point& a,const PlaneIdeal& b) noexcept { return antiWedge(a, b); }
    constexpr double Point::antiWedge(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double Point::join(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const Point& a,const BivectorBulk& b) noexcept { return {
        .x = (a.y * b.xy + a.z * b.xz),
        .y = (a.z * b.yz - a.x * b.xy),
        .z = (-a.x * b.xz - a.y * b.yz)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const Point& a,const BivectorBulk& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal Point::antiWedge(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal Point::join(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const Point& a,const BivectorWeight& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz,
        .w = (a.x * b.wx + a.y * b.wy + a.z * b.wz)
    }; }
    [[nodiscard]] constexpr Plane join(const Point& a,const BivectorWeight& b) noexcept { return antiWedge(a, b); }
    constexpr Plane Point::antiWedge(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane Point::join(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiWedge(const Point& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i,
        .w = b.i
    }; }
    [[nodiscard]] constexpr ProjectivePoint join(const Point& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectivePoint Point::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectivePoint Point::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiWedge(const Point& a,const PointCenter& b) noexcept { return {
        .xy = -a.z,
        .xz = a.y,
        .yz = -a.x
    }; }
    [[nodiscard]] constexpr BivectorBulk join(const Point& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorBulk Point::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorBulk Point::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const PlaneIdeal& a,const Motor& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const PlaneIdeal& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal PlaneIdeal::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal PlaneIdeal::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const PlaneIdeal& a,const ProjectivePoint& b) noexcept { return (-a.x * b.x - a.y * b.y - a.z * b.z); }
    [[nodiscard]] constexpr double join(const PlaneIdeal& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr double PlaneIdeal::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double PlaneIdeal::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const PlaneIdeal& a,const Vector& b) noexcept { return (-a.x * b.x - a.y * b.y - a.z * b.z); }
    [[nodiscard]] constexpr double join(const PlaneIdeal& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr double PlaneIdeal::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double PlaneIdeal::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const PlaneIdeal& a,const Point& b) noexcept { return (-a.x * b.x - a.y * b.y - a.z * b.z); }
    [[nodiscard]] constexpr double join(const PlaneIdeal& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr double PlaneIdeal::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double PlaneIdeal::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const PlaneIdeal& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const PlaneIdeal& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal PlaneIdeal::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal PlaneIdeal::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Quaternion antiWedge(const BivectorBulk& a,const Motor& b) noexcept { return {
        .s = (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy),
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    [[nodiscard]] constexpr Quaternion join(const BivectorBulk& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Quaternion BivectorBulk::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Quaternion BivectorBulk::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const BivectorBulk& a,const Bivector& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const BivectorBulk& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr double BivectorBulk::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double BivectorBulk::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorBulk& a,const ProjectivePoint& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const BivectorBulk& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal BivectorBulk::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal BivectorBulk::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const BivectorBulk& a,const ProjectiveTranslator& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const BivectorBulk& a,const ProjectiveTranslator& b) noexcept { return antiWedge(a, b); }
    constexpr double BivectorBulk::antiWedge(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double BivectorBulk::join(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const BivectorBulk& a,const Translator& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const BivectorBulk& a,const Translator& b) noexcept { return antiWedge(a, b); }
    constexpr double BivectorBulk::antiWedge(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double BivectorBulk::join(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorBulk& a,const Vector& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const BivectorBulk& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal BivectorBulk::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal BivectorBulk::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorBulk& a,const Point& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const BivectorBulk& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal BivectorBulk::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal BivectorBulk::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const BivectorBulk& a,const BivectorWeight& b) noexcept { return (a.xy * b.wz + a.yz * b.wx - a.xz * b.wy); }
    [[nodiscard]] constexpr double join(const BivectorBulk& a,const BivectorWeight& b) noexcept { return antiWedge(a, b); }
    constexpr double BivectorBulk::antiWedge(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double BivectorBulk::join(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiWedge(const BivectorBulk& a,const PseudoScalar& b) noexcept { return {
        .xy = a.xy * b.i,
        .xz = a.xz * b.i,
        .yz = a.yz * b.i
    }; }
    [[nodiscard]] constexpr BivectorBulk join(const BivectorBulk& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorBulk BivectorBulk::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorBulk BivectorBulk::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const BivectorWeight& a,const Motor& b) noexcept { return {
        .s = (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz),
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const BivectorWeight& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator BivectorWeight::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator BivectorWeight::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const BivectorWeight& a,const Bivector& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const BivectorWeight& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr double BivectorWeight::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double BivectorWeight::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const BivectorWeight& a,const ProjectivePoint& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const BivectorWeight& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr Plane BivectorWeight::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane BivectorWeight::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const BivectorWeight& a,const Quaternion& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const BivectorWeight& a,const Quaternion& b) noexcept { return antiWedge(a, b); }
    constexpr double BivectorWeight::antiWedge(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double BivectorWeight::join(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const BivectorWeight& a,const Vector& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const BivectorWeight& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr Plane BivectorWeight::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane BivectorWeight::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const BivectorWeight& a,const Point& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    [[nodiscard]] constexpr Plane join(const BivectorWeight& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr Plane BivectorWeight::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane BivectorWeight::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const BivectorWeight& a,const BivectorBulk& b) noexcept { return (a.wx * b.yz + a.wz * b.xy - a.wy * b.xz); }
    [[nodiscard]] constexpr double join(const BivectorWeight& a,const BivectorBulk& b) noexcept { return antiWedge(a, b); }
    constexpr double BivectorWeight::antiWedge(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double BivectorWeight::join(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorWeight antiWedge(const BivectorWeight& a,const PseudoScalar& b) noexcept { return {
        .wx = a.wx * b.i,
        .wy = a.wy * b.i,
        .wz = a.wz * b.i
    }; }
    [[nodiscard]] constexpr BivectorWeight join(const BivectorWeight& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorWeight BivectorWeight::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorWeight BivectorWeight::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorWeight& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const BivectorWeight& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal BivectorWeight::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal BivectorWeight::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Motor antiWedge(const PseudoScalar& a,const Motor& b) noexcept { return {
        .s = a.i * b.s,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz,
        .i = a.i * b.i
    }; }
    [[nodiscard]] constexpr Motor join(const PseudoScalar& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Motor PseudoScalar::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Motor PseudoScalar::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Plane antiWedge(const PseudoScalar& a,const Plane& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i * b.w
    }; }
    [[nodiscard]] constexpr Plane join(const PseudoScalar& a,const Plane& b) noexcept { return antiWedge(a, b); }
    constexpr Plane PseudoScalar::antiWedge(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Plane PseudoScalar::join(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Bivector antiWedge(const PseudoScalar& a,const Bivector& b) noexcept { return {
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    [[nodiscard]] constexpr Bivector join(const PseudoScalar& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr Bivector PseudoScalar::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Bivector PseudoScalar::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiWedge(const PseudoScalar& a,const ProjectivePoint& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i * b.w
    }; }
    [[nodiscard]] constexpr ProjectivePoint join(const PseudoScalar& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectivePoint PseudoScalar::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectivePoint PseudoScalar::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Quaternion antiWedge(const PseudoScalar& a,const Quaternion& b) noexcept { return {
        .s = a.i * b.s,
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    [[nodiscard]] constexpr Quaternion join(const PseudoScalar& a,const Quaternion& b) noexcept { return antiWedge(a, b); }
    constexpr Quaternion PseudoScalar::antiWedge(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Quaternion PseudoScalar::join(const Quaternion& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const PseudoScalar& a,const ProjectiveTranslator& b) noexcept { return {
        .s = a.i * b.s,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const PseudoScalar& a,const ProjectiveTranslator& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator PseudoScalar::antiWedge(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator PseudoScalar::join(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const PseudoScalar& a,const Translator& b) noexcept { return {
        .s = a.i,
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    [[nodiscard]] constexpr ProjectiveTranslator join(const PseudoScalar& a,const Translator& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectiveTranslator PseudoScalar::antiWedge(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectiveTranslator PseudoScalar::join(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Vector antiWedge(const PseudoScalar& a,const Vector& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z
    }; }
    [[nodiscard]] constexpr Vector join(const PseudoScalar& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr Vector PseudoScalar::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Vector PseudoScalar::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiWedge(const PseudoScalar& a,const Point& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z,
        .w = a.i
    }; }
    [[nodiscard]] constexpr ProjectivePoint join(const PseudoScalar& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectivePoint PseudoScalar::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectivePoint PseudoScalar::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const PseudoScalar& a,const PlaneIdeal& b) noexcept { return {
        .x = a.i * b.x,
        .y = a.i * b.y,
        .z = a.i * b.z
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const PseudoScalar& a,const PlaneIdeal& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal PseudoScalar::antiWedge(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal PseudoScalar::join(const PlaneIdeal& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiWedge(const PseudoScalar& a,const BivectorBulk& b) noexcept { return {
        .xy = a.i * b.xy,
        .xz = a.i * b.xz,
        .yz = a.i * b.yz
    }; }
    [[nodiscard]] constexpr BivectorBulk join(const PseudoScalar& a,const BivectorBulk& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorBulk PseudoScalar::antiWedge(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorBulk PseudoScalar::join(const BivectorBulk& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorWeight antiWedge(const PseudoScalar& a,const BivectorWeight& b) noexcept { return {
        .wx = a.i * b.wx,
        .wy = a.i * b.wy,
        .wz = a.i * b.wz
    }; }
    [[nodiscard]] constexpr BivectorWeight join(const PseudoScalar& a,const BivectorWeight& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorWeight PseudoScalar::antiWedge(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorWeight PseudoScalar::join(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PseudoScalar antiWedge(const PseudoScalar& a,const PseudoScalar& b) noexcept { return {
        .i = a.i * b.i
    }; }
    [[nodiscard]] constexpr PseudoScalar join(const PseudoScalar& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr PseudoScalar PseudoScalar::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PseudoScalar PseudoScalar::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiWedge(const PseudoScalar& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.i
    }; }
    [[nodiscard]] constexpr ProjectivePoint join(const PseudoScalar& a,const PointCenter& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectivePoint PseudoScalar::antiWedge(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectivePoint PseudoScalar::join(const PointCenter& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr Multivector antiWedge(const PointCenter& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = b.i,
        .i = 0.0
    }; }
    [[nodiscard]] constexpr Multivector join(const PointCenter& a,const Motor& b) noexcept { return antiWedge(a, b); }
    constexpr Multivector PointCenter::antiWedge(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr Multivector PointCenter::join(const Motor& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr double antiWedge(const PointCenter& a,const Plane& b) noexcept { return b.w; }
    [[nodiscard]] constexpr double join(const PointCenter& a,const Plane& b) noexcept { return antiWedge(a, b); }
    constexpr double PointCenter::antiWedge(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr double PointCenter::join(const Plane& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& a,const Bivector& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const PointCenter& a,const Bivector& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal PointCenter::antiWedge(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal PointCenter::join(const Bivector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiWedge(const PointCenter& a,const ProjectivePoint& b) noexcept { return {
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    [[nodiscard]] constexpr BivectorBulk join(const PointCenter& a,const ProjectivePoint& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorBulk PointCenter::antiWedge(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorBulk PointCenter::join(const ProjectivePoint& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& a,const ProjectiveTranslator& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const PointCenter& a,const ProjectiveTranslator& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal PointCenter::antiWedge(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal PointCenter::join(const ProjectiveTranslator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& a,const Translator& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const PointCenter& a,const Translator& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal PointCenter::antiWedge(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal PointCenter::join(const Translator& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiWedge(const PointCenter& a,const Vector& b) noexcept { return {
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    [[nodiscard]] constexpr BivectorBulk join(const PointCenter& a,const Vector& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorBulk PointCenter::antiWedge(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorBulk PointCenter::join(const Vector& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr BivectorBulk antiWedge(const PointCenter& a,const Point& b) noexcept { return {
        .xy = b.z,
        .xz = -b.y,
        .yz = b.x
    }; }
    [[nodiscard]] constexpr BivectorBulk join(const PointCenter& a,const Point& b) noexcept { return antiWedge(a, b); }
    constexpr BivectorBulk PointCenter::antiWedge(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr BivectorBulk PointCenter::join(const Point& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& a,const BivectorWeight& b) noexcept { return {
        .x = -b.wx,
        .y = -b.wy,
        .z = -b.wz
    }; }
    [[nodiscard]] constexpr PlaneIdeal join(const PointCenter& a,const BivectorWeight& b) noexcept { return antiWedge(a, b); }
    constexpr PlaneIdeal PointCenter::antiWedge(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr PlaneIdeal PointCenter::join(const BivectorWeight& b) const noexcept { return pga3d::antiWedge(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint antiWedge(const PointCenter& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    [[nodiscard]] constexpr ProjectivePoint join(const PointCenter& a,const PseudoScalar& b) noexcept { return antiWedge(a, b); }
    constexpr ProjectivePoint PointCenter::antiWedge(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }
    constexpr ProjectivePoint PointCenter::join(const PseudoScalar& b) const noexcept { return pga3d::antiWedge(*this, b); }

}

// opsSandwich.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

/**
 * Compiler can reuse constants between calls, where the same object used several times,
 * So in the code below all that constants `const double sMs = s * s` are reused and the code is fast.
 * It is crucial to keep method constexpr or inline to achieve this
 * On my machine this trick speed up `Motor.sandwich(Bivector)` from 9 ns to 3 ns
 * @code
 * const pga3d::Motor& motor = ...
 * for(pga3d::Vector& v: array) {
 *     v = motor.sandwich(v);
 * }
 * @endcode
 */
namespace pga3d {
    [[nodiscard]] constexpr Multivector sandwich(const Multivector&a, const Multivector& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMw = a.s * a.w;
        const double sMx = a.s * a.x;
        const double sMy = a.s * a.y;
        const double sMz = a.s * a.z;
        const double sMwx = a.s * a.wx;
        const double sMwy = a.s * a.wy;
        const double sMwz = a.s * a.wz;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double sMwxy = a.s * a.wxy;
        const double sMwxz = a.s * a.wxz;
        const double sMwyz = a.s * a.wyz;
        const double sMxyz = a.s * a.xyz;
        const double sMi = a.i * a.s;
        const double wMx = a.w * a.x;
        const double wMy = a.w * a.y;
        const double wMz = a.w * a.z;
        const double wMxy = a.w * a.xy;
        const double wMxz = a.w * a.xz;
        const double wMyz = a.w * a.yz;
        const double wMxyz = a.w * a.xyz;
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double xMwx = a.wx * a.x;
        const double xMwy = a.wy * a.x;
        const double xMwz = a.wz * a.x;
        const double xMxy = a.x * a.xy;
        const double xMxz = a.x * a.xz;
        const double xMyz = a.x * a.yz;
        const double xMwxy = a.wxy * a.x;
        const double xMwxz = a.wxz * a.x;
        const double xMwyz = a.wyz * a.x;
        const double xMxyz = a.x * a.xyz;
        const double xMi = a.i * a.x;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double yMwx = a.wx * a.y;
        const double yMwy = a.wy * a.y;
        const double yMwz = a.wz * a.y;
        const double yMxy = a.xy * a.y;
        const double yMxz = a.xz * a.y;
        const double yMyz = a.y * a.yz;
        const double yMwxy = a.wxy * a.y;
        const double yMwxz = a.wxz * a.y;
        const double yMwyz = a.wyz * a.y;
        const double yMxyz = a.xyz * a.y;
        const double yMi = a.i * a.y;
        const double zMz = a.z * a.z;
        const double zMwx = a.wx * a.z;
        const double zMwy = a.wy * a.z;
        const double zMwz = a.wz * a.z;
        const double zMxy = a.xy * a.z;
        const double zMxz = a.xz * a.z;
        const double zMyz = a.yz * a.z;
        const double zMwxy = a.wxy * a.z;
        const double zMwxz = a.wxz * a.z;
        const double zMwyz = a.wyz * a.z;
        const double zMxyz = a.xyz * a.z;
        const double zMi = a.i * a.z;
        const double wxMxy = a.wx * a.xy;
        const double wxMxz = a.wx * a.xz;
        const double wxMyz = a.wx * a.yz;
        const double wxMxyz = a.wx * a.xyz;
        const double wyMxy = a.wy * a.xy;
        const double wyMxz = a.wy * a.xz;
        const double wyMyz = a.wy * a.yz;
        const double wyMxyz = a.wy * a.xyz;
        const double wzMxy = a.wz * a.xy;
        const double wzMxz = a.wz * a.xz;
        const double wzMyz = a.wz * a.yz;
        const double wzMxyz = a.wz * a.xyz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xyMwxy = a.wxy * a.xy;
        const double xyMwxz = a.wxz * a.xy;
        const double xyMwyz = a.wyz * a.xy;
        const double xyMxyz = a.xy * a.xyz;
        const double xyMi = a.i * a.xy;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double xzMwxy = a.wxy * a.xz;
        const double xzMwxz = a.wxz * a.xz;
        const double xzMwyz = a.wyz * a.xz;
        const double xzMxyz = a.xyz * a.xz;
        const double xzMi = a.i * a.xz;
        const double yzMyz = a.yz * a.yz;
        const double yzMwxy = a.wxy * a.yz;
        const double yzMwxz = a.wxz * a.yz;
        const double yzMwyz = a.wyz * a.yz;
        const double yzMxyz = a.xyz * a.yz;
        const double yzMi = a.i * a.yz;
        const double wxyMxyz = a.wxy * a.xyz;
        const double wxzMxyz = a.wxz * a.xyz;
        const double wyzMxyz = a.wyz * a.xyz;
        const double xyzMxyz = a.xyz * a.xyz;
        const double xyzMi = a.i * a.xyz;
        return {
            .s = (2.0 * (b.x * (sMx + yzMxyz - yMxy - zMxz) + b.y * (sMy + xMxy - xzMxyz - zMyz) + b.z * (sMz + xMxz + xyMxyz + yMyz)) + b.s * (sMs + xMx + xyMxy + xyzMxyz + xzMxz + yMy + yzMyz + zMz)),
            .w = (2.0 * (b.i * (sMxyz + yMxz - xMyz - zMxy) + b.s * (sMw + xMwx + xyMwxy + xyzMi + xzMwxz + yMwy + yzMwyz + zMwz) + b.x * (sMwx + wMx + wyzMxyz + yzMi - wyMxy - wzMxz - yMwxy - zMwxz) + b.y * (sMwy + wMy + wxMxy + xMwxy - wxzMxyz - wzMyz - xzMi - zMwyz) + b.z * (sMwz + wMz + wxMxz + wxyMxyz + wyMyz + xMwxz + xyMi + yMwyz)) + b.w * (sMs + xyMxy + xzMxz + yzMyz - xMx - xyzMxyz - yMy - zMz)),
            .x = (2.0 * (b.s * (sMx + yMxy + yzMxyz + zMxz) + b.y * (sMxy + xMy - xzMyz - zMxyz) + b.z * (sMxz + xMz + xyMyz + yMxyz)) + b.x * (sMs + xMx + xyzMxyz + yzMyz - xyMxy - xzMxz - yMy - zMz)),
            .y = (2.0 * (b.s * (sMy + zMyz - xMxy - xzMxyz) + b.x * (xMy + zMxyz - sMxy - xzMyz) + b.z * (sMyz + yMz - xMxyz - xyMxz)) + b.y * (sMs + xyzMxyz + xzMxz + yMy - xMx - xyMxy - yzMyz - zMz)),
            .z = (2.0 * (b.s * (sMz + xyMxyz - xMxz - yMyz) + b.x * (xMz + xyMyz - sMxz - yMxyz) + b.y * (xMxyz + yMz - sMyz - xyMxz)) + b.z * (sMs + xyMxy + xyzMxyz + zMz - xMx - xzMxz - yMy - yzMyz)),
            .wx = (2.0 * (b.wxy * (sMy + xzMxyz - xMxy - zMyz) + b.wxz * (sMz + yMyz - xMxz - xyMxyz) + b.wy * (sMxy + zMxyz - xMy - xzMyz) + b.wyz * (sMxyz + zMxy - xMyz - yMxz) + b.wz * (sMxz + xyMyz - xMz - yMxyz) + b.xy * (wMy + wxMxy + wxzMxyz + wzMyz - sMwy - xMwxy - xzMi - zMwyz) + b.xyz * (wMyz + wxMxyz + xyMwxz + yMwz - sMwyz - xMi - xzMwxy - zMwy) + b.xz * (wMz + wxMxz + xyMi + yMwyz - sMwz - wxyMxyz - wyMyz - xMwxz) + b.yz * (wMxyz + wxMyz + wyMxz + zMwxy - sMi - wzMxy - xMwyz - yMwxz)) + b.wx * (sMs + yMy + yzMyz + zMz - xMx - xyMxy - xyzMxyz - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xMy - xzMyz - zMxyz) + b.wxy * (yzMxyz + zMxz - sMx - yMxy) + b.wxz * (-sMxyz - xMyz - yMxz - zMxy) + b.wyz * (sMz + xMxz - xyMxyz - yMyz) + b.wz * (sMyz + xMxyz - xyMxz - yMz) + b.xy * (sMwx + wyMxy + wyzMxyz + zMwxz - wMx - wzMxz - yMwxy - yzMi) + b.xyz * (sMwxz + wyMxyz + xyMwyz + zMwx - wMxz - xMwz - yMi - yzMwxy) + b.xz * (sMi + wxMyz + wyMxz + wzMxy - wMxyz - xMwyz - yMwxz - zMwxy) + b.yz * (wMz + wyMyz + xMwxz + xyMi - sMwz - wxMxz - wxyMxyz - yMwyz)) + b.wy * (sMs + xMx + xzMxz + zMz - xyMxy - xyzMxyz - yMy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz + yMxyz - sMxz - xMz) + b.wxy * (sMxyz + xMyz - yMxz - zMxy) + b.wxz * (yMxy + yzMxyz - sMx - zMxz) + b.wy * (-sMyz - xMxyz - xyMxz - yMz) + b.wyz * (-sMy - xMxy - xzMxyz - zMyz) + b.xy * (wMxyz + wyMxz + wzMxy + xMwyz - sMi - wxMyz - yMwxz - zMwxy) + b.xyz * (wMxy + wzMxyz + xMwy + xzMwyz - sMwxy - yMwx - yzMwxz - zMi) + b.xz * (sMwx + wyzMxyz + wzMxz + yMwxy - wMx - wyMxy - yzMi - zMwxz) + b.yz * (sMwy + wxMxy + wzMyz + xzMi - wMy - wxzMxyz - xMwxy - zMwyz)) + b.wz * (sMs + xMx + xyMxy + yMy - xyzMxyz - xzMxz - yzMyz - zMz)),
            .xy = (2.0 * (b.xyz * (sMz + xyMxyz - xMxz - yMyz) + b.xz * (sMyz + xyMxz - xMxyz - yMz) + b.yz * (xMz + xyMyz - sMxz - yMxyz)) + b.xy * (sMs + xyMxy + xyzMxyz + zMz - xMx - xzMxz - yMy - yzMyz)),
            .xz = (2.0 * (b.xy * (xMxyz + xyMxz - sMyz - yMz) + b.xyz * (xMxy + xzMxyz - sMy - zMyz) + b.yz * (sMxy + xzMyz - xMy - zMxyz)) + b.xz * (sMs + xyzMxyz + xzMxz + yMy - xMx - xyMxy - yzMyz - zMz)),
            .yz = (2.0 * (b.xy * (sMxz + xMz + xyMyz + yMxyz) + b.xyz * (sMx + yMxy + yzMxyz + zMxz) + b.xz * (xzMyz + zMxyz - sMxy - xMy)) + b.yz * (sMs + xMx + xyzMxyz + yzMyz - xyMxy - xzMxz - yMy - zMz)),
            .wxy = (2.0 * (b.wx * (sMy + xMxy + xzMxyz + zMyz) + b.wxz * (sMyz + xMxyz + xyMxz + yMz) + b.wy * (yMxy + yzMxyz - sMx - zMxz) + b.wyz * (xyMyz + yMxyz - sMxz - xMz) + b.wz * (yMxz + zMxy - sMxyz - xMyz) + b.xy * (sMw + xyMwxy + xyzMi + zMwz - xMwx - xzMwxz - yMwy - yzMwyz) + b.xyz * (sMwz + wMz + wxyMxyz + xyMi - wxMxz - wyMyz - xMwxz - yMwyz) + b.xz * (sMwyz + wMyz + xyMwxz + xzMwxy - wxMxyz - xMi - yMwz - zMwy) + b.yz * (xMwz + xyMwyz + yzMwxy + zMwx - sMwxz - wMxz - wyMxyz - yMi)) + b.wxy * (sMs + xMx + xyMxy + yMy - xyzMxyz - xzMxz - yzMyz - zMz)),
            .wxz = (2.0 * (b.wx * (sMz + xMxz - xyMxyz - yMyz) + b.wxy * (xyMxz + yMz - sMyz - xMxyz) + b.wy * (sMxyz + xMyz + yMxz + zMxy) + b.wyz * (sMxy + xMy + xzMyz + zMxyz) + b.wz * (yzMxyz + zMxz - sMx - yMxy) + b.xy * (wxMxyz + xMi + xyMwxz + xzMwxy - sMwyz - wMyz - yMwz - zMwy) + b.xyz * (wxMxy + wxzMxyz + xMwxy + xzMi - sMwy - wMy - wzMyz - zMwyz) + b.xz * (sMw + xyzMi + xzMwxz + yMwy - xMwx - xyMwxy - yzMwyz - zMwz) + b.yz * (sMwxy + wMxy + xzMwyz + yzMwxz - wzMxyz - xMwy - yMwx - zMi)) + b.wxz * (sMs + xMx + xzMxz + zMz - xyMxy - xyzMxyz - yMy - yzMyz)),
            .wyz = (2.0 * (b.wx * (xMyz + yMxz - sMxyz - zMxy) + b.wxy * (sMxz + xyMyz - xMz - yMxyz) + b.wxz * (xMy + xzMyz - sMxy - zMxyz) + b.wy * (sMz + yMyz - xMxz - xyMxyz) + b.wz * (xMxy + zMyz - sMy - xzMxyz) + b.xy * (sMwxz + wMxz + wyMxyz + xMwz + xyMwyz + yMi + yzMwxy + zMwx) + b.xyz * (sMwx + wMx + wyMxy + wyzMxyz + wzMxz + yMwxy + yzMi + zMwxz) + b.xz * (wzMxyz + xzMwyz + yzMwxz + zMi - sMwxy - wMxy - xMwy - yMwx) + b.yz * (sMw + xMwx + xyzMi + yzMwyz - xyMwxy - xzMwxz - yMwy - zMwz)) + b.wyz * (sMs + yMy + yzMyz + zMz - xMx - xyMxy - xyzMxyz - xzMxz)),
            .xyz = (2.0 * (b.xy * (sMz + xMxz + xyMxyz + yMyz) + b.xz * (xzMxyz + zMyz - sMy - xMxy) + b.yz * (sMx + yzMxyz - yMxy - zMxz)) + b.xyz * (sMs + xMx + xyMxy + xyzMxyz + xzMxz + yMy + yzMyz + zMz)),
            .i = (2.0 * (b.s * (sMi + wyMxz + xMwyz + zMwxy - wMxyz - wxMyz - wzMxy - yMwxz) + b.w * (xMyz + zMxy - sMxyz - yMxz) + b.x * (sMwyz + xMi + xyMwxz + yMwz - wMyz - wxMxyz - xzMwxy - zMwy) + b.y * (wMxz + xyMwyz + yMi + zMwx - sMwxz - wyMxyz - xMwz - yzMwxy) + b.z * (sMwxy + xMwy + xzMwyz + zMi - wMxy - wzMxyz - yMwx - yzMwxz)) + b.i * (sMs + xyMxy + xzMxz + yzMyz - xMx - xyzMxyz - yMy - zMz))
        };
    }
    constexpr Multivector Multivector::sandwich(const Multivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Motor&a, const Motor& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMwx = a.s * a.wx;
        const double sMwy = a.s * a.wy;
        const double sMwz = a.s * a.wz;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double sMi = a.i * a.s;
        const double wxMxy = a.wx * a.xy;
        const double wxMxz = a.wx * a.xz;
        const double wxMyz = a.wx * a.yz;
        const double wyMxy = a.wy * a.xy;
        const double wyMxz = a.wy * a.xz;
        const double wyMyz = a.wy * a.yz;
        const double wzMxy = a.wz * a.xy;
        const double wzMxz = a.wz * a.xz;
        const double wzMyz = a.wz * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xyMi = a.i * a.xy;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double xzMi = a.i * a.xz;
        const double yzMyz = a.yz * a.yz;
        const double yzMi = a.i * a.yz;
        return {
            .s = b.s * (sMs + xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz) + b.xy * (wxMxy + wzMyz - sMwy - xzMi) + b.xz * (wxMxz + xyMi - sMwz - wyMyz) + b.yz * (wxMyz + wyMxz - sMi - wzMxy)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz) + b.xy * (sMwx + wyMxy - wzMxz - yzMi) + b.xz * (sMi + wxMyz + wyMxz + wzMxy) + b.yz * (wyMyz + xyMi - sMwz - wxMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz) + b.xy * (wyMxz + wzMxy - sMi - wxMyz) + b.xz * (sMwx + wzMxz - wyMxy - yzMi) + b.yz * (sMwy + wxMxy + wzMyz + xzMi)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz)),
            .xy = (2.0 * (b.xz * (sMyz + xyMxz) + b.yz * (xyMyz - sMxz)) + b.xy * (sMs + xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * (xyMxz - sMyz) + b.yz * (sMxy + xzMyz)) + b.xz * (sMs + xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * (sMxz + xyMyz) + b.xz * (xzMyz - sMxy)) + b.yz * (sMs + yzMyz - xyMxy - xzMxz)),
            .i = (b.i * (sMs + xyMxy + xzMxz + yzMyz) + 2.0 * b.s * (sMi + wyMxz - wxMyz - wzMxy))
        };
    }
    constexpr Motor Motor::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Motor&a, const Plane& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz)) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz)) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz)) + b.z * (sMs + xyMxy - xzMxz - yzMyz)),
            .w = (2.0 * (b.x * (a.i * a.yz + a.s * a.wx - a.wy * a.xy - a.wz * a.xz) + b.y * (a.s * a.wy + a.wx * a.xy - a.i * a.xz - a.wz * a.yz) + b.z * (a.i * a.xy + a.s * a.wz + a.wx * a.xz + a.wy * a.yz)) + b.w * (sMs + xyMxy + xzMxz + yzMyz))
        };
    }
    constexpr Plane Motor::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Motor&a, const Bivector& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMwx = a.s * a.wx;
        const double sMwy = a.s * a.wy;
        const double sMwz = a.s * a.wz;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double sMi = a.i * a.s;
        const double wxMxy = a.wx * a.xy;
        const double wxMxz = a.wx * a.xz;
        const double wxMyz = a.wx * a.yz;
        const double wyMxy = a.wy * a.xy;
        const double wyMxz = a.wy * a.xz;
        const double wyMyz = a.wy * a.yz;
        const double wzMxy = a.wz * a.xy;
        const double wzMxz = a.wz * a.xz;
        const double wzMyz = a.wz * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xyMi = a.i * a.xy;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double xzMi = a.i * a.xz;
        const double yzMyz = a.yz * a.yz;
        const double yzMi = a.i * a.yz;
        return {
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz) + b.xy * (wxMxy + wzMyz - sMwy - xzMi) + b.xz * (wxMxz + xyMi - sMwz - wyMyz) + b.yz * (wxMyz + wyMxz - sMi - wzMxy)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz) + b.xy * (sMwx + wyMxy - wzMxz - yzMi) + b.xz * (sMi + wxMyz + wyMxz + wzMxy) + b.yz * (wyMyz + xyMi - sMwz - wxMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz) + b.xy * (wyMxz + wzMxy - sMi - wxMyz) + b.xz * (sMwx + wzMxz - wyMxy - yzMi) + b.yz * (sMwy + wxMxy + wzMyz + xzMi)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz)),
            .xy = (2.0 * (b.xz * (sMyz + xyMxz) + b.yz * (xyMyz - sMxz)) + b.xy * (sMs + xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * (xyMxz - sMyz) + b.yz * (sMxy + xzMyz)) + b.xz * (sMs + xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * (sMxz + xyMyz) + b.xz * (xzMyz - sMxy)) + b.yz * (sMs + yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr Bivector Motor::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Motor&a, const ProjectivePoint& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.w * (-a.i * a.yz - a.s * a.wx - a.wy * a.xy - a.wz * a.xz) + b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz)) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.w * (a.i * a.xz + a.wx * a.xy - a.s * a.wy - a.wz * a.yz) + b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz)) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.w * (a.wx * a.xz + a.wy * a.yz - a.i * a.xy - a.s * a.wz) + b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz)) + b.z * (sMs + xyMxy - xzMxz - yzMyz)),
            .w = b.w * (sMs + xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr ProjectivePoint Motor::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Motor&a, const Quaternion& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMwx = a.s * a.wx;
        const double sMwy = a.s * a.wy;
        const double sMwz = a.s * a.wz;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double sMi = a.i * a.s;
        const double wxMxy = a.wx * a.xy;
        const double wxMxz = a.wx * a.xz;
        const double wxMyz = a.wx * a.yz;
        const double wyMxy = a.wy * a.xy;
        const double wyMxz = a.wy * a.xz;
        const double wyMyz = a.wy * a.yz;
        const double wzMxy = a.wz * a.xy;
        const double wzMxz = a.wz * a.xz;
        const double wzMyz = a.wz * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xyMi = a.i * a.xy;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double xzMi = a.i * a.xz;
        const double yzMyz = a.yz * a.yz;
        const double yzMi = a.i * a.yz;
        return {
            .s = b.s * (sMs + xyMxy + xzMxz + yzMyz),
            .wx = 2.0 * (b.xy * (wxMxy + wzMyz - sMwy - xzMi) + b.xz * (wxMxz + xyMi - sMwz - wyMyz) + b.yz * (wxMyz + wyMxz - sMi - wzMxy)),
            .wy = 2.0 * (b.xy * (sMwx + wyMxy - wzMxz - yzMi) + b.xz * (sMi + wxMyz + wyMxz + wzMxy) + b.yz * (wyMyz + xyMi - sMwz - wxMxz)),
            .wz = 2.0 * (b.xy * (wyMxz + wzMxy - sMi - wxMyz) + b.xz * (sMwx + wzMxz - wyMxy - yzMi) + b.yz * (sMwy + wxMxy + wzMyz + xzMi)),
            .xy = (2.0 * (b.xz * (sMyz + xyMxz) + b.yz * (xyMyz - sMxz)) + b.xy * (sMs + xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * (xyMxz - sMyz) + b.yz * (sMxy + xzMyz)) + b.xz * (sMs + xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * (sMxz + xyMyz) + b.xz * (xzMyz - sMxy)) + b.yz * (sMs + yzMyz - xyMxy - xzMxz)),
            .i = 2.0 * b.s * (sMi + wyMxz - wxMyz - wzMxy)
        };
    }
    constexpr Motor Motor::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Motor&a, const ProjectiveTranslator& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (sMs + xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz)),
            .xy = 0.0,
            .xz = 0.0,
            .yz = 0.0,
            .i = 2.0 * b.s * (a.i * a.s + a.wy * a.xz - a.wx * a.yz - a.wz * a.xy)
        };
    }
    constexpr Motor Motor::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Motor&a, const Translator& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = (sMs + xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz)),
            .xy = 0.0,
            .xz = 0.0,
            .yz = 0.0,
            .i = 2.0 * (a.i * a.s + a.wy * a.xz - a.wx * a.yz - a.wz * a.xy)
        };
    }
    constexpr Motor Motor::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const Motor&a, const Vector& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz)) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz)) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz)) + b.z * (sMs + xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr Vector Motor::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Motor&a, const Point& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz) - a.i * a.yz - a.s * a.wx - a.wy * a.xy - a.wz * a.xz) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (a.i * a.xz + a.wx * a.xy + b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz) - a.s * a.wy - a.wz * a.yz) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (a.wx * a.xz + a.wy * a.yz + b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz) - a.i * a.xy - a.s * a.wz) + b.z * (sMs + xyMxy - xzMxz - yzMyz)),
            .w = (sMs + xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr ProjectivePoint Motor::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Motor&a, const PlaneIdeal& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz)) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz)) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz)) + b.z * (sMs + xyMxy - xzMxz - yzMyz)),
            .w = 2.0 * (b.x * (a.i * a.yz + a.s * a.wx - a.wy * a.xy - a.wz * a.xz) + b.y * (a.s * a.wy + a.wx * a.xy - a.i * a.xz - a.wz * a.yz) + b.z * (a.i * a.xy + a.s * a.wz + a.wx * a.xz + a.wy * a.yz))
        };
    }
    constexpr Plane Motor::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Motor&a, const BivectorBulk& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMwx = a.s * a.wx;
        const double sMwy = a.s * a.wy;
        const double sMwz = a.s * a.wz;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double sMi = a.i * a.s;
        const double wxMxy = a.wx * a.xy;
        const double wxMxz = a.wx * a.xz;
        const double wxMyz = a.wx * a.yz;
        const double wyMxy = a.wy * a.xy;
        const double wyMxz = a.wy * a.xz;
        const double wyMyz = a.wy * a.yz;
        const double wzMxy = a.wz * a.xy;
        const double wzMxz = a.wz * a.xz;
        const double wzMyz = a.wz * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xyMi = a.i * a.xy;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double xzMi = a.i * a.xz;
        const double yzMyz = a.yz * a.yz;
        const double yzMi = a.i * a.yz;
        return {
            .wx = 2.0 * (b.xy * (wxMxy + wzMyz - sMwy - xzMi) + b.xz * (wxMxz + xyMi - sMwz - wyMyz) + b.yz * (wxMyz + wyMxz - sMi - wzMxy)),
            .wy = 2.0 * (b.xy * (sMwx + wyMxy - wzMxz - yzMi) + b.xz * (sMi + wxMyz + wyMxz + wzMxy) + b.yz * (wyMyz + xyMi - sMwz - wxMxz)),
            .wz = 2.0 * (b.xy * (wyMxz + wzMxy - sMi - wxMyz) + b.xz * (sMwx + wzMxz - wyMxy - yzMi) + b.yz * (sMwy + wxMxy + wzMyz + xzMi)),
            .xy = (2.0 * (b.xz * (sMyz + xyMxz) + b.yz * (xyMyz - sMxz)) + b.xy * (sMs + xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * (xyMxz - sMyz) + b.yz * (sMxy + xzMyz)) + b.xz * (sMs + xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * (sMxz + xyMyz) + b.xz * (xzMyz - sMxy)) + b.yz * (sMs + yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr Bivector Motor::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const Motor&a, const BivectorWeight& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr BivectorWeight Motor::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const Motor&a, const PseudoScalar& b) noexcept {
        return {
            .i = b.i * (a.s * a.s + a.xy * a.xy + a.xz * a.xz + a.yz * a.yz)
        };
    }
    constexpr PseudoScalar Motor::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Motor&a, const PointCenter& b) noexcept {
        return {
            .x = 2.0 * (-a.i * a.yz - a.s * a.wx - a.wy * a.xy - a.wz * a.xz),
            .y = 2.0 * (a.i * a.xz + a.wx * a.xy - a.s * a.wy - a.wz * a.yz),
            .z = 2.0 * (a.wx * a.xz + a.wy * a.yz - a.i * a.xy - a.s * a.wz),
            .w = (a.s * a.s + a.xy * a.xy + a.xz * a.xz + a.yz * a.yz)
        };
    }
    constexpr ProjectivePoint Motor::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Plane&a, const Motor& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double xMw = a.w * a.x;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double yMw = a.w * a.y;
        const double zMz = a.z * a.z;
        const double zMw = a.w * a.z;
        return {
            .s = b.s * (xMx + yMy + zMz),
            .wx = (2.0 * (b.xy * yMw + b.xz * zMw - b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (b.yz * zMw - b.wx * xMy - b.wz * yMz - b.xy * xMw) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz - b.xz * xMw - b.yz * yMw) + b.wz * (xMx + yMy - zMz)),
            .xy = (2.0 * (b.yz * xMz - b.xz * yMz) + b.xy * (zMz - xMx - yMy)),
            .xz = (2.0 * (-b.xy * yMz - b.yz * xMy) + b.xz * (yMy - xMx - zMz)),
            .yz = (2.0 * (b.xy * xMz - b.xz * xMy) + b.yz * (xMx - yMy - zMz)),
            .i = b.i * (-xMx - yMy - zMz)
        };
    }
    constexpr Motor Plane::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Plane&a, const Plane& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (b.y * xMy + b.z * xMz) + b.x * (xMx - yMy - zMz)),
            .y = (2.0 * (b.x * xMy + b.z * yMz) + b.y * (yMy - xMx - zMz)),
            .z = (2.0 * (b.x * xMz + b.y * yMz) + b.z * (zMz - xMx - yMy)),
            .w = (b.w * (-xMx - yMy - zMz) + 2.0 * a.w * (a.x * b.x + a.y * b.y + a.z * b.z))
        };
    }
    constexpr Plane Plane::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Plane&a, const Bivector& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double xMw = a.w * a.x;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double yMw = a.w * a.y;
        const double zMz = a.z * a.z;
        const double zMw = a.w * a.z;
        return {
            .wx = (2.0 * (b.xy * yMw + b.xz * zMw - b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (b.yz * zMw - b.wx * xMy - b.wz * yMz - b.xy * xMw) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz - b.xz * xMw - b.yz * yMw) + b.wz * (xMx + yMy - zMz)),
            .xy = (2.0 * (b.yz * xMz - b.xz * yMz) + b.xy * (zMz - xMx - yMy)),
            .xz = (2.0 * (-b.xy * yMz - b.yz * xMy) + b.xz * (yMy - xMx - zMz)),
            .yz = (2.0 * (b.xy * xMz - b.xz * xMy) + b.yz * (xMx - yMy - zMz))
        };
    }
    constexpr Bivector Plane::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Plane&a, const ProjectivePoint& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (-b.y * xMy - b.z * xMz - a.w * a.x * b.w) + b.x * (yMy + zMz - xMx)),
            .y = (2.0 * (-b.x * xMy - b.z * yMz - a.w * a.y * b.w) + b.y * (xMx + zMz - yMy)),
            .z = (2.0 * (-b.x * xMz - b.y * yMz - a.w * a.z * b.w) + b.z * (xMx + yMy - zMz)),
            .w = b.w * (xMx + yMy + zMz)
        };
    }
    constexpr ProjectivePoint Plane::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Plane&a, const Quaternion& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double xMw = a.w * a.x;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double yMw = a.w * a.y;
        const double zMz = a.z * a.z;
        const double zMw = a.w * a.z;
        return {
            .s = b.s * (xMx + yMy + zMz),
            .wx = 2.0 * (b.xy * yMw + b.xz * zMw),
            .wy = 2.0 * (b.yz * zMw - b.xy * xMw),
            .wz = 2.0 * (-b.xz * xMw - b.yz * yMw),
            .xy = (2.0 * (b.yz * xMz - b.xz * yMz) + b.xy * (zMz - xMx - yMy)),
            .xz = (2.0 * (-b.xy * yMz - b.yz * xMy) + b.xz * (yMy - xMx - zMz)),
            .yz = (2.0 * (b.xy * xMz - b.xz * xMy) + b.yz * (xMx - yMy - zMz)),
            .i = 0.0
        };
    }
    constexpr Motor Plane::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Plane&a, const ProjectiveTranslator& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .s = b.s * (xMx + yMy + zMz),
            .wx = (2.0 * (-b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (-b.wx * xMy - b.wz * yMz) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz) + b.wz * (xMx + yMy - zMz))
        };
    }
    constexpr ProjectiveTranslator Plane::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Plane&a, const Translator& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .s = (xMx + yMy + zMz),
            .wx = (2.0 * (-b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (-b.wx * xMy - b.wz * yMz) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz) + b.wz * (xMx + yMy - zMz))
        };
    }
    constexpr ProjectiveTranslator Plane::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const Plane&a, const Vector& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (-b.y * xMy - b.z * xMz) + b.x * (yMy + zMz - xMx)),
            .y = (2.0 * (-b.x * xMy - b.z * yMz) + b.y * (xMx + zMz - yMy)),
            .z = (2.0 * (-b.x * xMz - b.y * yMz) + b.z * (xMx + yMy - zMz))
        };
    }
    constexpr Vector Plane::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Plane&a, const Point& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (-a.w * a.x - b.y * xMy - b.z * xMz) + b.x * (yMy + zMz - xMx)),
            .y = (2.0 * (-a.w * a.y - b.x * xMy - b.z * yMz) + b.y * (xMx + zMz - yMy)),
            .z = (2.0 * (-a.w * a.z - b.x * xMz - b.y * yMz) + b.z * (xMx + yMy - zMz)),
            .w = (xMx + yMy + zMz)
        };
    }
    constexpr ProjectivePoint Plane::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Plane&a, const PlaneIdeal& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (b.y * xMy + b.z * xMz) + b.x * (xMx - yMy - zMz)),
            .y = (2.0 * (b.x * xMy + b.z * yMz) + b.y * (yMy - xMx - zMz)),
            .z = (2.0 * (b.x * xMz + b.y * yMz) + b.z * (zMz - xMx - yMy)),
            .w = 2.0 * a.w * (a.x * b.x + a.y * b.y + a.z * b.z)
        };
    }
    constexpr Plane Plane::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Plane&a, const BivectorBulk& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double xMw = a.w * a.x;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double yMw = a.w * a.y;
        const double zMz = a.z * a.z;
        const double zMw = a.w * a.z;
        return {
            .wx = 2.0 * (b.xy * yMw + b.xz * zMw),
            .wy = 2.0 * (b.yz * zMw - b.xy * xMw),
            .wz = 2.0 * (-b.xz * xMw - b.yz * yMw),
            .xy = (2.0 * (b.yz * xMz - b.xz * yMz) + b.xy * (zMz - xMx - yMy)),
            .xz = (2.0 * (-b.xy * yMz - b.yz * xMy) + b.xz * (yMy - xMx - zMz)),
            .yz = (2.0 * (b.xy * xMz - b.xz * xMy) + b.yz * (xMx - yMy - zMz))
        };
    }
    constexpr Bivector Plane::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const Plane&a, const BivectorWeight& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .wx = (2.0 * (-b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (-b.wx * xMy - b.wz * yMz) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz) + b.wz * (xMx + yMy - zMz))
        };
    }
    constexpr BivectorWeight Plane::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const Plane&a, const PseudoScalar& b) noexcept {
        return {
            .i = b.i * (-a.x * a.x - a.y * a.y - a.z * a.z)
        };
    }
    constexpr PseudoScalar Plane::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Plane&a, const PointCenter& b) noexcept {
        return {
            .x = -2.0 * a.w * a.x,
            .y = -2.0 * a.w * a.y,
            .z = -2.0 * a.w * a.z,
            .w = (a.x * a.x + a.y * a.y + a.z * a.z)
        };
    }
    constexpr ProjectivePoint Plane::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Bivector&a, const Motor& b) noexcept {
        const double wxMxy = a.wx * a.xy;
        const double wxMxz = a.wx * a.xz;
        const double wxMyz = a.wx * a.yz;
        const double wyMxy = a.wy * a.xy;
        const double wyMxz = a.wy * a.xz;
        const double wyMyz = a.wy * a.yz;
        const double wzMxy = a.wz * a.xy;
        const double wzMxz = a.wz * a.xz;
        const double wzMyz = a.wz * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wz * xyMyz + b.xy * (wxMxy + wzMyz) + b.xz * (wxMxz - wyMyz) + b.yz * (wxMyz + wyMxz - wzMxy) - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.xy * (wyMxy - wzMxz) + b.xz * (wxMyz + wyMxz + wzMxy) + b.yz * (wyMyz - wxMxz) - b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz + b.xy * (wyMxz + wzMxy - wxMyz) + b.xz * (wzMxz - wyMxy) + b.yz * (wxMxy + wzMyz) - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz)),
            .xy = (2.0 * (b.xz * xyMxz + b.yz * xyMyz) + b.xy * (xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * xyMxz + b.yz * xzMyz) + b.xz * (xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * xyMyz + b.xz * xzMyz) + b.yz * (yzMyz - xyMxy - xzMxz)),
            .i = (b.i * (xyMxy + xzMxz + yzMyz) + 2.0 * b.s * (wyMxz - wxMyz - wzMxy))
        };
    }
    constexpr Motor Bivector::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Bivector&a, const Plane& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.z * xyMyz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (-b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz)),
            .w = (2.0 * (a.wx * (a.xy * b.y + a.xz * b.z) + a.wy * (a.yz * b.z - a.xy * b.x) + a.wz * (-a.xz * b.x - a.yz * b.y)) + b.w * (xyMxy + xzMxz + yzMyz))
        };
    }
    constexpr Plane Bivector::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Bivector&a, const Bivector& b) noexcept {
        const double wxMxy = a.wx * a.xy;
        const double wxMxz = a.wx * a.xz;
        const double wxMyz = a.wx * a.yz;
        const double wyMxy = a.wy * a.xy;
        const double wyMxz = a.wy * a.xz;
        const double wyMyz = a.wy * a.yz;
        const double wzMxy = a.wz * a.xy;
        const double wzMxz = a.wz * a.xz;
        const double wzMyz = a.wz * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .wx = (2.0 * (b.wz * xyMyz + b.xy * (wxMxy + wzMyz) + b.xz * (wxMxz - wyMyz) + b.yz * (wxMyz + wyMxz - wzMxy) - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.xy * (wyMxy - wzMxz) + b.xz * (wxMyz + wyMxz + wzMxy) + b.yz * (wyMyz - wxMxz) - b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz + b.xy * (wyMxz + wzMxy - wxMyz) + b.xz * (wzMxz - wyMxy) + b.yz * (wxMxy + wzMyz) - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz)),
            .xy = (2.0 * (b.xz * xyMxz + b.yz * xyMyz) + b.xy * (xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * xyMxz + b.yz * xzMyz) + b.xz * (xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * xyMyz + b.xz * xzMyz) + b.yz * (yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr Bivector Bivector::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Bivector&a, const ProjectivePoint& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.w * (-a.wy * a.xy - a.wz * a.xz) + b.z * xyMyz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.w * (a.wx * a.xy - a.wz * a.yz) - b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.w * (a.wx * a.xz + a.wy * a.yz) + b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz)),
            .w = b.w * (xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr ProjectivePoint Bivector::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Bivector&a, const Quaternion& b) noexcept {
        const double wxMxy = a.wx * a.xy;
        const double wxMxz = a.wx * a.xz;
        const double wxMyz = a.wx * a.yz;
        const double wyMxy = a.wy * a.xy;
        const double wyMxz = a.wy * a.xz;
        const double wyMyz = a.wy * a.yz;
        const double wzMxy = a.wz * a.xy;
        const double wzMxz = a.wz * a.xz;
        const double wzMyz = a.wz * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (xyMxy + xzMxz + yzMyz),
            .wx = 2.0 * (b.xy * (wxMxy + wzMyz) + b.xz * (wxMxz - wyMyz) + b.yz * (wxMyz + wyMxz - wzMxy)),
            .wy = 2.0 * (b.xy * (wyMxy - wzMxz) + b.xz * (wxMyz + wyMxz + wzMxy) + b.yz * (wyMyz - wxMxz)),
            .wz = 2.0 * (b.xy * (wyMxz + wzMxy - wxMyz) + b.xz * (wzMxz - wyMxy) + b.yz * (wxMxy + wzMyz)),
            .xy = (2.0 * (b.xz * xyMxz + b.yz * xyMyz) + b.xy * (xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * xyMxz + b.yz * xzMyz) + b.xz * (xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * xyMyz + b.xz * xzMyz) + b.yz * (yzMyz - xyMxy - xzMxz)),
            .i = 2.0 * b.s * (wyMxz - wxMyz - wzMxy)
        };
    }
    constexpr Motor Bivector::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Bivector&a, const ProjectiveTranslator& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wz * xyMyz - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (-b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz)),
            .xy = 0.0,
            .xz = 0.0,
            .yz = 0.0,
            .i = 2.0 * b.s * (a.wy * a.xz - a.wx * a.yz - a.wz * a.xy)
        };
    }
    constexpr Motor Bivector::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Bivector&a, const Translator& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = (xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wz * xyMyz - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (-b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz)),
            .xy = 0.0,
            .xz = 0.0,
            .yz = 0.0,
            .i = 2.0 * (a.wy * a.xz - a.wx * a.yz - a.wz * a.xy)
        };
    }
    constexpr Motor Bivector::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const Bivector&a, const Vector& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.z * xyMyz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (-b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr Vector Bivector::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Bivector&a, const Point& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.z * xyMyz - a.wy * a.xy - a.wz * a.xz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (a.wx * a.xy - a.wz * a.yz - b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (a.wx * a.xz + a.wy * a.yz + b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz)),
            .w = (xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr ProjectivePoint Bivector::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Bivector&a, const PlaneIdeal& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.z * xyMyz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (-b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz)),
            .w = 2.0 * (a.wx * (a.xy * b.y + a.xz * b.z) + a.wy * (a.yz * b.z - a.xy * b.x) + a.wz * (-a.xz * b.x - a.yz * b.y))
        };
    }
    constexpr Plane Bivector::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Bivector&a, const BivectorBulk& b) noexcept {
        const double wxMxy = a.wx * a.xy;
        const double wxMxz = a.wx * a.xz;
        const double wxMyz = a.wx * a.yz;
        const double wyMxy = a.wy * a.xy;
        const double wyMxz = a.wy * a.xz;
        const double wyMyz = a.wy * a.yz;
        const double wzMxy = a.wz * a.xy;
        const double wzMxz = a.wz * a.xz;
        const double wzMyz = a.wz * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .wx = 2.0 * (b.xy * (wxMxy + wzMyz) + b.xz * (wxMxz - wyMyz) + b.yz * (wxMyz + wyMxz - wzMxy)),
            .wy = 2.0 * (b.xy * (wyMxy - wzMxz) + b.xz * (wxMyz + wyMxz + wzMxy) + b.yz * (wyMyz - wxMxz)),
            .wz = 2.0 * (b.xy * (wyMxz + wzMxy - wxMyz) + b.xz * (wzMxz - wyMxy) + b.yz * (wxMxy + wzMyz)),
            .xy = (2.0 * (b.xz * xyMxz + b.yz * xyMyz) + b.xy * (xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * xyMxz + b.yz * xzMyz) + b.xz * (xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * xyMyz + b.xz * xzMyz) + b.yz * (yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr Bivector Bivector::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const Bivector&a, const BivectorWeight& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .wx = (2.0 * (b.wz * xyMyz - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (-b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr BivectorWeight Bivector::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const Bivector&a, const PseudoScalar& b) noexcept {
        return {
            .i = b.i * (a.xy * a.xy + a.xz * a.xz + a.yz * a.yz)
        };
    }
    constexpr PseudoScalar Bivector::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Bivector&a, const PointCenter& b) noexcept {
        return {
            .x = 2.0 * (-a.wy * a.xy - a.wz * a.xz),
            .y = 2.0 * (a.wx * a.xy - a.wz * a.yz),
            .z = 2.0 * (a.wx * a.xz + a.wy * a.yz),
            .w = (a.xy * a.xy + a.xz * a.xz + a.yz * a.yz)
        };
    }
    constexpr ProjectivePoint Bivector::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const ProjectivePoint&a, const Motor& b) noexcept {
        const double xMw = a.w * a.x;
        const double yMw = a.w * a.y;
        const double zMw = a.w * a.z;
        const double wMw = a.w * a.w;
        return {
            .s = b.s * wMw,
            .wx = (2.0 * (b.xy * yMw + b.xz * zMw) - b.wx * wMw),
            .wy = (2.0 * (b.yz * zMw - b.xy * xMw) - b.wy * wMw),
            .wz = (2.0 * (-b.xz * xMw - b.yz * yMw) - b.wz * wMw),
            .xy = b.xy * wMw,
            .xz = b.xz * wMw,
            .yz = b.yz * wMw,
            .i = -b.i * wMw
        };
    }
    constexpr Motor ProjectivePoint::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const ProjectivePoint&a, const Plane& b) noexcept {
        const double wMw = a.w * a.w;
        return {
            .x = b.x * wMw,
            .y = b.y * wMw,
            .z = b.z * wMw,
            .w = (-b.w * wMw + 2.0 * a.w * (-a.x * b.x - a.y * b.y - a.z * b.z))
        };
    }
    constexpr Plane ProjectivePoint::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const ProjectivePoint&a, const Bivector& b) noexcept {
        const double xMw = a.w * a.x;
        const double yMw = a.w * a.y;
        const double zMw = a.w * a.z;
        const double wMw = a.w * a.w;
        return {
            .wx = (2.0 * (b.xy * yMw + b.xz * zMw) - b.wx * wMw),
            .wy = (2.0 * (b.yz * zMw - b.xy * xMw) - b.wy * wMw),
            .wz = (2.0 * (-b.xz * xMw - b.yz * yMw) - b.wz * wMw),
            .xy = b.xy * wMw,
            .xz = b.xz * wMw,
            .yz = b.yz * wMw
        };
    }
    constexpr Bivector ProjectivePoint::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint&a, const ProjectivePoint& b) noexcept {
        const double wMw = a.w * a.w;
        return {
            .x = (-b.x * wMw + 2.0 * a.w * a.x * b.w),
            .y = (-b.y * wMw + 2.0 * a.w * a.y * b.w),
            .z = (-b.z * wMw + 2.0 * a.w * a.z * b.w),
            .w = b.w * wMw
        };
    }
    constexpr ProjectivePoint ProjectivePoint::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const ProjectivePoint&a, const Quaternion& b) noexcept {
        const double xMw = a.w * a.x;
        const double yMw = a.w * a.y;
        const double zMw = a.w * a.z;
        const double wMw = a.w * a.w;
        return {
            .s = b.s * wMw,
            .wx = 2.0 * (b.xy * yMw + b.xz * zMw),
            .wy = 2.0 * (b.yz * zMw - b.xy * xMw),
            .wz = 2.0 * (-b.xz * xMw - b.yz * yMw),
            .xy = b.xy * wMw,
            .xz = b.xz * wMw,
            .yz = b.yz * wMw,
            .i = 0.0
        };
    }
    constexpr Motor ProjectivePoint::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectivePoint&a, const ProjectiveTranslator& b) noexcept {
        const double wMw = a.w * a.w;
        return {
            .s = b.s * wMw,
            .wx = -b.wx * wMw,
            .wy = -b.wy * wMw,
            .wz = -b.wz * wMw
        };
    }
    constexpr ProjectiveTranslator ProjectivePoint::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectivePoint&a, const Translator& b) noexcept {
        const double wMw = a.w * a.w;
        return {
            .s = wMw,
            .wx = -b.wx * wMw,
            .wy = -b.wy * wMw,
            .wz = -b.wz * wMw
        };
    }
    constexpr ProjectiveTranslator ProjectivePoint::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const ProjectivePoint&a, const Vector& b) noexcept {
        const double wMw = a.w * a.w;
        return {
            .x = -b.x * wMw,
            .y = -b.y * wMw,
            .z = -b.z * wMw
        };
    }
    constexpr Vector ProjectivePoint::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint&a, const Point& b) noexcept {
        const double wMw = a.w * a.w;
        return {
            .x = (-b.x * wMw + 2.0 * a.w * a.x),
            .y = (-b.y * wMw + 2.0 * a.w * a.y),
            .z = (-b.z * wMw + 2.0 * a.w * a.z),
            .w = wMw
        };
    }
    constexpr ProjectivePoint ProjectivePoint::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const ProjectivePoint&a, const PlaneIdeal& b) noexcept {
        const double wMw = a.w * a.w;
        return {
            .x = b.x * wMw,
            .y = b.y * wMw,
            .z = b.z * wMw,
            .w = 2.0 * a.w * (-a.x * b.x - a.y * b.y - a.z * b.z)
        };
    }
    constexpr Plane ProjectivePoint::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const ProjectivePoint&a, const BivectorBulk& b) noexcept {
        const double xMw = a.w * a.x;
        const double yMw = a.w * a.y;
        const double zMw = a.w * a.z;
        const double wMw = a.w * a.w;
        return {
            .wx = 2.0 * (b.xy * yMw + b.xz * zMw),
            .wy = 2.0 * (b.yz * zMw - b.xy * xMw),
            .wz = 2.0 * (-b.xz * xMw - b.yz * yMw),
            .xy = b.xy * wMw,
            .xz = b.xz * wMw,
            .yz = b.yz * wMw
        };
    }
    constexpr Bivector ProjectivePoint::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const ProjectivePoint&a, const BivectorWeight& b) noexcept {
        const double wMw = a.w * a.w;
        return {
            .wx = -b.wx * wMw,
            .wy = -b.wy * wMw,
            .wz = -b.wz * wMw
        };
    }
    constexpr BivectorWeight ProjectivePoint::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const ProjectivePoint&a, const PseudoScalar& b) noexcept {
        return {
            .i = -a.w * a.w * b.i
        };
    }
    constexpr PseudoScalar ProjectivePoint::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint&a, const PointCenter& b) noexcept {
        return {
            .x = 2.0 * a.w * a.x,
            .y = 2.0 * a.w * a.y,
            .z = 2.0 * a.w * a.z,
            .w = a.w * a.w
        };
    }
    constexpr ProjectivePoint ProjectivePoint::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Quaternion&a, const Motor& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (sMs + xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz)),
            .xy = (2.0 * (b.xz * (sMyz + xyMxz) + b.yz * (xyMyz - sMxz)) + b.xy * (sMs + xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * (xyMxz - sMyz) + b.yz * (sMxy + xzMyz)) + b.xz * (sMs + xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * (sMxz + xyMyz) + b.xz * (xzMyz - sMxy)) + b.yz * (sMs + yzMyz - xyMxy - xzMxz)),
            .i = b.i * (sMs + xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr Motor Quaternion::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Quaternion&a, const Plane& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz)) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz)) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz)) + b.z * (sMs + xyMxy - xzMxz - yzMyz)),
            .w = b.w * (sMs + xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr Plane Quaternion::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Quaternion&a, const Bivector& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz)),
            .xy = (2.0 * (b.xz * (sMyz + xyMxz) + b.yz * (xyMyz - sMxz)) + b.xy * (sMs + xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * (xyMxz - sMyz) + b.yz * (sMxy + xzMyz)) + b.xz * (sMs + xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * (sMxz + xyMyz) + b.xz * (xzMyz - sMxy)) + b.yz * (sMs + yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr Bivector Quaternion::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Quaternion&a, const ProjectivePoint& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz)) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz)) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz)) + b.z * (sMs + xyMxy - xzMxz - yzMyz)),
            .w = b.w * (sMs + xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr ProjectivePoint Quaternion::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Quaternion sandwich(const Quaternion&a, const Quaternion& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (sMs + xyMxy + xzMxz + yzMyz),
            .xy = (2.0 * (b.xz * (sMyz + xyMxz) + b.yz * (xyMyz - sMxz)) + b.xy * (sMs + xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * (xyMxz - sMyz) + b.yz * (sMxy + xzMyz)) + b.xz * (sMs + xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * (sMxz + xyMyz) + b.xz * (xzMyz - sMxy)) + b.yz * (sMs + yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr Quaternion Quaternion::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Quaternion&a, const ProjectiveTranslator& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (sMs + xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr ProjectiveTranslator Quaternion::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Quaternion&a, const Translator& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = (sMs + xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr ProjectiveTranslator Quaternion::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const Quaternion&a, const Vector& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz)) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz)) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz)) + b.z * (sMs + xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr Vector Quaternion::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Quaternion&a, const Point& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz)) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz)) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz)) + b.z * (sMs + xyMxy - xzMxz - yzMyz)),
            .w = (sMs + xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr ProjectivePoint Quaternion::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal sandwich(const Quaternion&a, const PlaneIdeal& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.y * (sMxy - xzMyz) + b.z * (sMxz + xyMyz)) + b.x * (sMs + yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (b.x * (-sMxy - xzMyz) + b.z * (sMyz - xyMxz)) + b.y * (sMs + xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * (xyMyz - sMxz) + b.y * (-sMyz - xyMxz)) + b.z * (sMs + xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr PlaneIdeal Quaternion::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorBulk sandwich(const Quaternion&a, const BivectorBulk& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .xy = (2.0 * (b.xz * (sMyz + xyMxz) + b.yz * (xyMyz - sMxz)) + b.xy * (sMs + xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * (xyMxz - sMyz) + b.yz * (sMxy + xzMyz)) + b.xz * (sMs + xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * (sMxz + xyMyz) + b.xz * (xzMyz - sMxy)) + b.yz * (sMs + yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr BivectorBulk Quaternion::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const Quaternion&a, const BivectorWeight& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMxy = a.s * a.xy;
        const double sMxz = a.s * a.xz;
        const double sMyz = a.s * a.yz;
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .wx = (2.0 * (b.wy * (sMxy - xzMyz) + b.wz * (sMxz + xyMyz)) + b.wx * (sMs + yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (b.wx * (-sMxy - xzMyz) + b.wz * (sMyz - xyMxz)) + b.wy * (sMs + xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * (xyMyz - sMxz) + b.wy * (-sMyz - xyMxz)) + b.wz * (sMs + xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr BivectorWeight Quaternion::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const Quaternion&a, const PseudoScalar& b) noexcept {
        return {
            .i = b.i * (a.s * a.s + a.xy * a.xy + a.xz * a.xz + a.yz * a.yz)
        };
    }
    constexpr PseudoScalar Quaternion::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Quaternion&a, const PointCenter& b) noexcept {
        return {
            .x = 0.0,
            .y = 0.0,
            .z = 0.0,
            .w = (a.s * a.s + a.xy * a.xy + a.xz * a.xz + a.yz * a.yz)
        };
    }
    constexpr ProjectivePoint Quaternion::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const ProjectiveTranslator&a, const Motor& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMwx = a.s * a.wx;
        const double sMwy = a.s * a.wy;
        const double sMwz = a.s * a.wz;
        return {
            .s = b.s * sMs,
            .wx = (2.0 * (-b.xy * sMwy - b.xz * sMwz) + b.wx * sMs),
            .wy = (2.0 * (b.xy * sMwx - b.yz * sMwz) + b.wy * sMs),
            .wz = (2.0 * (b.xz * sMwx + b.yz * sMwy) + b.wz * sMs),
            .xy = b.xy * sMs,
            .xz = b.xz * sMs,
            .yz = b.yz * sMs,
            .i = b.i * sMs
        };
    }
    constexpr Motor ProjectiveTranslator::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const ProjectiveTranslator&a, const Plane& b) noexcept {
        const double sMs = a.s * a.s;
        return {
            .x = b.x * sMs,
            .y = b.y * sMs,
            .z = b.z * sMs,
            .w = (b.w * sMs + 2.0 * a.s * (a.wx * b.x + a.wy * b.y + a.wz * b.z))
        };
    }
    constexpr Plane ProjectiveTranslator::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const ProjectiveTranslator&a, const Bivector& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMwx = a.s * a.wx;
        const double sMwy = a.s * a.wy;
        const double sMwz = a.s * a.wz;
        return {
            .wx = (2.0 * (-b.xy * sMwy - b.xz * sMwz) + b.wx * sMs),
            .wy = (2.0 * (b.xy * sMwx - b.yz * sMwz) + b.wy * sMs),
            .wz = (2.0 * (b.xz * sMwx + b.yz * sMwy) + b.wz * sMs),
            .xy = b.xy * sMs,
            .xz = b.xz * sMs,
            .yz = b.yz * sMs
        };
    }
    constexpr Bivector ProjectiveTranslator::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectiveTranslator&a, const ProjectivePoint& b) noexcept {
        const double sMs = a.s * a.s;
        return {
            .x = (b.x * sMs - 2.0 * a.s * a.wx * b.w),
            .y = (b.y * sMs - 2.0 * a.s * a.wy * b.w),
            .z = (b.z * sMs - 2.0 * a.s * a.wz * b.w),
            .w = b.w * sMs
        };
    }
    constexpr ProjectivePoint ProjectiveTranslator::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const ProjectiveTranslator&a, const Quaternion& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMwx = a.s * a.wx;
        const double sMwy = a.s * a.wy;
        const double sMwz = a.s * a.wz;
        return {
            .s = b.s * sMs,
            .wx = 2.0 * (-b.xy * sMwy - b.xz * sMwz),
            .wy = 2.0 * (b.xy * sMwx - b.yz * sMwz),
            .wz = 2.0 * (b.xz * sMwx + b.yz * sMwy),
            .xy = b.xy * sMs,
            .xz = b.xz * sMs,
            .yz = b.yz * sMs,
            .i = 0.0
        };
    }
    constexpr Motor ProjectiveTranslator::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator&a, const ProjectiveTranslator& b) noexcept {
        const double sMs = a.s * a.s;
        return {
            .s = b.s * sMs,
            .wx = b.wx * sMs,
            .wy = b.wy * sMs,
            .wz = b.wz * sMs
        };
    }
    constexpr ProjectiveTranslator ProjectiveTranslator::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator&a, const Translator& b) noexcept {
        const double sMs = a.s * a.s;
        return {
            .s = sMs,
            .wx = b.wx * sMs,
            .wy = b.wy * sMs,
            .wz = b.wz * sMs
        };
    }
    constexpr ProjectiveTranslator ProjectiveTranslator::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const ProjectiveTranslator&a, const Vector& b) noexcept {
        const double sMs = a.s * a.s;
        return {
            .x = b.x * sMs,
            .y = b.y * sMs,
            .z = b.z * sMs
        };
    }
    constexpr Vector ProjectiveTranslator::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectiveTranslator&a, const Point& b) noexcept {
        const double sMs = a.s * a.s;
        return {
            .x = (b.x * sMs - 2.0 * a.s * a.wx),
            .y = (b.y * sMs - 2.0 * a.s * a.wy),
            .z = (b.z * sMs - 2.0 * a.s * a.wz),
            .w = sMs
        };
    }
    constexpr ProjectivePoint ProjectiveTranslator::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const ProjectiveTranslator&a, const PlaneIdeal& b) noexcept {
        const double sMs = a.s * a.s;
        return {
            .x = b.x * sMs,
            .y = b.y * sMs,
            .z = b.z * sMs,
            .w = 2.0 * a.s * (a.wx * b.x + a.wy * b.y + a.wz * b.z)
        };
    }
    constexpr Plane ProjectiveTranslator::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const ProjectiveTranslator&a, const BivectorBulk& b) noexcept {
        const double sMs = a.s * a.s;
        const double sMwx = a.s * a.wx;
        const double sMwy = a.s * a.wy;
        const double sMwz = a.s * a.wz;
        return {
            .wx = 2.0 * (-b.xy * sMwy - b.xz * sMwz),
            .wy = 2.0 * (b.xy * sMwx - b.yz * sMwz),
            .wz = 2.0 * (b.xz * sMwx + b.yz * sMwy),
            .xy = b.xy * sMs,
            .xz = b.xz * sMs,
            .yz = b.yz * sMs
        };
    }
    constexpr Bivector ProjectiveTranslator::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const ProjectiveTranslator&a, const BivectorWeight& b) noexcept {
        const double sMs = a.s * a.s;
        return {
            .wx = b.wx * sMs,
            .wy = b.wy * sMs,
            .wz = b.wz * sMs
        };
    }
    constexpr BivectorWeight ProjectiveTranslator::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const ProjectiveTranslator&a, const PseudoScalar& b) noexcept {
        return {
            .i = a.s * a.s * b.i
        };
    }
    constexpr PseudoScalar ProjectiveTranslator::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectiveTranslator&a, const PointCenter& b) noexcept {
        return {
            .x = -2.0 * a.s * a.wx,
            .y = -2.0 * a.s * a.wy,
            .z = -2.0 * a.s * a.wz,
            .w = a.s * a.s
        };
    }
    constexpr ProjectivePoint ProjectiveTranslator::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Translator&a, const Motor& b) noexcept {
        return {
            .s = b.s,
            .wx = (b.wx - 2.0 * a.wy * b.xy - 2.0 * a.wz * b.xz),
            .wy = (b.wy - 2.0 * a.wz * b.yz + 2.0 * a.wx * b.xy),
            .wz = (b.wz + 2.0 * a.wx * b.xz + 2.0 * a.wy * b.yz),
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz,
            .i = b.i
        };
    }
    constexpr Motor Translator::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Translator&a, const Plane& b) noexcept {
        return {
            .x = b.x,
            .y = b.y,
            .z = b.z,
            .w = (b.w + 2.0 * a.wx * b.x + 2.0 * a.wy * b.y + 2.0 * a.wz * b.z)
        };
    }
    constexpr Plane Translator::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Translator&a, const Bivector& b) noexcept {
        return {
            .wx = (b.wx - 2.0 * a.wy * b.xy - 2.0 * a.wz * b.xz),
            .wy = (b.wy - 2.0 * a.wz * b.yz + 2.0 * a.wx * b.xy),
            .wz = (b.wz + 2.0 * a.wx * b.xz + 2.0 * a.wy * b.yz),
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz
        };
    }
    constexpr Bivector Translator::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Translator&a, const ProjectivePoint& b) noexcept {
        return {
            .x = (b.x - 2.0 * a.wx * b.w),
            .y = (b.y - 2.0 * a.wy * b.w),
            .z = (b.z - 2.0 * a.wz * b.w),
            .w = b.w
        };
    }
    constexpr ProjectivePoint Translator::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Translator&a, const Quaternion& b) noexcept {
        return {
            .s = b.s,
            .wx = 2.0 * (-a.wy * b.xy - a.wz * b.xz),
            .wy = 2.0 * (a.wx * b.xy - a.wz * b.yz),
            .wz = 2.0 * (a.wx * b.xz + a.wy * b.yz),
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz,
            .i = 0.0
        };
    }
    constexpr Motor Translator::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator&a, const ProjectiveTranslator& b) noexcept {
        return {
            .s = b.s,
            .wx = b.wx,
            .wy = b.wy,
            .wz = b.wz
        };
    }
    constexpr ProjectiveTranslator Translator::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Translator sandwich(const Translator&a, const Translator& b) noexcept {
        return {
            .wx = b.wx,
            .wy = b.wy,
            .wz = b.wz
        };
    }
    constexpr Translator Translator::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const Translator&a, const Vector& b) noexcept {
        return {
            .x = b.x,
            .y = b.y,
            .z = b.z
        };
    }
    constexpr Vector Translator::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Point sandwich(const Translator&a, const Point& b) noexcept {
        return {
            .x = (b.x - 2.0 * a.wx),
            .y = (b.y - 2.0 * a.wy),
            .z = (b.z - 2.0 * a.wz)
        };
    }
    constexpr Point Translator::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Translator&a, const PlaneIdeal& b) noexcept {
        return {
            .x = b.x,
            .y = b.y,
            .z = b.z,
            .w = 2.0 * (a.wx * b.x + a.wy * b.y + a.wz * b.z)
        };
    }
    constexpr Plane Translator::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Translator&a, const BivectorBulk& b) noexcept {
        return {
            .wx = 2.0 * (-a.wy * b.xy - a.wz * b.xz),
            .wy = 2.0 * (a.wx * b.xy - a.wz * b.yz),
            .wz = 2.0 * (a.wx * b.xz + a.wy * b.yz),
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz
        };
    }
    constexpr Bivector Translator::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const Translator&a, const BivectorWeight& b) noexcept {
        return {
            .wx = b.wx,
            .wy = b.wy,
            .wz = b.wz
        };
    }
    constexpr BivectorWeight Translator::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const Translator&a, const PseudoScalar& b) noexcept {
        return {
            .i = b.i
        };
    }
    constexpr PseudoScalar Translator::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Point sandwich(const Translator&a, const PointCenter& b) noexcept {
        return {
            .x = -2.0 * a.wx,
            .y = -2.0 * a.wy,
            .z = -2.0 * a.wz
        };
    }
    constexpr Point Translator::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Point&a, const Motor& b) noexcept {
        return {
            .s = b.s,
            .wx = (-b.wx + 2.0 * (a.y * b.xy + a.z * b.xz)),
            .wy = (-b.wy + 2.0 * (a.z * b.yz - a.x * b.xy)),
            .wz = (-b.wz + 2.0 * (-a.x * b.xz - a.y * b.yz)),
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz,
            .i = -b.i
        };
    }
    constexpr Motor Point::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Point&a, const Plane& b) noexcept {
        return {
            .x = b.x,
            .y = b.y,
            .z = b.z,
            .w = (-b.w + 2.0 * (-a.x * b.x - a.y * b.y - a.z * b.z))
        };
    }
    constexpr Plane Point::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Point&a, const Bivector& b) noexcept {
        return {
            .wx = (-b.wx + 2.0 * (a.y * b.xy + a.z * b.xz)),
            .wy = (-b.wy + 2.0 * (a.z * b.yz - a.x * b.xy)),
            .wz = (-b.wz + 2.0 * (-a.x * b.xz - a.y * b.yz)),
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz
        };
    }
    constexpr Bivector Point::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const Point&a, const ProjectivePoint& b) noexcept {
        return {
            .x = (-b.x + 2.0 * a.x * b.w),
            .y = (-b.y + 2.0 * a.y * b.w),
            .z = (-b.z + 2.0 * a.z * b.w),
            .w = b.w
        };
    }
    constexpr ProjectivePoint Point::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const Point&a, const Quaternion& b) noexcept {
        return {
            .s = b.s,
            .wx = 2.0 * (a.y * b.xy + a.z * b.xz),
            .wy = 2.0 * (a.z * b.yz - a.x * b.xy),
            .wz = 2.0 * (-a.x * b.xz - a.y * b.yz),
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz,
            .i = 0.0
        };
    }
    constexpr Motor Point::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Point&a, const ProjectiveTranslator& b) noexcept {
        return {
            .s = b.s,
            .wx = -b.wx,
            .wy = -b.wy,
            .wz = -b.wz
        };
    }
    constexpr ProjectiveTranslator Point::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Translator sandwich(const Point&a, const Translator& b) noexcept {
        return {
            .wx = -b.wx,
            .wy = -b.wy,
            .wz = -b.wz
        };
    }
    constexpr Translator Point::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const Point&a, const Vector& b) noexcept {
        return {
            .x = -b.x,
            .y = -b.y,
            .z = -b.z
        };
    }
    constexpr Vector Point::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Point sandwich(const Point&a, const Point& b) noexcept {
        return {
            .x = (-b.x + 2.0 * a.x),
            .y = (-b.y + 2.0 * a.y),
            .z = (-b.z + 2.0 * a.z)
        };
    }
    constexpr Point Point::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const Point&a, const PlaneIdeal& b) noexcept {
        return {
            .x = b.x,
            .y = b.y,
            .z = b.z,
            .w = 2.0 * (-a.x * b.x - a.y * b.y - a.z * b.z)
        };
    }
    constexpr Plane Point::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const Point&a, const BivectorBulk& b) noexcept {
        return {
            .wx = 2.0 * (a.y * b.xy + a.z * b.xz),
            .wy = 2.0 * (a.z * b.yz - a.x * b.xy),
            .wz = 2.0 * (-a.x * b.xz - a.y * b.yz),
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz
        };
    }
    constexpr Bivector Point::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const Point&a, const BivectorWeight& b) noexcept {
        return {
            .wx = -b.wx,
            .wy = -b.wy,
            .wz = -b.wz
        };
    }
    constexpr BivectorWeight Point::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const Point&a, const PseudoScalar& b) noexcept {
        return {
            .i = -b.i
        };
    }
    constexpr PseudoScalar Point::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Point sandwich(const Point&a, const PointCenter& b) noexcept {
        return {
            .x = 2.0 * a.x,
            .y = 2.0 * a.y,
            .z = 2.0 * a.z
        };
    }
    constexpr Point Point::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const PlaneIdeal&a, const Motor& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .s = b.s * (xMx + yMy + zMz),
            .wx = (2.0 * (-b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (-b.wx * xMy - b.wz * yMz) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz) + b.wz * (xMx + yMy - zMz)),
            .xy = (2.0 * (b.yz * xMz - b.xz * yMz) + b.xy * (zMz - xMx - yMy)),
            .xz = (2.0 * (-b.xy * yMz - b.yz * xMy) + b.xz * (yMy - xMx - zMz)),
            .yz = (2.0 * (b.xy * xMz - b.xz * xMy) + b.yz * (xMx - yMy - zMz)),
            .i = b.i * (-xMx - yMy - zMz)
        };
    }
    constexpr Motor PlaneIdeal::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal&a, const Plane& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (b.y * xMy + b.z * xMz) + b.x * (xMx - yMy - zMz)),
            .y = (2.0 * (b.x * xMy + b.z * yMz) + b.y * (yMy - xMx - zMz)),
            .z = (2.0 * (b.x * xMz + b.y * yMz) + b.z * (zMz - xMx - yMy)),
            .w = b.w * (-xMx - yMy - zMz)
        };
    }
    constexpr Plane PlaneIdeal::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const PlaneIdeal&a, const Bivector& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .wx = (2.0 * (-b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (-b.wx * xMy - b.wz * yMz) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz) + b.wz * (xMx + yMy - zMz)),
            .xy = (2.0 * (b.yz * xMz - b.xz * yMz) + b.xy * (zMz - xMx - yMy)),
            .xz = (2.0 * (-b.xy * yMz - b.yz * xMy) + b.xz * (yMy - xMx - zMz)),
            .yz = (2.0 * (b.xy * xMz - b.xz * xMy) + b.yz * (xMx - yMy - zMz))
        };
    }
    constexpr Bivector PlaneIdeal::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const PlaneIdeal&a, const ProjectivePoint& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (-b.y * xMy - b.z * xMz) + b.x * (yMy + zMz - xMx)),
            .y = (2.0 * (-b.x * xMy - b.z * yMz) + b.y * (xMx + zMz - yMy)),
            .z = (2.0 * (-b.x * xMz - b.y * yMz) + b.z * (xMx + yMy - zMz)),
            .w = b.w * (xMx + yMy + zMz)
        };
    }
    constexpr ProjectivePoint PlaneIdeal::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Quaternion sandwich(const PlaneIdeal&a, const Quaternion& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .s = b.s * (xMx + yMy + zMz),
            .xy = (2.0 * (b.yz * xMz - b.xz * yMz) + b.xy * (zMz - xMx - yMy)),
            .xz = (2.0 * (-b.xy * yMz - b.yz * xMy) + b.xz * (yMy - xMx - zMz)),
            .yz = (2.0 * (b.xy * xMz - b.xz * xMy) + b.yz * (xMx - yMy - zMz))
        };
    }
    constexpr Quaternion PlaneIdeal::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const PlaneIdeal&a, const ProjectiveTranslator& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .s = b.s * (xMx + yMy + zMz),
            .wx = (2.0 * (-b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (-b.wx * xMy - b.wz * yMz) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz) + b.wz * (xMx + yMy - zMz))
        };
    }
    constexpr ProjectiveTranslator PlaneIdeal::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const PlaneIdeal&a, const Translator& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .s = (xMx + yMy + zMz),
            .wx = (2.0 * (-b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (-b.wx * xMy - b.wz * yMz) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz) + b.wz * (xMx + yMy - zMz))
        };
    }
    constexpr ProjectiveTranslator PlaneIdeal::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const PlaneIdeal&a, const Vector& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (-b.y * xMy - b.z * xMz) + b.x * (yMy + zMz - xMx)),
            .y = (2.0 * (-b.x * xMy - b.z * yMz) + b.y * (xMx + zMz - yMy)),
            .z = (2.0 * (-b.x * xMz - b.y * yMz) + b.z * (xMx + yMy - zMz))
        };
    }
    constexpr Vector PlaneIdeal::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const PlaneIdeal&a, const Point& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (-b.y * xMy - b.z * xMz) + b.x * (yMy + zMz - xMx)),
            .y = (2.0 * (-b.x * xMy - b.z * yMz) + b.y * (xMx + zMz - yMy)),
            .z = (2.0 * (-b.x * xMz - b.y * yMz) + b.z * (xMx + yMy - zMz)),
            .w = (xMx + yMy + zMz)
        };
    }
    constexpr ProjectivePoint PlaneIdeal::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal sandwich(const PlaneIdeal&a, const PlaneIdeal& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .x = (2.0 * (b.y * xMy + b.z * xMz) + b.x * (xMx - yMy - zMz)),
            .y = (2.0 * (b.x * xMy + b.z * yMz) + b.y * (yMy - xMx - zMz)),
            .z = (2.0 * (b.x * xMz + b.y * yMz) + b.z * (zMz - xMx - yMy))
        };
    }
    constexpr PlaneIdeal PlaneIdeal::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorBulk sandwich(const PlaneIdeal&a, const BivectorBulk& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .xy = (2.0 * (b.yz * xMz - b.xz * yMz) + b.xy * (zMz - xMx - yMy)),
            .xz = (2.0 * (-b.xy * yMz - b.yz * xMy) + b.xz * (yMy - xMx - zMz)),
            .yz = (2.0 * (b.xy * xMz - b.xz * xMy) + b.yz * (xMx - yMy - zMz))
        };
    }
    constexpr BivectorBulk PlaneIdeal::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const PlaneIdeal&a, const BivectorWeight& b) noexcept {
        const double xMx = a.x * a.x;
        const double xMy = a.x * a.y;
        const double xMz = a.x * a.z;
        const double yMy = a.y * a.y;
        const double yMz = a.y * a.z;
        const double zMz = a.z * a.z;
        return {
            .wx = (2.0 * (-b.wy * xMy - b.wz * xMz) + b.wx * (yMy + zMz - xMx)),
            .wy = (2.0 * (-b.wx * xMy - b.wz * yMz) + b.wy * (xMx + zMz - yMy)),
            .wz = (2.0 * (-b.wx * xMz - b.wy * yMz) + b.wz * (xMx + yMy - zMz))
        };
    }
    constexpr BivectorWeight PlaneIdeal::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const PlaneIdeal&a, const PseudoScalar& b) noexcept {
        return {
            .i = b.i * (-a.x * a.x - a.y * a.y - a.z * a.z)
        };
    }
    constexpr PseudoScalar PlaneIdeal::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const PlaneIdeal&a, const PointCenter& b) noexcept {
        return {
            .x = 0.0,
            .y = 0.0,
            .z = 0.0,
            .w = (a.x * a.x + a.y * a.y + a.z * a.z)
        };
    }
    constexpr ProjectivePoint PlaneIdeal::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const BivectorBulk&a, const Motor& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wz * xyMyz - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (-b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz)),
            .xy = (2.0 * (b.xz * xyMxz + b.yz * xyMyz) + b.xy * (xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * xyMxz + b.yz * xzMyz) + b.xz * (xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * xyMyz + b.xz * xzMyz) + b.yz * (yzMyz - xyMxy - xzMxz)),
            .i = b.i * (xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr Motor BivectorBulk::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const BivectorBulk&a, const Plane& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.z * xyMyz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (-b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz)),
            .w = b.w * (xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr Plane BivectorBulk::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk&a, const Bivector& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .wx = (2.0 * (b.wz * xyMyz - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (-b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz)),
            .xy = (2.0 * (b.xz * xyMxz + b.yz * xyMyz) + b.xy * (xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * xyMxz + b.yz * xzMyz) + b.xz * (xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * xyMyz + b.xz * xzMyz) + b.yz * (yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr Bivector BivectorBulk::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const BivectorBulk&a, const ProjectivePoint& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.z * xyMyz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (-b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz)),
            .w = b.w * (xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr ProjectivePoint BivectorBulk::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Quaternion sandwich(const BivectorBulk&a, const Quaternion& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (xyMxy + xzMxz + yzMyz),
            .xy = (2.0 * (b.xz * xyMxz + b.yz * xyMyz) + b.xy * (xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * xyMxz + b.yz * xzMyz) + b.xz * (xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * xyMyz + b.xz * xzMyz) + b.yz * (yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr Quaternion BivectorBulk::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const BivectorBulk&a, const ProjectiveTranslator& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = b.s * (xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wz * xyMyz - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (-b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr ProjectiveTranslator BivectorBulk::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const BivectorBulk&a, const Translator& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .s = (xyMxy + xzMxz + yzMyz),
            .wx = (2.0 * (b.wz * xyMyz - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (-b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr ProjectiveTranslator BivectorBulk::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const BivectorBulk&a, const Vector& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.z * xyMyz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (-b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr Vector BivectorBulk::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const BivectorBulk&a, const Point& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.z * xyMyz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (-b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz)),
            .w = (xyMxy + xzMxz + yzMyz)
        };
    }
    constexpr ProjectivePoint BivectorBulk::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal sandwich(const BivectorBulk&a, const PlaneIdeal& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .x = (2.0 * (b.z * xyMyz - b.y * xzMyz) + b.x * (yzMyz - xyMxy - xzMxz)),
            .y = (2.0 * (-b.x * xzMyz - b.z * xyMxz) + b.y * (xzMxz - xyMxy - yzMyz)),
            .z = (2.0 * (b.x * xyMyz - b.y * xyMxz) + b.z * (xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr PlaneIdeal BivectorBulk::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorBulk sandwich(const BivectorBulk&a, const BivectorBulk& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .xy = (2.0 * (b.xz * xyMxz + b.yz * xyMyz) + b.xy * (xyMxy - xzMxz - yzMyz)),
            .xz = (2.0 * (b.xy * xyMxz + b.yz * xzMyz) + b.xz * (xzMxz - xyMxy - yzMyz)),
            .yz = (2.0 * (b.xy * xyMyz + b.xz * xzMyz) + b.yz * (yzMyz - xyMxy - xzMxz))
        };
    }
    constexpr BivectorBulk BivectorBulk::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorBulk&a, const BivectorWeight& b) noexcept {
        const double xyMxy = a.xy * a.xy;
        const double xyMxz = a.xy * a.xz;
        const double xyMyz = a.xy * a.yz;
        const double xzMxz = a.xz * a.xz;
        const double xzMyz = a.xz * a.yz;
        const double yzMyz = a.yz * a.yz;
        return {
            .wx = (2.0 * (b.wz * xyMyz - b.wy * xzMyz) + b.wx * (yzMyz - xyMxy - xzMxz)),
            .wy = (2.0 * (-b.wx * xzMyz - b.wz * xyMxz) + b.wy * (xzMxz - xyMxy - yzMyz)),
            .wz = (2.0 * (b.wx * xyMyz - b.wy * xyMxz) + b.wz * (xyMxy - xzMxz - yzMyz))
        };
    }
    constexpr BivectorWeight BivectorBulk::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const BivectorBulk&a, const PseudoScalar& b) noexcept {
        return {
            .i = b.i * (a.xy * a.xy + a.xz * a.xz + a.yz * a.yz)
        };
    }
    constexpr PseudoScalar BivectorBulk::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const BivectorBulk&a, const PointCenter& b) noexcept {
        return {
            .x = 0.0,
            .y = 0.0,
            .z = 0.0,
            .w = (a.xy * a.xy + a.xz * a.xz + a.yz * a.yz)
        };
    }
    constexpr ProjectivePoint BivectorBulk::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Motor sandwich(const PointCenter&a, const Motor& b) noexcept {
        return {
            .s = b.s,
            .wx = -b.wx,
            .wy = -b.wy,
            .wz = -b.wz,
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz,
            .i = -b.i
        };
    }
    constexpr Motor PointCenter::sandwich(const Motor& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Plane sandwich(const PointCenter&a, const Plane& b) noexcept {
        return {
            .x = b.x,
            .y = b.y,
            .z = b.z,
            .w = -b.w
        };
    }
    constexpr Plane PointCenter::sandwich(const Plane& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Bivector sandwich(const PointCenter&a, const Bivector& b) noexcept {
        return {
            .wx = -b.wx,
            .wy = -b.wy,
            .wz = -b.wz,
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz
        };
    }
    constexpr Bivector PointCenter::sandwich(const Bivector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter&a, const ProjectivePoint& b) noexcept {
        return {
            .x = -b.x,
            .y = -b.y,
            .z = -b.z,
            .w = b.w
        };
    }
    constexpr ProjectivePoint PointCenter::sandwich(const ProjectivePoint& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Quaternion sandwich(const PointCenter&a, const Quaternion& b) noexcept {
        return {
            .s = b.s,
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz
        };
    }
    constexpr Quaternion PointCenter::sandwich(const Quaternion& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr ProjectiveTranslator sandwich(const PointCenter&a, const ProjectiveTranslator& b) noexcept {
        return {
            .s = b.s,
            .wx = -b.wx,
            .wy = -b.wy,
            .wz = -b.wz
        };
    }
    constexpr ProjectiveTranslator PointCenter::sandwich(const ProjectiveTranslator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Translator sandwich(const PointCenter&a, const Translator& b) noexcept {
        return {
            .wx = -b.wx,
            .wy = -b.wy,
            .wz = -b.wz
        };
    }
    constexpr Translator PointCenter::sandwich(const Translator& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Vector sandwich(const PointCenter&a, const Vector& b) noexcept {
        return {
            .x = -b.x,
            .y = -b.y,
            .z = -b.z
        };
    }
    constexpr Vector PointCenter::sandwich(const Vector& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr Point sandwich(const PointCenter&a, const Point& b) noexcept {
        return {
            .x = -b.x,
            .y = -b.y,
            .z = -b.z
        };
    }
    constexpr Point PointCenter::sandwich(const Point& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal sandwich(const PointCenter&a, const PlaneIdeal& b) noexcept {
        return {
            .x = b.x,
            .y = b.y,
            .z = b.z
        };
    }
    constexpr PlaneIdeal PointCenter::sandwich(const PlaneIdeal& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorBulk sandwich(const PointCenter&a, const BivectorBulk& b) noexcept {
        return {
            .xy = b.xy,
            .xz = b.xz,
            .yz = b.yz
        };
    }
    constexpr BivectorBulk PointCenter::sandwich(const BivectorBulk& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr BivectorWeight sandwich(const PointCenter&a, const BivectorWeight& b) noexcept {
        return {
            .wx = -b.wx,
            .wy = -b.wy,
            .wz = -b.wz
        };
    }
    constexpr BivectorWeight PointCenter::sandwich(const BivectorWeight& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PseudoScalar sandwich(const PointCenter&a, const PseudoScalar& b) noexcept {
        return {
            .i = -b.i
        };
    }
    constexpr PseudoScalar PointCenter::sandwich(const PseudoScalar& b) const noexcept { return pga3d::sandwich(*this, b); }

    [[nodiscard]] constexpr PointCenter sandwich(const PointCenter&a, const PointCenter& b) noexcept {
        return {};
    }
    constexpr PointCenter PointCenter::sandwich(const PointCenter& b) const noexcept { return pga3d::sandwich(*this, b); }

}

// opsSandwichAsMatrix.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichAsMatrix

namespace pga3d {
    constexpr std::array<double, 16> Motor::sandwichAsMatrixForProjectivePoint() const noexcept {
        return {
            (s * s + yz * yz - xy * xy - xz * xz), (-2.0 * xz * yz + 2.0 * s * xy), (2.0 * s * xz + 2.0 * xy * yz), (-2.0 * i * yz - 2.0 * s * wx - 2.0 * wy * xy - 2.0 * wz * xz),
            (-2.0 * s * xy - 2.0 * xz * yz), (s * s + xz * xz - xy * xy - yz * yz), (-2.0 * xy * xz + 2.0 * s * yz), (-2.0 * s * wy - 2.0 * wz * yz + 2.0 * i * xz + 2.0 * wx * xy),
            (-2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * yz - 2.0 * xy * xz), (s * s + xy * xy - xz * xz - yz * yz), (-2.0 * i * xy - 2.0 * s * wz + 2.0 * wx * xz + 2.0 * wy * yz),
            0.0, 0.0, 0.0, (s * s + xy * xy + xz * xz + yz * yz)
        };
    }

    constexpr std::array<double, 9> Motor::sandwichAsMatrixForVector() const noexcept {
        return {
            (s * s + yz * yz - xy * xy - xz * xz), (-2.0 * xz * yz + 2.0 * s * xy), (2.0 * s * xz + 2.0 * xy * yz),
            (-2.0 * s * xy - 2.0 * xz * yz), (s * s + xz * xz - xy * xy - yz * yz), (-2.0 * xy * xz + 2.0 * s * yz),
            (-2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * yz - 2.0 * xy * xz), (s * s + xy * xy - xz * xz - yz * yz)
        };
    }

    constexpr std::array<double, 36> Motor::sandwichAsMatrixForBivector() const noexcept {
        return {
            (s * s + yz * yz - xy * xy - xz * xz), (-2.0 * xz * yz + 2.0 * s * xy), (2.0 * s * xz + 2.0 * xy * yz), (-2.0 * i * xz - 2.0 * s * wy + 2.0 * wx * xy + 2.0 * wz * yz), (-2.0 * s * wz - 2.0 * wy * yz + 2.0 * i * xy + 2.0 * wx * xz), (-2.0 * i * s - 2.0 * wz * xy + 2.0 * wx * yz + 2.0 * wy * xz),
            (-2.0 * s * xy - 2.0 * xz * yz), (s * s + xz * xz - xy * xy - yz * yz), (-2.0 * xy * xz + 2.0 * s * yz), (-2.0 * i * yz - 2.0 * wz * xz + 2.0 * s * wx + 2.0 * wy * xy), (2.0 * i * s + 2.0 * wx * yz + 2.0 * wy * xz + 2.0 * wz * xy), (-2.0 * s * wz - 2.0 * wx * xz + 2.0 * i * xy + 2.0 * wy * yz),
            (-2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * yz - 2.0 * xy * xz), (s * s + xy * xy - xz * xz - yz * yz), (-2.0 * i * s - 2.0 * wx * yz + 2.0 * wy * xz + 2.0 * wz * xy), (-2.0 * i * yz - 2.0 * wy * xy + 2.0 * s * wx + 2.0 * wz * xz), (2.0 * i * xz + 2.0 * s * wy + 2.0 * wx * xy + 2.0 * wz * yz),
            0.0, 0.0, 0.0, (s * s + xy * xy - xz * xz - yz * yz), (2.0 * s * yz + 2.0 * xy * xz), (-2.0 * s * xz + 2.0 * xy * yz),
            0.0, 0.0, 0.0, (-2.0 * s * yz + 2.0 * xy * xz), (s * s + xz * xz - xy * xy - yz * yz), (2.0 * s * xy + 2.0 * xz * yz),
            0.0, 0.0, 0.0, (2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * xy + 2.0 * xz * yz), (s * s + yz * yz - xy * xy - xz * xz)
        };
    }

    constexpr std::array<double, 16> Motor::sandwichAsMatrixForPlane() const noexcept {
        return {
            (s * s + yz * yz - xy * xy - xz * xz), (-2.0 * xz * yz + 2.0 * s * xy), (2.0 * s * xz + 2.0 * xy * yz), 0.0,
            (-2.0 * s * xy - 2.0 * xz * yz), (s * s + xz * xz - xy * xy - yz * yz), (-2.0 * xy * xz + 2.0 * s * yz), 0.0,
            (-2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * yz - 2.0 * xy * xz), (s * s + xy * xy - xz * xz - yz * yz), 0.0,
            (-2.0 * wy * xy - 2.0 * wz * xz + 2.0 * i * yz + 2.0 * s * wx), (-2.0 * i * xz - 2.0 * wz * yz + 2.0 * s * wy + 2.0 * wx * xy), (2.0 * i * xy + 2.0 * s * wz + 2.0 * wx * xz + 2.0 * wy * yz), (s * s + xy * xy + xz * xz + yz * yz)
        };
    }

    constexpr std::array<double, 16> Quaternion::sandwichAsMatrixForProjectivePoint() const noexcept {
        return {
            (s * s + yz * yz - xy * xy - xz * xz), (-2.0 * xz * yz + 2.0 * s * xy), (2.0 * s * xz + 2.0 * xy * yz), 0.0,
            (-2.0 * s * xy - 2.0 * xz * yz), (s * s + xz * xz - xy * xy - yz * yz), (-2.0 * xy * xz + 2.0 * s * yz), 0.0,
            (-2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * yz - 2.0 * xy * xz), (s * s + xy * xy - xz * xz - yz * yz), 0.0,
            0.0, 0.0, 0.0, (s * s + xy * xy + xz * xz + yz * yz)
        };
    }

    constexpr std::array<double, 9> Quaternion::sandwichAsMatrixForVector() const noexcept {
        return {
            (s * s + yz * yz - xy * xy - xz * xz), (-2.0 * xz * yz + 2.0 * s * xy), (2.0 * s * xz + 2.0 * xy * yz),
            (-2.0 * s * xy - 2.0 * xz * yz), (s * s + xz * xz - xy * xy - yz * yz), (-2.0 * xy * xz + 2.0 * s * yz),
            (-2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * yz - 2.0 * xy * xz), (s * s + xy * xy - xz * xz - yz * yz)
        };
    }

    constexpr std::array<double, 36> Quaternion::sandwichAsMatrixForBivector() const noexcept {
        return {
            (s * s + yz * yz - xy * xy - xz * xz), (-2.0 * xz * yz + 2.0 * s * xy), (2.0 * s * xz + 2.0 * xy * yz), 0.0, 0.0, 0.0,
            (-2.0 * s * xy - 2.0 * xz * yz), (s * s + xz * xz - xy * xy - yz * yz), (-2.0 * xy * xz + 2.0 * s * yz), 0.0, 0.0, 0.0,
            (-2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * yz - 2.0 * xy * xz), (s * s + xy * xy - xz * xz - yz * yz), 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, (s * s + xy * xy - xz * xz - yz * yz), (2.0 * s * yz + 2.0 * xy * xz), (-2.0 * s * xz + 2.0 * xy * yz),
            0.0, 0.0, 0.0, (-2.0 * s * yz + 2.0 * xy * xz), (s * s + xz * xz - xy * xy - yz * yz), (2.0 * s * xy + 2.0 * xz * yz),
            0.0, 0.0, 0.0, (2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * xy + 2.0 * xz * yz), (s * s + yz * yz - xy * xy - xz * xz)
        };
    }

    constexpr std::array<double, 16> Quaternion::sandwichAsMatrixForPlane() const noexcept {
        return {
            (s * s + yz * yz - xy * xy - xz * xz), (-2.0 * xz * yz + 2.0 * s * xy), (2.0 * s * xz + 2.0 * xy * yz), 0.0,
            (-2.0 * s * xy - 2.0 * xz * yz), (s * s + xz * xz - xy * xy - yz * yz), (-2.0 * xy * xz + 2.0 * s * yz), 0.0,
            (-2.0 * s * xz + 2.0 * xy * yz), (-2.0 * s * yz - 2.0 * xy * xz), (s * s + xy * xy - xz * xz - yz * yz), 0.0,
            0.0, 0.0, 0.0, (s * s + xy * xy + xz * xz + yz * yz)
        };
    }
}

// opsCross.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

namespace pga3d {
    [[nodiscard]] constexpr Multivector cross(const Multivector& a,const Multivector& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z + a.xyz * b.i - a.i * b.xyz - a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = (a.xy * b.y + a.xz * b.z - a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy + a.yz * b.z - a.xy * b.x - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz - a.xz * b.x - a.yz * b.y),
        .wx = (a.w * b.x + a.xy * b.wy + a.xyz * b.wyz + a.xz * b.wz - a.wy * b.xy - a.wyz * b.xyz - a.wz * b.xz - a.x * b.w),
        .wy = (a.w * b.y + a.wx * b.xy + a.wxz * b.xyz + a.yz * b.wz - a.wz * b.yz - a.xy * b.wx - a.xyz * b.wxz - a.y * b.w),
        .wz = (a.w * b.z + a.wx * b.xz + a.wy * b.yz + a.xyz * b.wxy - a.wxy * b.xyz - a.xz * b.wx - a.yz * b.wy - a.z * b.w),
        .xy = (a.x * b.y + a.yz * b.xz - a.xz * b.yz - a.y * b.x),
        .xz = (a.x * b.z + a.xy * b.yz - a.yz * b.xy - a.z * b.x),
        .yz = (a.xz * b.xy + a.y * b.z - a.xy * b.xz - a.z * b.y),
        .wxy = (a.i * b.z + a.wyz * b.xz + a.wz * b.xyz + a.yz * b.wxz - a.wxz * b.yz - a.xyz * b.wz - a.xz * b.wyz - a.z * b.i),
        .wxz = (a.wxy * b.yz + a.xy * b.wyz + a.xyz * b.wy + a.y * b.i - a.i * b.y - a.wy * b.xyz - a.wyz * b.xy - a.yz * b.wxy),
        .wyz = (a.i * b.x + a.wx * b.xyz + a.wxz * b.xy + a.xz * b.wxy - a.wxy * b.xz - a.x * b.i - a.xy * b.wxz - a.xyz * b.wx),
        .xyz = 0.0,
        .i = (a.w * b.xyz + a.wxy * b.z + a.wyz * b.x + a.y * b.wxz - a.wxz * b.y - a.x * b.wyz - a.xyz * b.w - a.z * b.wxy)
    }; }
    constexpr Multivector Multivector::cross(const Multivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Motor& a,const Motor& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.yz * b.wz - a.wz * b.yz - a.xy * b.wx),
        .wz = (a.wx * b.xz + a.wy * b.yz - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Motor::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const Motor& a,const Plane& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.i * b.z,
        .wxz = -a.i * b.y,
        .wyz = a.i * b.x,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Motor::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Motor& a,const Bivector& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.yz * b.wz - a.wz * b.yz - a.xy * b.wx),
        .wz = (a.wx * b.xz + a.wy * b.yz - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Motor::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const Motor& a,const ProjectivePoint& b) noexcept { return {
        .s = 0.0,
        .w = -a.i * b.w,
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wz * b.w + a.xz * b.x + a.yz * b.y),
        .wxz = (a.yz * b.z - a.wy * b.w - a.xy * b.x),
        .wyz = (a.wx * b.w - a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Motor::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Motor& a,const Quaternion& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Motor::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Motor& a,const ProjectiveTranslator& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight Motor::cross(const ProjectiveTranslator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Motor& a,const Translator& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight Motor::cross(const Translator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Motor& a,const Vector& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector Motor::cross(const Vector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const Motor& a,const Point& b) noexcept { return {
        .s = 0.0,
        .w = -a.i,
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (a.wz + a.xz * b.x + a.yz * b.y),
        .wxz = (-a.wy + a.yz * b.z - a.xy * b.x),
        .wyz = (a.wx - a.xy * b.y - a.xz * b.z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Motor::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const Motor& a,const PlaneIdeal& b) noexcept { return {
        .s = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z),
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.i * b.z,
        .wxz = -a.i * b.y,
        .wyz = a.i * b.x,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Motor::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Motor& a,const BivectorBulk& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Motor::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Motor& a,const BivectorWeight& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight Motor::cross(const BivectorWeight& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const Motor& a,const PointCenter& b) noexcept { return {
        .s = 0.0,
        .w = -a.i,
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = a.wz,
        .wxz = -a.wy,
        .wyz = a.wx,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Motor::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const Plane& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.i,
        .wxz = a.y * b.i,
        .wyz = -a.x * b.i,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Plane::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Plane& a,const Plane& b) noexcept { return {
        .wx = (a.w * b.x - a.x * b.w),
        .wy = (a.w * b.y - a.y * b.w),
        .wz = (a.w * b.z - a.z * b.w),
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Bivector Plane::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const Plane& a,const Bivector& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane Plane::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const Plane& a,const ProjectivePoint& b) noexcept { return {
        .i = (a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar Plane::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal cross(const Plane& a,const Quaternion& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr PlaneIdeal Plane::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const Plane& a,const ProjectiveTranslator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane Plane::cross(const ProjectiveTranslator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const Plane& a,const Translator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane Plane::cross(const Translator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const Plane& a,const Vector& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar Plane::cross(const Vector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const Plane& a,const Point& b) noexcept { return {
        .i = (a.w + a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar Plane::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Plane& a,const PlaneIdeal& b) noexcept { return {
        .wx = a.w * b.x,
        .wy = a.w * b.y,
        .wz = a.w * b.z,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Bivector Plane::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal cross(const Plane& a,const BivectorBulk& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr PlaneIdeal Plane::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const Plane& a,const BivectorWeight& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane Plane::cross(const BivectorWeight& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Plane& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr Vector Plane::cross(const PseudoScalar& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const Plane& a,const PointCenter& b) noexcept { return {
        .i = a.w
    }; }
    constexpr PseudoScalar Plane::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Bivector& a,const Motor& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.yz * b.wz - a.wz * b.yz - a.xy * b.wx),
        .wz = (a.wx * b.xz + a.wy * b.yz - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Bivector::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const Bivector& a,const Plane& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane Bivector::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Bivector& a,const Bivector& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz - a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy + a.yz * b.wz - a.wz * b.yz - a.xy * b.wx),
        .wz = (a.wx * b.xz + a.wy * b.yz - a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Bivector::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Bivector& a,const ProjectivePoint& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z - a.wx * b.w),
        .y = (a.yz * b.z - a.wy * b.w - a.xy * b.x),
        .z = (-a.wz * b.w - a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector Bivector::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Bivector& a,const Quaternion& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Bivector::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Bivector& a,const ProjectiveTranslator& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight Bivector::cross(const ProjectiveTranslator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Bivector& a,const Translator& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight Bivector::cross(const Translator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Bivector& a,const Vector& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector Bivector::cross(const Vector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Bivector& a,const Point& b) noexcept { return {
        .x = (-a.wx + a.xy * b.y + a.xz * b.z),
        .y = (-a.wy + a.yz * b.z - a.xy * b.x),
        .z = (-a.wz - a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector Bivector::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const Bivector& a,const PlaneIdeal& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y),
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane Bivector::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Bivector& a,const BivectorBulk& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Bivector::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Bivector& a,const BivectorWeight& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight Bivector::cross(const BivectorWeight& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Bivector& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Vector Bivector::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const ProjectivePoint& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = a.w * b.i,
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-a.w * b.wz - a.x * b.xz - a.y * b.yz),
        .wxz = (a.w * b.wy + a.x * b.xy - a.z * b.yz),
        .wyz = (a.y * b.xy + a.z * b.xz - a.w * b.wx),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const ProjectivePoint& a,const Plane& b) noexcept { return {
        .i = (-a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr PseudoScalar ProjectivePoint::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const ProjectivePoint& a,const Bivector& b) noexcept { return {
        .x = (a.w * b.wx - a.y * b.xy - a.z * b.xz),
        .y = (a.w * b.wy + a.x * b.xy - a.z * b.yz),
        .z = (a.w * b.wz + a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector ProjectivePoint::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& a,const ProjectivePoint& b) noexcept { return {
        .wx = (a.x * b.w - a.w * b.x),
        .wy = (a.y * b.w - a.w * b.y),
        .wz = (a.z * b.w - a.w * b.z)
    }; }
    constexpr BivectorWeight ProjectivePoint::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const ProjectivePoint& a,const Quaternion& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector ProjectivePoint::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const ProjectivePoint& a,const ProjectiveTranslator& b) noexcept { return {
        .x = a.w * b.wx,
        .y = a.w * b.wy,
        .z = a.w * b.wz
    }; }
    constexpr Vector ProjectivePoint::cross(const ProjectiveTranslator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const ProjectivePoint& a,const Translator& b) noexcept { return {
        .x = a.w * b.wx,
        .y = a.w * b.wy,
        .z = a.w * b.wz
    }; }
    constexpr Vector ProjectivePoint::cross(const Translator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& a,const Vector& b) noexcept { return {
        .wx = -a.w * b.x,
        .wy = -a.w * b.y,
        .wz = -a.w * b.z
    }; }
    constexpr BivectorWeight ProjectivePoint::cross(const Vector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& a,const Point& b) noexcept { return {
        .wx = (a.x - a.w * b.x),
        .wy = (a.y - a.w * b.y),
        .wz = (a.z - a.w * b.z)
    }; }
    constexpr BivectorWeight ProjectivePoint::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const ProjectivePoint& a,const PlaneIdeal& b) noexcept { return {
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr PseudoScalar ProjectivePoint::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const ProjectivePoint& a,const BivectorBulk& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector ProjectivePoint::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const ProjectivePoint& a,const BivectorWeight& b) noexcept { return {
        .x = a.w * b.wx,
        .y = a.w * b.wy,
        .z = a.w * b.wz
    }; }
    constexpr Vector ProjectivePoint::cross(const BivectorWeight& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const ProjectivePoint& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = a.w * b.i
    }; }
    constexpr Plane ProjectivePoint::cross(const PseudoScalar& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& a,const PointCenter& b) noexcept { return {
        .wx = a.x,
        .wy = a.y,
        .wz = a.z
    }; }
    constexpr BivectorWeight ProjectivePoint::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Quaternion& a,const Motor& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Quaternion::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal cross(const Quaternion& a,const Plane& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr PlaneIdeal Quaternion::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const Quaternion& a,const Bivector& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector Quaternion::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Quaternion& a,const ProjectivePoint& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector Quaternion::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorBulk cross(const Quaternion& a,const Quaternion& b) noexcept { return {
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr BivectorBulk Quaternion::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Quaternion& a,const ProjectiveTranslator& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight Quaternion::cross(const ProjectiveTranslator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Quaternion& a,const Translator& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight Quaternion::cross(const Translator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Quaternion& a,const Vector& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector Quaternion::cross(const Vector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Quaternion& a,const Point& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector Quaternion::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal cross(const Quaternion& a,const PlaneIdeal& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr PlaneIdeal Quaternion::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorBulk cross(const Quaternion& a,const BivectorBulk& b) noexcept { return {
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr BivectorBulk Quaternion::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Quaternion& a,const BivectorWeight& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight Quaternion::cross(const BivectorWeight& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& a,const Motor& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight ProjectiveTranslator::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const ProjectiveTranslator& a,const Plane& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane ProjectiveTranslator::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& a,const Bivector& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight ProjectiveTranslator::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const ProjectiveTranslator& a,const ProjectivePoint& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w
    }; }
    constexpr Vector ProjectiveTranslator::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& a,const Quaternion& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight ProjectiveTranslator::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const ProjectiveTranslator& a,const Point& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Vector ProjectiveTranslator::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const ProjectiveTranslator& a,const PlaneIdeal& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane ProjectiveTranslator::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& a,const BivectorBulk& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight ProjectiveTranslator::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const ProjectiveTranslator& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Vector ProjectiveTranslator::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Translator& a,const Motor& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight Translator::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const Translator& a,const Plane& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane Translator::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Translator& a,const Bivector& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight Translator::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Translator& a,const ProjectivePoint& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w
    }; }
    constexpr Vector Translator::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Translator& a,const Quaternion& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight Translator::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Translator& a,const Point& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Vector Translator::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const Translator& a,const PlaneIdeal& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane Translator::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Translator& a,const BivectorBulk& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight Translator::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Translator& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Vector Translator::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Vector& a,const Motor& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector Vector::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const Vector& a,const Plane& b) noexcept { return {
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr PseudoScalar Vector::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Vector& a,const Bivector& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector Vector::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Vector& a,const ProjectivePoint& b) noexcept { return {
        .wx = a.x * b.w,
        .wy = a.y * b.w,
        .wz = a.z * b.w
    }; }
    constexpr BivectorWeight Vector::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Vector& a,const Quaternion& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector Vector::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Vector& a,const Point& b) noexcept { return {
        .wx = a.x,
        .wy = a.y,
        .wz = a.z
    }; }
    constexpr BivectorWeight Vector::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const Vector& a,const PlaneIdeal& b) noexcept { return {
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr PseudoScalar Vector::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Vector& a,const BivectorBulk& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector Vector::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Vector& a,const PointCenter& b) noexcept { return {
        .wx = a.x,
        .wy = a.y,
        .wz = a.z
    }; }
    constexpr BivectorWeight Vector::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const Point& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = b.i,
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (-b.wz - a.x * b.xz - a.y * b.yz),
        .wxz = (b.wy + a.x * b.xy - a.z * b.yz),
        .wyz = (-b.wx + a.y * b.xy + a.z * b.xz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Point::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const Point& a,const Plane& b) noexcept { return {
        .i = (-b.w - a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr PseudoScalar Point::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Point& a,const Bivector& b) noexcept { return {
        .x = (b.wx - a.y * b.xy - a.z * b.xz),
        .y = (b.wy + a.x * b.xy - a.z * b.yz),
        .z = (b.wz + a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector Point::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Point& a,const ProjectivePoint& b) noexcept { return {
        .wx = (-b.x + a.x * b.w),
        .wy = (-b.y + a.y * b.w),
        .wz = (-b.z + a.z * b.w)
    }; }
    constexpr BivectorWeight Point::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Point& a,const Quaternion& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector Point::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Point& a,const ProjectiveTranslator& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Vector Point::cross(const ProjectiveTranslator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Point& a,const Translator& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Vector Point::cross(const Translator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Point& a,const Vector& b) noexcept { return {
        .wx = -b.x,
        .wy = -b.y,
        .wz = -b.z
    }; }
    constexpr BivectorWeight Point::cross(const Vector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Point& a,const Point& b) noexcept { return {
        .wx = (a.x - b.x),
        .wy = (a.y - b.y),
        .wz = (a.z - b.z)
    }; }
    constexpr BivectorWeight Point::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const Point& a,const PlaneIdeal& b) noexcept { return {
        .i = (-a.x * b.x - a.y * b.y - a.z * b.z)
    }; }
    constexpr PseudoScalar Point::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Point& a,const BivectorBulk& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr Vector Point::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const Point& a,const BivectorWeight& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Vector Point::cross(const BivectorWeight& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const Point& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr Plane Point::cross(const PseudoScalar& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const Point& a,const PointCenter& b) noexcept { return {
        .wx = a.x,
        .wy = a.y,
        .wz = a.z
    }; }
    constexpr BivectorWeight Point::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const PlaneIdeal& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz),
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -a.z * b.i,
        .wxz = a.y * b.i,
        .wyz = -a.x * b.i,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const PlaneIdeal& a,const Plane& b) noexcept { return {
        .wx = -a.x * b.w,
        .wy = -a.y * b.w,
        .wz = -a.z * b.w,
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr Bivector PlaneIdeal::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const PlaneIdeal& a,const Bivector& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz),
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane PlaneIdeal::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const PlaneIdeal& a,const ProjectivePoint& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar PlaneIdeal::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal cross(const PlaneIdeal& a,const Quaternion& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr PlaneIdeal PlaneIdeal::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const PlaneIdeal& a,const ProjectiveTranslator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane PlaneIdeal::cross(const ProjectiveTranslator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const PlaneIdeal& a,const Translator& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane PlaneIdeal::cross(const Translator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const PlaneIdeal& a,const Vector& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar PlaneIdeal::cross(const Vector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const PlaneIdeal& a,const Point& b) noexcept { return {
        .i = (a.x * b.x + a.y * b.y + a.z * b.z)
    }; }
    constexpr PseudoScalar PlaneIdeal::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorBulk cross(const PlaneIdeal& a,const PlaneIdeal& b) noexcept { return {
        .xy = (a.x * b.y - a.y * b.x),
        .xz = (a.x * b.z - a.z * b.x),
        .yz = (a.y * b.z - a.z * b.y)
    }; }
    constexpr BivectorBulk PlaneIdeal::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal cross(const PlaneIdeal& a,const BivectorBulk& b) noexcept { return {
        .x = (-a.y * b.xy - a.z * b.xz),
        .y = (a.x * b.xy - a.z * b.yz),
        .z = (a.x * b.xz + a.y * b.yz)
    }; }
    constexpr PlaneIdeal PlaneIdeal::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const PlaneIdeal& a,const BivectorWeight& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (-a.x * b.wx - a.y * b.wy - a.z * b.wz)
    }; }
    constexpr Plane PlaneIdeal::cross(const BivectorWeight& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const PlaneIdeal& a,const PseudoScalar& b) noexcept { return {
        .x = a.x * b.i,
        .y = a.y * b.i,
        .z = a.z * b.i
    }; }
    constexpr Vector PlaneIdeal::cross(const PseudoScalar& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const BivectorBulk& a,const Motor& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector BivectorBulk::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal cross(const BivectorBulk& a,const Plane& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr PlaneIdeal BivectorBulk::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Bivector cross(const BivectorBulk& a,const Bivector& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy),
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr Bivector BivectorBulk::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const BivectorBulk& a,const ProjectivePoint& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector BivectorBulk::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorBulk cross(const BivectorBulk& a,const Quaternion& b) noexcept { return {
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr BivectorBulk BivectorBulk::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const BivectorBulk& a,const ProjectiveTranslator& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight BivectorBulk::cross(const ProjectiveTranslator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const BivectorBulk& a,const Translator& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight BivectorBulk::cross(const Translator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const BivectorBulk& a,const Vector& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector BivectorBulk::cross(const Vector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const BivectorBulk& a,const Point& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr Vector BivectorBulk::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PlaneIdeal cross(const BivectorBulk& a,const PlaneIdeal& b) noexcept { return {
        .x = (a.xy * b.y + a.xz * b.z),
        .y = (a.yz * b.z - a.xy * b.x),
        .z = (-a.xz * b.x - a.yz * b.y)
    }; }
    constexpr PlaneIdeal BivectorBulk::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorBulk cross(const BivectorBulk& a,const BivectorBulk& b) noexcept { return {
        .xy = (a.yz * b.xz - a.xz * b.yz),
        .xz = (a.xy * b.yz - a.yz * b.xy),
        .yz = (a.xz * b.xy - a.xy * b.xz)
    }; }
    constexpr BivectorBulk BivectorBulk::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const BivectorBulk& a,const BivectorWeight& b) noexcept { return {
        .wx = (a.xy * b.wy + a.xz * b.wz),
        .wy = (a.yz * b.wz - a.xy * b.wx),
        .wz = (-a.xz * b.wx - a.yz * b.wy)
    }; }
    constexpr BivectorWeight BivectorBulk::cross(const BivectorWeight& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& a,const Motor& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight BivectorWeight::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const BivectorWeight& a,const Plane& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane BivectorWeight::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& a,const Bivector& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight BivectorWeight::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const BivectorWeight& a,const ProjectivePoint& b) noexcept { return {
        .x = -a.wx * b.w,
        .y = -a.wy * b.w,
        .z = -a.wz * b.w
    }; }
    constexpr Vector BivectorWeight::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& a,const Quaternion& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight BivectorWeight::cross(const Quaternion& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const BivectorWeight& a,const Point& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Vector BivectorWeight::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const BivectorWeight& a,const PlaneIdeal& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (a.wx * b.x + a.wy * b.y + a.wz * b.z)
    }; }
    constexpr Plane BivectorWeight::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& a,const BivectorBulk& b) noexcept { return {
        .wx = (-a.wy * b.xy - a.wz * b.xz),
        .wy = (a.wx * b.xy - a.wz * b.yz),
        .wz = (a.wx * b.xz + a.wy * b.yz)
    }; }
    constexpr BivectorWeight BivectorWeight::cross(const BivectorBulk& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const BivectorWeight& a,const PointCenter& b) noexcept { return {
        .x = -a.wx,
        .y = -a.wy,
        .z = -a.wz
    }; }
    constexpr Vector BivectorWeight::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const PseudoScalar& a,const Plane& b) noexcept { return {
        .x = -a.i * b.x,
        .y = -a.i * b.y,
        .z = -a.i * b.z
    }; }
    constexpr Vector PseudoScalar::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const PseudoScalar& a,const ProjectivePoint& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.i * b.w
    }; }
    constexpr Plane PseudoScalar::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const PseudoScalar& a,const Point& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.i
    }; }
    constexpr Plane PseudoScalar::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const PseudoScalar& a,const PlaneIdeal& b) noexcept { return {
        .x = -a.i * b.x,
        .y = -a.i * b.y,
        .z = -a.i * b.z
    }; }
    constexpr Vector PseudoScalar::cross(const PlaneIdeal& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const PseudoScalar& a,const PointCenter& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -a.i
    }; }
    constexpr Plane PseudoScalar::cross(const PointCenter& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Multivector cross(const PointCenter& a,const Motor& b) noexcept { return {
        .s = 0.0,
        .w = b.i,
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = -b.wz,
        .wxz = b.wy,
        .wyz = -b.wx,
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector PointCenter::cross(const Motor& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr PseudoScalar cross(const PointCenter& a,const Plane& b) noexcept { return {
        .i = -b.w
    }; }
    constexpr PseudoScalar PointCenter::cross(const Plane& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const PointCenter& a,const Bivector& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Vector PointCenter::cross(const Bivector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const PointCenter& a,const ProjectivePoint& b) noexcept { return {
        .wx = -b.x,
        .wy = -b.y,
        .wz = -b.z
    }; }
    constexpr BivectorWeight PointCenter::cross(const ProjectivePoint& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const PointCenter& a,const ProjectiveTranslator& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Vector PointCenter::cross(const ProjectiveTranslator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const PointCenter& a,const Translator& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Vector PointCenter::cross(const Translator& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const PointCenter& a,const Vector& b) noexcept { return {
        .wx = -b.x,
        .wy = -b.y,
        .wz = -b.z
    }; }
    constexpr BivectorWeight PointCenter::cross(const Vector& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr BivectorWeight cross(const PointCenter& a,const Point& b) noexcept { return {
        .wx = -b.x,
        .wy = -b.y,
        .wz = -b.z
    }; }
    constexpr BivectorWeight PointCenter::cross(const Point& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Vector cross(const PointCenter& a,const BivectorWeight& b) noexcept { return {
        .x = b.wx,
        .y = b.wy,
        .z = b.wz
    }; }
    constexpr Vector PointCenter::cross(const BivectorWeight& b) const noexcept { return pga3d::cross(*this, b); }

    [[nodiscard]] constexpr Plane cross(const PointCenter& a,const PseudoScalar& b) noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr Plane PointCenter::cross(const PseudoScalar& b) const noexcept { return pga3d::cross(*this, b); }

}

// pga3d.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

// Edge.h

namespace pga3d {
    struct Edge {
        Point a = {};
        Point b = {};

        [[nodiscard]] constexpr Point center() const noexcept {
            return Point::mid(a, b);
        }

        [[nodiscard]] constexpr Vector ab() const noexcept {
            return b - a;
        }

        [[nodiscard]] constexpr Bivector line() const noexcept {
            return a.antiWedge(b);
        }

        [[nodiscard]] constexpr Point interpolatedPoint(const double t) const noexcept {
          return Point::interpolate(a, b, t);
        }

        [[nodiscard]] constexpr Edge reversed() const noexcept {
            return {b, a};
        }

        constexpr void reverse() noexcept {
            *this = reversed();
        }

        [[nodiscard]] double magnitude() const noexcept {
            return ab().norm();
        }

        [[nodiscard]] constexpr double magnitudeSquare() const noexcept {
            return ab().normSquare();
        }

    };
}

// Triangle.h

namespace pga3d {
    struct Triangle {
        Point a = {};
        Point b = {};
        Point c = {};

        [[nodiscard]] constexpr Vector ab() const noexcept { return b - a; }
        [[nodiscard]] constexpr Vector ac() const noexcept { return c - a; }
        [[nodiscard]] constexpr Vector bc() const noexcept { return c - b; }

        [[nodiscard]] constexpr Point center() const noexcept {
            return Point::mid(a, b, c);
        }

        [[nodiscard]] constexpr Plane plane() const noexcept {
            return a.antiWedge(b).antiWedge(c);
        }

        [[nodiscard]] double perimeter() const noexcept {
            return ab().norm() + ac().norm() + bc().norm();
        }

        [[nodiscard]] double area() const noexcept {
            return 0.5 * ab().antiWedge(ac()).norm();
        }
    };
}

// Cylinder.h

namespace pga3d {
    struct Cylinder {
        Point a = {};
        Point b = {};
        double r = 0.0;

        [[nodiscard]] constexpr Point center() const noexcept {
            return Point::mid(a, b);
        }

        [[nodiscard]] constexpr Vector ab() const noexcept {
            return b - a;
        }

        [[nodiscard]] constexpr Bivector line() const noexcept {
            return a.antiWedge(b);
        }
    };
}

// Sphere.h

namespace pga3d {
    struct Sphere {
        Point center = {};
        double radius = 0.0;

        [[nodiscard]] constexpr bool contains(const Point& point) const noexcept {
            const Vector dr = point - center;
            const double drNormSquare = dr.normSquare();
            return drNormSquare <= radius * radius;
        }

        [[nodiscard]] Point clamp(const Point& point) const noexcept {
            const Vector dr = point - center;
            const double drNormSquare = dr.normSquare();
            if (drNormSquare <= radius * radius) {
                return point;
            }

            const double drNorm = std::sqrt(drNormSquare);
            return center + dr * (radius / (drNorm + 1e-100));
        }

        [[nodiscard]] constexpr Vector clampDR(const Point& point) const noexcept {
            const Vector dr = point - center;
            const double drNormSquare = dr.normSquare();
            if (drNormSquare <= radius * radius) {
                return dr;
            }

            const double drNorm = std::sqrt(drNormSquare);
            return dr * (radius / (drNorm + 1e-100));
        }
    };
}

// AABB.h

namespace pga3d {
    struct AABB {
        Point min = {};
        Point max = {};

        [[nodiscard]] constexpr Vector size() const noexcept {
            return max - min;
        }

        [[nodiscard]] constexpr Vector halfSize() const noexcept {
            return size() * 0.5;
        }

        [[nodiscard]] constexpr double volume() const noexcept {
            const Vector s = size();
            return s.x * s.y * s.z;
        }

        [[nodiscard]] constexpr double surfaceArea() const noexcept {
            const Vector s = size();
            return 2.0 * (s.x * s.y + s.x * s.z + s.y * s.z);
        }

        [[nodiscard]] constexpr Point center() const noexcept {
            return Point::mid(min, max);
        }

        [[nodiscard]] constexpr Point clamp(const Point& point) const noexcept {
            return point.clamp(min, max);
        }

        [[nodiscard]] inline double distanceTo(const Point& point) const noexcept {
            const Point clamped = clamp(point);
            return clamped.distanceTo(point);
        }

        [[nodiscard]] constexpr bool contains(const Point& point) const noexcept {
            return point.x >= min.x && point.x <= max.x &&
                   point.y >= min.y && point.y <= max.y &&
                   point.z >= min.z && point.z <= max.z;
        }

        [[nodiscard]] constexpr bool contains(const AABB& aabb) const noexcept {
            return contains(aabb.min) && contains(aabb.max);
        }

        [[nodiscard]] constexpr AABB expanded(const Vector& eps) const noexcept {
            return {
                .min = min - eps,
                .max = max + eps
            };
        }

        [[nodiscard]] constexpr AABB expanded(const double eps) const noexcept {
            return expanded(Vector{eps, eps, eps});
        }

        constexpr void expand(const Vector& eps) noexcept {
            *this = expanded(eps);
        }

        constexpr void expand(const double eps) noexcept {
            *this = expanded(eps);
        }

        [[nodiscard]] constexpr AABB merged(const AABB& other) const noexcept {
            return {
                .min = min.min(other.min),
                .max = max.max(other.max),
            };
        }

        [[nodiscard]] constexpr AABB merged(const Point& p) const noexcept {
            return {
                .min = min.min(p),
                .max = max.max(p),
            };
        }

        constexpr void merge(const AABB& other) noexcept {
            *this = merged(other);
        }

        constexpr void merge(const Point& p) noexcept {
            *this = merged(p);
        }
    };
}

// Energy.h

namespace pga3d {
    template<class T>
    concept HasEnergy =
            requires(const T &obj) {
                { energy(obj) } -> std::same_as<double>;
            };

    template<class T>
    concept HasEnergyMethod =
            requires(const T &obj) {
                { obj.energy() } -> std::same_as<double>;
            };

    template<HasEnergyMethod T>
    auto energy(const T &obj) {
        return obj.energy();
    }

    template<HasEnergy T>
    double energy(const std::span<const T>& elems) {
        double totalEnergy = 0.0;
        for (const auto &elem: elems) {
            totalEnergy += energy(elem);
        }
        return totalEnergy;
    }

    template<HasEnergy T>
    double energy(const std::vector<T>& elems) {
        double totalEnergy = 0.0;
        for (const auto &elem: elems) {
            totalEnergy += energy(elem);
        }
        return totalEnergy;
    }
}

// Forque.h

namespace pga3d {
    struct Forque {
        [[nodiscard]] static constexpr Bivector force(const Point& point, const Vector& force) noexcept{
            return point.antiWedge(force);
        }

        [[nodiscard]] static constexpr Bivector force(const Point& point, const Point& endPoint) noexcept{
            return point.antiWedge(endPoint);
        }

        [[nodiscard]] static constexpr Bivector torque(const Vector &torque) noexcept {
            return Bivector{.wx = torque.x, .wy = torque.y, .wz = torque.z, .xy = 0.0, .xz = 0.0, .yz = 0.0};
        }

        [[nodiscard]] static constexpr Vector extractLinearForce(const Bivector &forque) noexcept {
            const Bivector fd = forque.dual();
            return {.x = fd.wx, .y = fd.wy, .z = fd.wz};
        }

        [[nodiscard]] static constexpr Point getCenter(const Bivector &forque) noexcept {
            const Vector v = extractLinearForce(forque);
            const double vNormSquare = v.normSquare();

            if (vNormSquare > 1e-100) {
                const Vector w{.x = forque.wx, .y = forque.wy, .z = forque.wz};
                const BivectorWeight result = (v.dual().cross(w.dual())).dual() / vNormSquare;
                return Point{result.wx, result.wy, result.wz};
            } else {
                // pure torque
                return Point{0.0, 0.0, 0.0};
            }
        }

        [[nodiscard]] static constexpr Vector extractTorqueAroundCenter(const Bivector &forque) noexcept {
            const Vector v = extractLinearForce(forque);
            const double vNormSquare = v.normSquare();
            if (vNormSquare > 1e-100) {
                const double inv = 1.0 / std::sqrt(vNormSquare);
                return {.x = forque.wx * v.x * inv, .y = forque.wy * v.y * inv, .z = forque.wz * v.z * inv};
            } else {
                return {.x = forque.wx, .y = forque.wy, .z = forque.wz};
            }
        }

        [[nodiscard]] static Bivector spring(const Point &current, const Point &another, double k, double springLength) noexcept {
            const Vector dir = another - current;
            const double dirDist = dir.norm();
            return force(current, dir * (k * (dirDist - springLength) / (dirDist + 1e-100)));
        }
    };
}

// Velocity.h

namespace pga3d {
    class Velocity {
        [[nodiscard]] static constexpr BivectorWeight linear(const Vector& v) noexcept {
            return {.wx = v.x, .wy = v.y, .wz = v.z};
        }

        [[nodiscard]] static constexpr BivectorBulk angular(double xy, double xz, double yz) noexcept {
            return {.xy = xy, .xz = xz, .yz = yz};
        }

        [[nodiscard]] static constexpr Bivector angular(const BivectorBulk& w, const Point& rotationCenter) noexcept {
            return w - linear(pointLinearVelocity(rotationCenter, w));
        }

        [[nodiscard]] static constexpr Vector pointLinearVelocity(const Point& point, const Bivector& velocity) noexcept {
            return point.cross(velocity);
        }

        [[nodiscard]] static constexpr Vector pointLinearVelocity(const Point& point, const BivectorWeight& velocity) noexcept {
            return point.cross(velocity);
        }

        [[nodiscard]] static constexpr Vector pointLinearVelocity(const Point& point, const BivectorBulk& velocity) noexcept {
            return point.cross(velocity);
        }
    };
}

// Inertia.h

//
// Helper formulas for inertia construction
//
namespace pga3d::inertia {
    [[nodiscard]] static constexpr double diskInPlane(const double r, const double innerR = 0.0) noexcept {
        return 0.5 * (r * r + innerR * innerR);
    }

    [[nodiscard]] static constexpr double diskXX(const double r, const double innerR = 0.0) noexcept {
        return 0.25 * (r * r + innerR * innerR);
    }

    [[nodiscard]] static constexpr double rodAlongAxis(const double length) noexcept {
        return length * length / 12;
    }
}

// InertiaLocalSphere.h

namespace pga3d {
    /**
     * Fully symmetrical tensor of inertia (for example, for cube or sphere).
     * It has no precession, and computations are simpler and faster
     *
     * @param mass - mass
     * @param mr2  - square of effective radius multiplied by mass
     */
    struct InertiaLocalSphere {
        double mass = 0.0;
        double mr2 = 0.0;

        [[nodiscard]] constexpr double mryz() const noexcept { return mr2; }
        [[nodiscard]] constexpr double mrxz() const noexcept { return mr2; }
        [[nodiscard]] constexpr double mrxy() const noexcept { return mr2; }

        [[nodiscard]] constexpr Bivector operator()(const Bivector& velocity) const noexcept {
            return Bivector {
                .wx = velocity.yz * mr2,
                .wy = -velocity.xz * mr2,
                .wz = velocity.xy * mr2,
                .xy = velocity.wz * mass,
                .xz = -velocity.wy * mass,
                .yz = velocity.wx * mass,
              };
        }

        [[nodiscard]] constexpr Bivector invert(const Bivector& localInertia) const noexcept {
            const double massInv = 1.0 / mass;
            const double mr2Inv = 1.0 / mr2;

            return Bivector {
                .wx = localInertia.yz * massInv,
                .wy = -localInertia.xz * massInv,
                .wz = localInertia.xy * massInv,
                .xy = localInertia.wz * mr2Inv,
                .xz = -localInertia.wy * mr2Inv,
                .yz = localInertia.wx * mr2Inv,
            };
        }

        /** invert(localB.cross(apply(localB)) + localForque) */
        [[nodiscard]] constexpr Bivector getAcceleration(const Bivector& localB, const Bivector& localForque) const noexcept {
            const double massInv = 1.0 / mass;
            const double mr2Inv = 1.0 / mr2;

            return {
                .wx = localForque.yz * massInv + localB.wy * localB.xy + localB.wz * localB.xz,
                .wy = -localForque.xz * massInv + localB.wz * localB.yz - localB.wx * localB.xy,
                .wz = localForque.xy * massInv - localB.wx * localB.xz - localB.wy * localB.yz,
                .xy = localForque.wz * mr2Inv,
                .xz = -localForque.wy * mr2Inv,
                .yz = localForque.wx * mr2Inv,
            };
        }

        [[nodiscard]] constexpr double getKineticEnergy(const Bivector& velocity) const noexcept {
            return velocity.antiWedge(operator()(velocity)) * 0.5;
        }

        [[nodiscard]] static constexpr InertiaLocalSphere fromXX(const double mass, const double xx) noexcept {
            return {
                .mass = mass,
                .mr2 = mass * xx * 2.0 ,
            };
        }

        [[nodiscard]] static constexpr InertiaLocalSphere fromR2(const double mass, const double r2) noexcept {
            return {
                .mass = mass,
                .mr2 = mass * r2,
            };
        }

        [[nodiscard]] static constexpr InertiaLocalSphere point(const double mass) noexcept {
            return {mass, 0.0};
        }

        [[nodiscard]] static constexpr InertiaLocalSphere cube(const double mass, const double rx) noexcept {
            return fromR2(mass, rx * rx * (2.0 / 3.0));
        }

        [[nodiscard]] static constexpr InertiaLocalSphere hollowSphere(const double mass, const double r) noexcept {
            return fromR2(mass, r * r * (2.0 / 3.0));
        }

        [[nodiscard]] static constexpr InertiaLocalSphere solidSphere(const double mass, const double r) noexcept {
            return fromR2(mass, r * r * (2.0 / 5.0));
        }
    };
}

// InertiaLocal.h

namespace pga3d {
    struct InertiaLocal {
        double mass = 0.0;
        double mryz = 0.0; // moment of inertia in plane yz (including both integral for (dm * y^2 and dm * z^2)
        double mrxz = 0.0;
        double mrxy = 0.0;

        [[nodiscard]] constexpr Bivector operator()(const Bivector& velocity) const noexcept {
            return Bivector {
              .wx = velocity.yz * mryz,
              .wy = -velocity.xz * mrxz,
              .wz = velocity.xy * mrxy,
              .xy = velocity.wz * mass,
              .xz = -velocity.wy * mass,
              .yz = velocity.wx * mass,
            };
        }

        [[nodiscard]] constexpr Bivector invert(const Bivector& localInertia) const noexcept {
            const double massInv = 1.0 / mass;

            return Bivector {
              .wx = localInertia.yz * massInv,
              .wy = -localInertia.xz * massInv,
              .wz = localInertia.xy * massInv,
              .xy = localInertia.wz / mrxy,
              .xz = -localInertia.wy / mrxz,
              .yz = localInertia.wx / mryz,
            };
        }

        /** invert(localB.cross(apply(localB)) + localForque) */
        [[nodiscard]] constexpr Bivector getAcceleration(const Bivector& localB, const Bivector& localForque) const noexcept {
            return Bivector {
              .wx = localForque.yz / mass + localB.wy * localB.xy + localB.wz * localB.xz,
              .wy = -localForque.xz / mass + localB.wz * localB.yz - localB.wx * localB.xy,
              .wz = localForque.xy / mass - localB.wx * localB.xz - localB.wy * localB.yz,
              .xy = (localForque.wz + localB.xz * localB.yz * (mrxz - mryz)) / mrxy,
              .xz = (-localForque.wy + localB.xy * localB.yz * (mryz - mrxy)) / mrxz,
              .yz = (localForque.wx + localB.xy * localB.xz * (mrxy - mrxz)) / mryz,
            };
        }

        [[nodiscard]] constexpr double getKineticEnergy(const Bivector& velocity) const noexcept {
            return velocity.antiWedge(operator()(velocity)) * 0.5;
        }

        // constructors
        [[nodiscard]] static constexpr InertiaLocal from(const InertiaLocalSphere& i) noexcept {
            return {
                .mass = i.mass,
                .mryz = i.mryz(),
                .mrxz = i.mrxz(),
                .mrxy = i.mrxy(),
            };
        }

        [[nodiscard]] static constexpr InertiaLocal symmetric(const double mass, const double mr2) noexcept {
            return {.mass = mass, .mryz = mr2, .mrxz = mr2, .mrxy = mr2};
        }

        [[nodiscard]] static constexpr InertiaLocal fromXXYYZZ(const double mass, const double xx, const double yy, const double zz) noexcept {
            return {
                .mass = mass,
                .mryz = (yy + zz) * mass,
                .mrxz = (xx + zz) * mass,
                .mrxy = (xx + yy) * mass,
            };
        }

        [[nodiscard]] static constexpr InertiaLocal point(const double mass) noexcept {
            return from(InertiaLocalSphere::point(mass));
        }

        [[nodiscard]] static constexpr InertiaLocal cube(const double mass, const double rx) noexcept {
            return from(InertiaLocalSphere::cube(mass, rx));
        }

        [[nodiscard]] static constexpr InertiaLocal cube(const double mass, const double rx, const double ry, const double rz) noexcept {
            constexpr double mult = 1.0 / 3.0;
            return fromXXYYZZ(mass, rx * rx * mult, ry * ry * mult, rz * rz * mult);
        }

        [[nodiscard]] static constexpr InertiaLocal hollowSphere(const double mass, const double r) noexcept {
            return from(InertiaLocalSphere::hollowSphere(mass, r));
        }

        [[nodiscard]] static constexpr InertiaLocal solidSphere(const double mass, const double r) noexcept {
            return from( InertiaLocalSphere::solidSphere(mass, r));
        }

        [[nodiscard]] static constexpr InertiaLocal solidEllipsoid(const double mass, const double rx, const double ry, const double rz) noexcept {
            constexpr double mult = 1.0 / 5.0;
            return fromXXYYZZ(mass, rx * rx * mult, ry * ry * mult, rz * rz * mult);
        }

        // rod along OX
        [[nodiscard]] static constexpr InertiaLocal rodX(const double mass, const double length) noexcept {
            const double rod = inertia::rodAlongAxis(length);
            return fromXXYYZZ(mass, rod, 0.0, 0.0);
        }

        // disk in plane YZ
        [[nodiscard]] static constexpr InertiaLocal diskYZ(const double mass, const double r, const double innerR = 0.0) noexcept {
            const double disk = inertia::diskXX(r, innerR);
            return fromXXYYZZ(mass, 0.0, disk, disk);
        }

        // cylinder with axis along OX
        [[nodiscard]] static constexpr InertiaLocal cylinderX(const double mass, const double length, const double r, const double innerR = 0.0) noexcept {
            const double disk = inertia::diskXX(r, 0.0);
            const double rod = inertia::rodAlongAxis(length);
            return fromXXYYZZ(mass, rod, disk, disk);
        }
    };
}

// InertiaMovedLocal.h

namespace pga3d {
    struct InertiaMovedLocal {
        Motor localToGlobal = {};
        InertiaLocal localInertia = {};

        [[nodiscard]] constexpr double mass() const noexcept {
            return localInertia.mass;
        }

        [[nodiscard]] constexpr Point centerOfMassPoint() const noexcept {
            return localToGlobal.sandwich(pga3d::PointCenter{}).toPointUnsafe();
        }

        [[nodiscard]] constexpr Bivector operator ()(const Bivector& globalB) const noexcept {
            const Bivector localB = localToGlobal.reversed().sandwich(globalB);
            const Bivector localI = localInertia(localB);
            return localToGlobal.sandwich(localI);
        }

        [[nodiscard]] constexpr Bivector invert(const Bivector& globalI) const noexcept {
            const Bivector localI = localToGlobal.reversed().sandwich(globalI);
            const Bivector localB = localInertia.invert(localI);
            return localToGlobal.sandwich(localB);
        }

        [[nodiscard]] constexpr Bivector getLocalAcceleration(const Bivector &globalVelocity,
                                                              const Bivector &globalForque) const noexcept {
            const Bivector localB = localToGlobal.reversed().sandwich(globalVelocity);
            const Bivector localF = localToGlobal.reversed().sandwich(globalForque);
            return localInertia.getAcceleration(localB, localF);
        }

        [[nodiscard]] constexpr Bivector getAcceleration(const Bivector &globalVelocity,
                                                         const Bivector &globalForque) const noexcept {
            const Bivector localA = getLocalAcceleration(globalVelocity, globalForque);
            return localToGlobal.sandwich(localA);
        }

        [[nodiscard]] constexpr double getKineticEnergy(const Bivector &globalVelocity) const noexcept {
            const Bivector localB = localToGlobal.reversed().sandwich(globalVelocity);
            return localInertia.getKineticEnergy(localB);
        }

        [[nodiscard]] constexpr InertiaMovedLocal movedBy(const Motor& m) const noexcept {
            return {
                .localToGlobal = m.geometric(localToGlobal),
                .localInertia = localInertia,
            };
        }

        [[nodiscard]] constexpr InertiaMovedLocal movedBy(const Translator& m) const noexcept {
            return {
                .localToGlobal = m.geometric(localToGlobal),
                .localInertia = localInertia,
            };
        }

        [[nodiscard]] constexpr InertiaMovedLocal movedBy(const Quaternion& m) const noexcept {
            return {
                .localToGlobal = m.geometric(localToGlobal),
                .localInertia = localInertia,
            };
        }
    };
}

// InertiaSummable.h

namespace pga3d {
    struct InertiaSummable {
        double ww = 0.0;
        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;
        double xx = 0.0;
        double yy = 0.0;
        double zz = 0.0;
        double xy = 0.0;
        double yz = 0.0;
        double xz = 0.0;

        [[nodiscard]] constexpr double mass() const noexcept {
            return ww;
        }

        [[nodiscard]] constexpr Point centerOfMass() const noexcept {
            const double inv = 1.0 / mass();
            return {.x = wx * inv, .y = wy * inv, .z = wz * inv};
        }

        [[nodiscard]] constexpr ProjectivePoint centerOfMassProjective() const noexcept {
            return {.x = wx , .y = wy , .z = wz, .w = ww};
        }

        [[nodiscard]] constexpr double normSquare() const noexcept {
            return ww * ww + wx * wx + wy * wy + wz * wz + xx * xx + yy * yy + zz * zz + xy * xy + yz * yz + xz * xz;
        }

        [[nodiscard]] constexpr Bivector operator()(const Bivector& b) const noexcept {
            return {
                .wx = +(yy + zz) * b.yz + xy * b.xz - xz * b.xy - wz * b.wy + wy * b.wz,
                .wy = -xy * b.yz - (xx + zz) * b.xz - yz * b.xy - wx * b.wz + wz * b.wx,
                .wz = -xz * b.yz + yz * b.xz + (xx + yy) * b.xy + wx * b.wy - wy * b.wx,
                .xy = ww * b.wz + wx * b.xz + wy * b.yz,
                .xz = -ww * b.wy - wx * b.xy + wz * b.yz,
                .yz = ww * b.wx - wy * b.xy - wz * b.xz,
            };
        }

    private:
        [[nodiscard]] constexpr InertiaSummable movedByImpl(auto mapProjectivePoint) const noexcept {
            const ProjectivePoint cx = mapProjectivePoint(ProjectivePoint{xx, xy , xz, wx});
            const ProjectivePoint cy = mapProjectivePoint(ProjectivePoint{xy, yy, yz, wy});
            const ProjectivePoint cz = mapProjectivePoint(ProjectivePoint{xz, yz, zz, wz});
            const ProjectivePoint cw = mapProjectivePoint(ProjectivePoint{wx, wy, wz, ww});

            const ProjectivePoint rx = mapProjectivePoint(ProjectivePoint{cx.x, cy.x, cz.x, cw.x});
            const ProjectivePoint ry = mapProjectivePoint(ProjectivePoint{cx.y, cy.y, cz.y, cw.y});
            const ProjectivePoint rz = mapProjectivePoint(ProjectivePoint{cx.z, cy.z, cz.z, cw.z});
            const ProjectivePoint rw = mapProjectivePoint(ProjectivePoint{cx.w, cy.w, cz.w, cw.w});

            return {
                .ww = rw.w,
                .wx = rw.x,
                .wy = rw.y,
                .wz = rw.z,
                .xx = rx.x,
                .yy = ry.y,
                .zz = rz.z,
                .xy = rx.y,
                .yz = ry.z,
                .xz = rx.z
            };
        }
    public:

        [[nodiscard]] constexpr InertiaSummable movedBy(const Motor& m) const noexcept {
            return movedByImpl([&](const ProjectivePoint& p) { return m.sandwich(p); });
        }

        [[nodiscard]] constexpr InertiaSummable movedBy(const Translator& m) const noexcept {
            return movedByImpl([&](const ProjectivePoint& p) { return m.sandwich(p); });
        }

        [[nodiscard]] constexpr InertiaSummable movedBy(const Quaternion& m) const noexcept {
            return movedByImpl([&](const ProjectivePoint& p) { return m.sandwich(p); });
        }

        [[nodiscard]] static constexpr InertiaSummable point(const Point& p, double mass) noexcept {
            // inertia of a mass in a point = symmetricProduct(p.toProjectivePoint, p * mass)
            return {
                .ww = mass,
                .wx = p.x * mass,
                .wy = p.y * mass,
                .wz = p.z * mass,
                .xx = p.x * p.x * mass,
                .yy = p.y * p.y * mass,
                .zz = p.z * p.z * mass,
                .xy = p.x * p.y * mass,
                .yz = p.y * p.z * mass,
                .xz = p.x * p.z * mass,
            };
        }

        [[nodiscard]] static constexpr InertiaSummable from(const InertiaLocalSphere& inertia) noexcept {
            return {
                .ww = inertia.mass,
                .wx = 0.0,
                .wy = 0.0,
                .wz = 0.0,
                .xx = inertia.mr2 * 0.5,
                .yy = inertia.mr2 * 0.5,
                .zz = inertia.mr2 * 0.5,
                .xy = 0.0,
                .yz = 0.0,
                .xz = 0.0,
            };
        }

        [[nodiscard]] static constexpr InertiaSummable from(const InertiaLocal& inertia) noexcept {
            const double mrxyz2 = (inertia.mrxy + inertia.mrxz + inertia.mryz) * 0.5;

            const double mrx2 = mrxyz2 - inertia.mryz;
            const double mry2 = mrxyz2 - inertia.mrxz;
            const double mrz2 = mrxyz2 - inertia.mrxy;

            return {
                .ww = inertia.mass,
                .wx = 0.0,
                .wy = 0.0,
                .wz = 0.0,
                .xx = mrx2,
                .yy = mry2,
                .zz = mrz2,
                .xy = 0.0,
                .yz = 0.0,
                .xz = 0.0
            };
        }

        [[nodiscard]] static constexpr InertiaSummable from(const InertiaMovedLocal& inertia) noexcept {
            return from(inertia.localInertia).movedBy(inertia.localToGlobal);
        }
    };

    [[nodiscard]] constexpr InertiaSummable operator+(const InertiaSummable& a, const InertiaSummable& b) noexcept {
        return {
            .ww = a.ww + b.ww,
            .wx = a.wx + b.wx,
            .wy = a.wy + b.wy,
            .wz = a.wz + b.wz,
            .xx = a.xx + b.xx,
            .yy = a.yy + b.yy,
            .zz = a.zz + b.zz,
            .xy = a.xy + b.xy,
            .yz = a.yz + b.yz,
            .xz = a.xz + b.xz
        };
    }

    [[nodiscard]] constexpr InertiaSummable& operator+=(InertiaSummable& a, const InertiaSummable& b) noexcept {
        a = a + b;
        return a;
    }

    [[nodiscard]] constexpr InertiaSummable operator-(const InertiaSummable& a, const InertiaSummable& b) noexcept {
        return {
            .ww = a.ww - b.ww,
            .wx = a.wx - b.wx,
            .wy = a.wy - b.wy,
            .wz = a.wz - b.wz,
            .xx = a.xx - b.xx,
            .yy = a.yy - b.yy,
            .zz = a.zz - b.zz,
            .xy = a.xy - b.xy,
            .yz = a.yz - b.yz,
            .xz = a.xz - b.xz
        };
    }

    [[nodiscard]] constexpr InertiaSummable& operator-=(InertiaSummable& a, const InertiaSummable& b) noexcept {
        a = a - b;
        return a;
    }

    [[nodiscard]] constexpr InertiaSummable operator*(const InertiaSummable& a, double mult) noexcept {
        return {
            .ww = a.ww * mult,
            .wx = a.wx * mult,
            .wy = a.wy * mult,
            .wz = a.wz * mult,
            .xx = a.xx * mult,
            .yy = a.yy * mult,
            .zz = a.zz * mult,
            .xy = a.xy * mult,
            .yz = a.yz * mult,
            .xz = a.xz * mult
        };
    }

    [[nodiscard]] constexpr InertiaSummable operator*(double mult, const InertiaSummable& a) noexcept {
        return a * mult;
    }

    [[nodiscard]] constexpr InertiaSummable& operator*=(InertiaSummable& a, double mult) noexcept {
        a = a * mult;
        return a;
    }
}

// LinearOperator.h

namespace pga3d {
    template<typename T>
    concept PgaElem = requires(T obj)
    {
        { T::componentsCount } -> std::convertible_to<std::size_t>;
        { obj.toArray() } -> std::same_as<std::array<double, T::componentsCount>>;
        { T::from(std::array<double, T::componentsCount>{}) } -> std::same_as<T>;
    };

    template<PgaElem T>
    struct LinearOperator {
        static constexpr size_t size = T::componentsCount;
        static constexpr size_t squaredSize = size * size;

        std::array<double, T::componentsCount * T::componentsCount> matrix;

        constexpr T operator()(const T& a) const noexcept {
            const auto& aArray = a.toArray();
            std::array<double, T::componentsCount> result;

            for (int i = 0; i < T::componentsCount; ++i) {
                double elem = 0.0;
                for (int j = 0; j < T::componentsCount; ++j) {
                    elem += matrix[i * size + j] * aArray[j];
                }
                result[i] = elem;
            }

            return T::from(result);
        }

        template<class MapFunc>
        static constexpr LinearOperator create(MapFunc func) noexcept
            requires std::regular_invocable<MapFunc&, const T&> && std::same_as<std::invoke_result_t<MapFunc, const T&>, T> {

            LinearOperator result;

            for (size_t i = 0; i < size; ++i) {
                std::array<double, size> arr = {};
                arr[i] = 1.0;

                const T probe = T::from(arr);
                std::array<double, size> map = func(probe).toArray();

                for (size_t j = 0; j < size; ++j) {
                    result.matrix[i + j * size] = map[j];
                }
            }

            return result;
        }

        friend std::ostream& operator<<(std::ostream& os, const LinearOperator<T>& op) {
            os << "LinearOperator([";
            for (size_t i = 0; i < size; ++i) {
                os << "[";
                for (size_t j = 0; j < size; ++j) {
                    os << op.matrix[i * size + j];
                    if (j < T::componentsCount - 1) os << ", ";
                }
                os << "]";
                if (i < size - 1) os << ", ";
            }
            os << "])";
            return os;
        }
    };

    constexpr  LinearOperator<ProjectivePoint> linearOperatorForSandwichForProjectivePoint(const Motor& motor) {
        return LinearOperator<ProjectivePoint>{ motor.sandwichAsMatrixForProjectivePoint() };
    }

    constexpr  LinearOperator<ProjectivePoint> linearOperatorForSandwichForProjectivePoint(const Quaternion& q) {
        return LinearOperator<ProjectivePoint>{ q.sandwichAsMatrixForProjectivePoint() };
    }
}

// BodyState.h

namespace pga3d {
    struct BodyState {
        Motor motor = {};
        Bivector localB = {};

        static constexpr BodyState id() noexcept {
            return {
                .motor = Motor::id(),
                .localB = {},
            };
        }

        static constexpr BodyState zero() noexcept {
            return {
                .motor = {},
                .localB = {},
            };
        }

        [[nodiscard]] BodyState madd(const BodyState& other, double t) const noexcept {
            return {
                .motor = motor.madd(other.motor, t),
                .localB = localB.madd(other.localB, t),
            };
        }

        [[nodiscard]] BodyState renormalized() const noexcept {
            return {
                .motor = motor.renormalized(),
                .localB = localB,
            };
        }

        [[nodiscard]] constexpr Point localPosToGlobal(const Point& localPos) const noexcept {
            return motor.sandwich(localPos).toPointUnsafe();
        }

        [[nodiscard]] constexpr Point globalPosToLocal(const Point& globalPos) const noexcept {
            return motor.reversed().sandwich(globalPos).toPointUnsafe();
        }

        [[nodiscard]] constexpr Vector globalVelocityForLocalPos(const Point& localPos) const noexcept {
            return motor.sandwich(localPos.cross(localB));
        }
    };

    [[nodiscard]] constexpr BodyState operator+(const BodyState& a, const BodyState& b) noexcept {
        return {
            .motor = a.motor + b.motor,
            .localB = a.localB + b.localB,
        };
    }

    constexpr BodyState& operator+=(BodyState& a, const BodyState& b) noexcept {
        a = a + b;
        return a;
    }

    [[nodiscard]] constexpr BodyState operator-(const BodyState& a, const BodyState& b) noexcept {
        return {
            .motor = a.motor - b.motor,
            .localB = a.localB - b.localB,
        };
    }

    constexpr BodyState& operator-=(BodyState& a, const BodyState& b) noexcept {
        a = a - b;
        return a;
    }

    [[nodiscard]] constexpr BodyState operator*(const BodyState& a, double mult) noexcept {
        return {
            .motor = a.motor * mult,
            .localB = a.localB * mult,
        };
    }

    constexpr BodyState& operator*=(BodyState& a, double mult) noexcept {
        a = a * mult;
        return a;
    }

    [[nodiscard]] constexpr BodyState operator*(double mult, const BodyState& a) noexcept {
        return a * mult;
    }
}

// PhysicsBody.h

namespace pga3d {
    struct PhysicsBody {
        InertiaMovedLocal inertia = {};
        BodyState state = {};
        Bivector globalForqueAccumulator = {};

        [[nodiscard]] constexpr Bivector globalForque() const noexcept {
            return globalForqueAccumulator;
        }

        [[nodiscard]] constexpr Bivector localForque() const noexcept {
            return state.motor.reversed().sandwich(globalForque());
        }

        constexpr void resetForqueAccum() noexcept {
            globalForqueAccumulator = {};
        }

        constexpr void addGlobalForque(const Bivector& globalForque) noexcept {
            globalForqueAccumulator += globalForque;
        }

        /** Otherwise it's too easy to forget adding paired force */
        constexpr void addGlobalForquePaired(const Bivector &globalForque, PhysicsBody &other) noexcept {
            globalForqueAccumulator += globalForque;
            other.globalForqueAccumulator -= globalForque;
        }

        [[nodiscard]] constexpr BodyState stateDerivative() const noexcept {
            return BodyState{
                .motor = state.motor.geometric(state.localB) * -0.5,
                .localB = inertia.getAcceleration(state.localB, localForque())
            };
        }

        [[nodiscard]] constexpr double kineticEnergy() const noexcept {
            return state.localB.antiWedge(inertia(state.localB)) * 0.5;
        }

        [[nodiscard]] constexpr Bivector impulse() const noexcept {
            return state.motor.sandwich(inertia(state.localB));
        }

        [[nodiscard]] constexpr Point localPosToGlobal(const Point& localPos) const noexcept {
            return state.localPosToGlobal(localPos);
        }

        [[nodiscard]] constexpr Point globalPosToLocal(const Point& localPos) const noexcept {
            return state.globalPosToLocal(localPos);
        }

        [[nodiscard]] constexpr Point globalCenterOfMass() const noexcept {
            return localPosToGlobal(inertia.centerOfMassPoint());
        }

        [[nodiscard]] constexpr Vector globalVelocityForLocalPos(const Point& localPos) const noexcept {
            return state.globalVelocityForLocalPos(localPos);
        }
    };

    [[nodiscard]] constexpr double energy(const PhysicsBody &body) noexcept {
        return body.kineticEnergy();
    }
    static_assert(HasEnergy<PhysicsBody>);
}

// BodyPoint.h

namespace pga3d {
    struct BodyPoint {
        PhysicsBody* body = nullptr;
        Point localPoint = {};

        [[nodiscard]] constexpr Point globalPos() const noexcept {
            return body->localPosToGlobal(localPoint);
        }

        [[nodiscard]] constexpr Vector globalPosVelocity() const noexcept {
            return body->globalVelocityForLocalPos(localPoint);
        }
    };
}

// BodyLine.h

namespace pga3d {
    struct BodyLine {
        PhysicsBody* body = nullptr;
        Bivector localLine = {};

        [[nodiscard]] constexpr Bivector globalLine() const {
            return body->state.motor.sandwich(localLine);
        }
    };
}

// PhysicsBodyConnection.h

namespace pga3d {
    template<class T>
    concept HasAddForqueMethod =
            requires(T &obj) {
                { obj.addForque() } -> std::same_as<void>;
            };

    template<class T>
    concept HasBeforeStepMethod =
            requires(T &obj) {
                { obj.beforeStep() } -> std::same_as<void>;
            };

    template<class T>
    concept HasAfterStepMethod =
            requires(T &obj) {
                { obj.afterStep() } -> std::same_as<void>;
            };
}

// Friction.h

namespace pga3d {
    struct VelocityFriction {
        double linearK = 0.0;
        double quadraticK = 0.0;
        double maxForce = 0.0;

        [[nodiscard]] constexpr bool isZero() const noexcept {
            return maxForce == 0.0;
        }

        [[nodiscard]] constexpr double operator()(double velocity) const noexcept {
            const double sign = velocity > 0.0 ? 1.0 : -1.0;
            const double f = velocity * ( -linearK - velocity * quadraticK * sign);
            return std::clamp(f, -maxForce, maxForce);
        }

        [[nodiscard]] Vector operator()(const Vector& velocity) const noexcept {
            const Vector f = velocity * (-linearK - quadraticK * velocity.norm());
            return f.clamp(
                {-maxForce, -maxForce, -maxForce},
                {maxForce, maxForce, maxForce}
            );
        }

        [[nodiscard]] constexpr static VelocityFriction linear(const double k, const double maxForce) noexcept {
            return {k, 0.0, maxForce};
        }

        [[nodiscard]] constexpr static VelocityFriction quadratic(const double k2, const double maxForce) noexcept {
            return {0.0, k2, maxForce};
        }

        [[nodiscard]] constexpr static VelocityFriction constant(const double maxForce, const double minVelocity) noexcept {
            return {maxForce / minVelocity, 0.0, maxForce};
        }
    };

    struct PositionFrictionStiffness {
        double linearK = 0.0;
        double maxDelta = 0.0;

        [[nodiscard]] constexpr double getMaxForce() const noexcept {
            return maxDelta * linearK;
        }

        constexpr void setMaxForce(const double maxForce, const double newMaxDelta) noexcept {
            linearK = maxForce / newMaxDelta;
            maxDelta = newMaxDelta;
        }

        [[nodiscard]] constexpr bool isZero() const noexcept {
            return linearK == 0.0;
        }

        [[nodiscard]] constexpr static PositionFrictionStiffness create(const double maxForce, const double maxDetla) noexcept {
            return {
                .linearK = maxForce / maxDetla,
                .maxDelta = maxDetla,
            };
        }
    };

    struct Position1dFriction {
        PositionFrictionStiffness stiffness;
        double boundPosition = 0.0;

        [[nodiscard]] constexpr double getMaxForce() const noexcept {
            return stiffness.getMaxForce();
        }

        constexpr void setMaxForce(const double maxForce, const double newMaxDelta) noexcept {
            stiffness.setMaxForce(maxForce, newMaxDelta);
        }

        [[nodiscard]] constexpr bool isZero() const noexcept {
            return stiffness.isZero();
        }

        [[nodiscard]] constexpr double operator()(const double position) const noexcept {
            return std::clamp(boundPosition - position, -stiffness.maxDelta, stiffness.maxDelta) * stiffness.linearK;
        }

        constexpr void correctBoundPosition(const double position) noexcept {
            boundPosition = std::clamp(boundPosition, position - stiffness.maxDelta, position + stiffness.maxDelta);
        }

        [[nodiscard]] constexpr static Position1dFriction create(const double maxForce, const double maxDelta) noexcept {
            return {
                .stiffness = PositionFrictionStiffness::create(maxForce, maxDelta),
                .boundPosition = 0.0
            };
        }
    };

    struct Position3dFriction {
        PositionFrictionStiffness stiffness;
        Point boundPosition = {}; // in local coords
        [[nodiscard]] constexpr double getMaxForce() const noexcept {
            return stiffness.getMaxForce();
        }

        constexpr void setMaxForce(const double maxForce, const double newMaxDelta) noexcept {
            stiffness.setMaxForce(maxForce, newMaxDelta);
        }

        [[nodiscard]] constexpr bool isZero() const noexcept {
            return stiffness.isZero();
        }

        inline void correctBoundPosition(const Point& position) noexcept {
            boundPosition = Sphere{position, stiffness.maxDelta}.clamp(boundPosition);
        }

        [[nodiscard]] constexpr static Position3dFriction create(const double maxForce, const double maxDelta) noexcept {
            return {
                .stiffness = PositionFrictionStiffness::create(maxForce, maxDelta),
                .boundPosition = {}
            };
        }

        [[nodiscard]] static Bivector getForque(const PositionFrictionStiffness& stiffness,
                                                const Point& newPosition,
                                                const Point& globalBoundPosition) noexcept {
            const Vector targetShift = Sphere{newPosition, stiffness.maxDelta}.clampDR(globalBoundPosition);
            return Forque::force(newPosition, targetShift * stiffness.linearK);
        }
    };

    struct Point3dFriction {
        Position3dFriction positionFriction = {};
        VelocityFriction velocityFriction = {};
        BodyPoint first = {};
        PhysicsBody* second = nullptr;

        [[nodiscard]] Bivector getForque() const {
            const Point firstPos = first.globalPos();
            const Point secondPos = second->localPosToGlobal(positionFriction.boundPosition);

            const Vector firstVelocity = first.globalPosVelocity();
            const Vector secondVelocity = second->globalVelocityForLocalPos(positionFriction.boundPosition);

            return
                Position3dFriction::getForque(positionFriction.stiffness, firstPos, secondPos) +
                Forque::force(firstPos, velocityFriction(firstVelocity - secondVelocity));
        }

        void addForque() const {
            first.body->addGlobalForquePaired(getForque(), *second);
        }

        void afterStep() {
            const Point firstPointInSecond = second->globalPosToLocal(first.globalPos());
            positionFriction.correctBoundPosition(firstPointInSecond);
        }
    };
}

// Spring.h

namespace pga3d {
    struct SpringConfig {
        VelocityFriction velocityFriction{};
        Position1dFriction positionFriction{};
        double k = 0.0;
        double targetR = 0.0;
        bool noPush = false;
        bool noPull = false;

        void addForque(const BodyPoint &first, const BodyPoint &second, auto processResult) const noexcept {
            const Point pos1 = first.globalPos();
            const Point pos2 = second.globalPos();
            const Vector dPos = pos2 - pos1;
            const double r2 = dPos.normSquare();
            if (r2 <= targetR * targetR) {
                if (noPush) return;
            } else {
                if (noPull) return;
            }

            const double r = std::sqrt(r2);

            double frictionForce = 0.0;
            if (!velocityFriction.isZero()) {
                const Vector velocity1 = first.globalPosVelocity();
                const Vector velocity2 = second.globalPosVelocity();
                const Vector dv = velocity2 - velocity1;
                const double sign = dPos.antiDot(dv).i;
                frictionForce += velocityFriction(sign * dv.norm());
            }
            frictionForce += positionFriction(r);

            const double mult = (k * (r - targetR) - frictionForce) / (r + 1e-100);
            const Bivector forque = pos1.antiWedge(dPos) * mult;

            processResult(forque);
        }

        void addForque(const BodyPoint &first, const BodyPoint &second) const noexcept {
            addForque(first, second, [&](const Bivector& forque) {
                first.body->addGlobalForquePaired(forque, *second.body);
            });
        }

        [[nodiscard]] Bivector getForque(const BodyPoint &first, const BodyPoint &second) const noexcept {
            Bivector result = {};
            addForque(first, second, [&](const Bivector& forque) {
                result = forque;
            });
            return result;
        }

        [[nodiscard]] double getEnergy(const BodyPoint &first, const BodyPoint &second) const noexcept {
            const Point pos1 = first.globalPos();
            const Point pos2 = second.globalPos();
            const Vector dPos = pos2 - pos1;
            const double r2 = dPos.normSquare();
            if (r2 <= targetR * targetR) {
                if (noPush) return 0.0;
            } else {
                if (noPull) return 0.0;
            }
            const double r = std::sqrt(r2);
            const double dr = r - targetR;
            return 0.5 * k * dr * dr;
        }

        void afterStep(const BodyPoint& first, const BodyPoint& second) noexcept {
            const Point pos1 = first.globalPos();
            const Point pos2 = second.globalPos();
            const Vector dPos = pos2 - pos1;
            const double r = dPos.normSquare();
            positionFriction.correctBoundPosition(r);
        }
    };

    struct Spring {
        SpringConfig config;
        BodyPoint first;
        BodyPoint second;

        void addForque() const noexcept {
            config.addForque(first, second);
        }

        [[nodiscard]] Bivector getForque() const noexcept {
            return config.getForque(first, second);
        }

        void afterStep() noexcept {
            config.afterStep(first, second);
        }

        [[nodiscard]] double energy() const noexcept {
            return config.getEnergy(first, second);
        }
    };

    static_assert(HasEnergy<Spring>);
    static_assert(HasAddForqueMethod<Spring>);
    static_assert(HasAfterStepMethod<Spring>);
}

// PhysicsBodyConnections.h

namespace pga3d {
    template<class Connection> requires HasAddForqueMethod<Connection>
    struct PhysicsBodyConnections {
        std::vector<Connection> elems;

        void beforeStep() {
            if constexpr (HasBeforeStepMethod<Connection>) {
                for (auto &elem: elems) {
                    elem.beforeStep();
                }
            }
        }

        void addForque() const {
            for (const auto &elem: elems) {
                elem.addForque();
            }
        }

        void afterStep() {
            if constexpr (HasAfterStepMethod<Connection>) {
                for (auto &elem: elems) {
                    elem.afterStep();
                }
            }
        }
    };

    template<HasEnergy Connection>
    [[nodiscard]] double energy(const PhysicsBodyConnections<Connection> &connections) {
        return energy(connections.elems);
    }

    static_assert(HasEnergy<Spring>);
    static_assert(HasEnergy<PhysicsBodyConnections<Spring> >);
}

// Gravity.h

namespace pga3d {
    struct GravitySystem {
        Vector gravity{};

        void addForques(std::span<PhysicsBody> bodies) const noexcept {
            if (gravity == Vector{}) return;

            for (auto &body: bodies) {
                body.addGlobalForque(Forque::force(body.globalCenterOfMass(), body.inertia.mass() * gravity));
            }
        }

        [[nodiscard]] constexpr double energy(std::span<const PhysicsBody> bodies) const noexcept {
            if (gravity == Vector{}) return 0.0;
            double totalEnergy = 0.0;
            for (auto &body: bodies) {
                totalEnergy -= gravity.antiDot(body.globalCenterOfMass()).i;
            }
            return totalEnergy;
        }
    };
}

// SpringToLine.h

namespace pga3d {
    struct SpringToLineConfig {
        double k = 0.0;

        [[nodiscard]] Bivector getForque(const BodyLine &bodyLine, const BodyPoint &bodyPoint) const noexcept {
            const Bivector line = bodyLine.globalLine();
            const Point pos2 = bodyPoint.globalPos();

            const Point posOnLine = pos2.projectOntoLine(line).toPoint();
            return Forque::force(posOnLine, pos2) * k;
        }

        void addForque(const BodyLine &bodyLine, const BodyPoint &bodyPoint) const noexcept {
            const Bivector forque = getForque(bodyLine, bodyPoint);
            bodyLine.body->addGlobalForquePaired(forque, *bodyPoint.body);
        }

        [[nodiscard]] constexpr double getEnergy(const BodyLine &bodyLine, const BodyPoint &bodyPoint) const noexcept {
            const Bivector line = bodyLine.globalLine();
            const Point pos2 = bodyPoint.globalPos();
            const Point posOnLine = pos2.projectOntoLine(line).toPoint();
            const double r2 = (pos2 - posOnLine).normSquare();
            return 0.5 * k * r2;
        }
    };

    struct SpringToLine {
        SpringToLineConfig config;
        BodyLine line;
        BodyPoint point;

        void addForque() const noexcept {
            config.addForque(line, point);
        }

        [[nodiscard]] Bivector getForque() const noexcept {
            return config.getForque(line, point);
        }

        [[nodiscard]] constexpr double energy() const noexcept {
            return config.getEnergy(line, point);
        }
    };

    static_assert(HasEnergy<SpringToLine>);
    static_assert(HasAddForqueMethod<SpringToLine>);
}

// Torsion.h

namespace pga3d {
    struct TorsionConfig {
        double kNperRad = 0.0;

        void calculateForque(const BodyPoint &first,
                             const BodyPoint &second,
                             const BodyLine &axis,
                             auto onResult) const noexcept {
            const Point firstGlobalPos = first.globalPos();
            const Point secondGlobalPos = second.globalPos();

            const Bivector axisGlobalLine = axis.globalLine();

            const Point firstProjectedToLine = firstGlobalPos.projectOntoLine(axisGlobalLine).toPoint();
            const Point secondProjectedToLine = secondGlobalPos.projectOntoLine(axisGlobalLine).toPoint();

            const Vector dr1 = firstGlobalPos - firstProjectedToLine;
            const Vector dr2 = secondGlobalPos - secondProjectedToLine;

            const double dr1NormSquare = dr1.normSquare();
            const double dr2NormSquare = dr2.normSquare();

            const double dr1Dr2Norm = std::sqrt(dr1NormSquare * dr2NormSquare);

            if (dr1Dr2Norm < 1e-100) return;

            const BivectorBulk momentum = (dr1.dual().geometric(dr2.dual()) / dr1Dr2Norm).log() * kNperRad;

            const BivectorWeight f1 = Translator::addVector(dr1).sandwich(-momentum).weight() / dr1NormSquare;
            const Vector force1 = Vector(f1.wx, f1.wy, f1.wz);

            const BivectorWeight f2 = Translator::addVector(dr2).sandwich(momentum).weight() / dr2NormSquare;
            const Vector force2 = Vector(f2.wx, f2.wy, f2.wz);

            const Bivector mf1 = Forque::force(firstGlobalPos, force1);
            const Bivector mf2 = Forque::force(secondGlobalPos, force2);

            onResult(mf1, mf2);
        }

        [[nodiscard]] double getEnergy(const BodyPoint &first,
                                       const BodyPoint &second,
                                       const BodyLine &axis) const noexcept {
            const Point firstGlobalPos = first.globalPos();
            const Point secondGlobalPos = second.globalPos();

            const Bivector axisGlobalLine = axis.globalLine();

            const Point firstProjectedToLine = firstGlobalPos.projectOntoLine(axisGlobalLine).toPoint();
            const Point secondProjectedToLine = secondGlobalPos.projectOntoLine(axisGlobalLine).toPoint();

            const Vector dr1 = firstGlobalPos - firstProjectedToLine;
            const Vector dr2 = secondGlobalPos - secondProjectedToLine;

            const double dr1NormSquare = dr1.normSquare();
            const double dr2NormSquare = dr2.normSquare();

            const double dr1Dr2Norm = std::sqrt(dr1NormSquare * dr2NormSquare);

            if (dr1Dr2Norm < 1e-100) return 0.0;

            const BivectorBulk rotationAngle = (dr1.dual().geometric(dr2.dual()) / dr1Dr2Norm).log();
            return 0.5 * kNperRad * rotationAngle.normSquare();
        }

        void addForque(const BodyPoint &first, const BodyPoint &second, const BodyLine &axis) const noexcept {
            calculateForque(first, second, axis, [&](const Bivector &mf1, const Bivector &mf2) {
                first.body->addGlobalForquePaired(mf1, *axis.body);
                second.body->addGlobalForquePaired(mf2, *axis.body);
            });
        }

        [[nodiscard]] std::pair<Bivector, Bivector> getTorque(const BodyPoint &first, const BodyPoint &second,
                                                              const BodyLine &axis) const noexcept {
            std::pair<Bivector, Bivector> result = {};

            calculateForque(first, second, axis, [&](const Bivector &mf1, const Bivector &mf2) {
                result.first = mf1;
                result.second = mf2;
            });

            return result;
        }
    };

    struct Torsion {
        TorsionConfig config = {};

        BodyPoint first = {};
        BodyPoint second = {};
        BodyLine axis = {};

        void addForque() const noexcept {
            config.addForque(first, second, axis);
        }

        [[nodiscard]] std::pair<Bivector, Bivector> getForque() const noexcept {
            return config.getTorque(first, second, axis);
        }

        [[nodiscard]] double energy() const noexcept {
            return config.getEnergy(first, second, axis);
        }
    };

    static_assert(HasEnergy<Torsion>);
    static_assert(HasAddForqueMethod<Torsion>);
}

// PhysicsSolverRK4.h

namespace pga3d {
     class PhysicsSolverRK4 {
     private:
          std::vector<BodyState> initialStates;
          std::vector<BodyState> d1;
          std::vector<BodyState> d2;
          std::vector<BodyState> d3;
          std::vector<BodyState> d4;

          void updateSizes(size_t newSize) {
               initialStates.resize(newSize);
               d1.resize(newSize);
               d2.resize(newSize);
               d3.resize(newSize);
               d4.resize(newSize);
          }

          static void resetForqueAccumulators(std::span<PhysicsBody>& dynamicBodies) {
               for (PhysicsBody &body: dynamicBodies) {
                    body.resetForqueAccum();
               }
          }

          static void computeDerivativeInto(std::vector<BodyState> &result, const std::span<PhysicsBody>& dynamicBodies) {
               const size_t size = dynamicBodies.size();
               for (size_t pos = 0; pos < size; ++pos) {
                    result[pos] = dynamicBodies[pos].stateDerivative();
               }
          }

          void setFinalState(std::span<PhysicsBody>& dynamicBodies, const double dt) {
               const size_t size = dynamicBodies.size();
               for (size_t pos = 0; pos < size; ++pos) {
                    const BodyState dState =
                         d1[pos] * (dt * (1.0 / 6.0))
                        + d2[pos] * (dt * (1.0 / 3.0))
                        + d3[pos] * (dt * (1.0 / 3.0))
                        + d4[pos] * (dt * (1.0 / 6.0));

                    dynamicBodies[pos].state = (initialStates[pos] + dState).renormalized();
               }
          }

          void setNewState(std::span<PhysicsBody>& dynamicBodies, const double dt, const std::vector<BodyState> &derivative) {
               const size_t size = dynamicBodies.size();
               for (size_t pos = 0; pos < size; ++pos) {
                    dynamicBodies[pos].state = initialStates[pos].madd(derivative[pos], dt).renormalized();
               }
          }

          void setInitialState(const std::span<PhysicsBody>& dynamicBodies) {
               const size_t size = dynamicBodies.size();
               for (size_t pos = 0; pos < size; ++pos) {
                    initialStates[pos] = dynamicBodies[pos].state;
               }
          }

     public:
          void doStepRk4(std::span<PhysicsBody> dynamicBodies, const double dt, auto addForquesToBodies) {
               updateSizes(dynamicBodies.size());
               setInitialState(dynamicBodies);

               resetForqueAccumulators(dynamicBodies);
               addForquesToBodies(0.0);
               computeDerivativeInto(d1, dynamicBodies);
               
               setNewState(dynamicBodies, 0.5 * dt, d1);
               resetForqueAccumulators(dynamicBodies);
               addForquesToBodies(0.5);
               computeDerivativeInto(d2, dynamicBodies);

               setNewState(dynamicBodies, 0.5 * dt, d2);
               resetForqueAccumulators(dynamicBodies);
               addForquesToBodies(0.5);
               computeDerivativeInto(d3, dynamicBodies);

               setNewState(dynamicBodies, dt, d3);
               resetForqueAccumulators(dynamicBodies);
               addForquesToBodies(1.0);
               computeDerivativeInto(d4, dynamicBodies);

               setFinalState(dynamicBodies, dt);
          }
     };
}